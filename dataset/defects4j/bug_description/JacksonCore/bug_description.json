{
  "JacksonCore_1": {
    "description": "NullPointerException thrown when NaN read as BigDecimal\n(moved from https://github.com/FasterXML/jackson/issues/4 reported by @jroper)\n\n---\n\nIf `JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS` is turned on, then when NaN is encountered, it will be reported as being a float number token. Subsequently invoking getDecimalNumber throws an NPE:\n\n```\nNullPointerException: null (TextBuffer.java:394)\ncom.fasterxml.jackson.core.util.TextBuffer.contentsAsDecimal(TextBuffer.java:394)\ncom.fasterxml.jackson.core.base.ParserBase._parseSlowFloatValue(ParserBase.java:799)\ncom.fasterxml.jackson.core.base.ParserBase._parseNumericValue(ParserBase.java:781)\n com.fasterxml.jackson.core.base.ParserBase.getDecimalValue(ParserBase.java:711)\n```\n\nBy the way, the expected behaviour here I would say would be to throw NumberFormatException, this is what is thrown by the BigDecimal constructor when you pass in Double.NaN or any of the infinity double values.\n\nI'm not sure, but maybe this NPE is also an issue for integers too, and the expected behaviour for them would also be to throw NumberFormatException.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_2": {
    "description": "Parser parsers numbers eagerly; does not report error with missing space\n(note: moved from https://github.com/FasterXML/jackson-databind/issues/260)\n\n---\n\nIf you give input like:\n\n```\n123true\n```\n\nit will first successfully parse integer 123, and then boolean `true`. This should instead result in a parse exception.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_3": {
    "description": "_currInputRowStart isn't initialized in UTF8StreamJsonParser() constructor. The column position will be wrong. \nThe UTF8StreamJson Parser constructor allows to specify the start position. But it doesn't set the  \"_currInputRowStart\" as the same value. It is still 0. So when raise the exception, the column calculation (ParserBase.getCurrentLocation() )will be wrong.\n\nint col = _inputPtr - _currInputRowStart + 1; // 1-based\n\npublic UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_4": {
    "description": "What is the maximum key length allowed?\nI noticed that even in Jackson 2.4, if a JSON key is longer than 262144 bytes, ArrayIndexOutOfBoundsException is thrown from TextBuffer. Below is the stack trace:\n\n```\njava.lang.ArrayIndexOutOfBoundsException\n    at java.lang.System.arraycopy(Native Method)\n    at com.fasterxml.jackson.core.util.TextBuffer.expandCurrentSegment(TextBuffer.java:604)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2034)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.findName(UTF8StreamJsonParser.java:1928)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseLongFieldName(UTF8StreamJsonParser.java:1534)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseMediumFieldName(UTF8StreamJsonParser.java:1502)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseFieldName(UTF8StreamJsonParser.java:1437)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:668)\n    ... <below are our code> ...\n```\n\nLooking at TextBuffer.expandCurrentSegment(TextBuffer.java:604), once the length of _currentSegment is increased to MAX_SEGMENT_LEN + 1 (262145) bytes, the newLen will stay at MAX_SEGMENT_LEN, which is smaller than len. Therefore System.arraycopy() will fail.\n\nI understand it is rare to have key larger than 262144 bytes, but it would be nice if\n- Jackson explicitly throw exception stating that key is too long.\n- Document that the maximum key length is 262144 bytes.\n\nOR\n- Update TextBuffer to support super long key.\n\nThanks!\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_5": {
    "description": "An exception is thrown for a valid JsonPointer expression\nJson-Patch project leader has noted me that there is a bug on JsonPointer implementation and I have decided to investigate.\n\nBasically if you do something like `JsonPointer.compile(\"/1e0\");` it throws a NumberFormatExpcetion which is not true. This is because this piece of code:\n\n``` java\nprivate final static int _parseInt(String str)\n    {\n        final int len = str.length();\n        if (len == 0) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        // for now, we'll assume 32-bit indexes are fine\n        return NumberInput.parseInt(str);\n    }\n```\n\nWhen they found a number it interprets the segment as integer but in reality it should be the whole expression. For this reason I think that the condition should be changed to the inverse condition  (if it doesn't found any char then it is a number.\n\nIf you want I can send you a PR as well.\n\nAlex.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_6": {
    "description": "`JsonPointer` should not consider \"00\" to be valid index\nAlthough `00` can be parsed as `0` in some cases, it is not a valid JSON number; and is also not legal numeric index for JSON Pointer. As such, `JsonPointer` class should ensure it can only match property name \"00\" and not array index.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_7": {
    "description": "Add a check so `JsonGenerator.writeString()` won't work if `writeFieldName()` expected.\nLooks like calling `writeString()` (and perhaps other scalar write methods) results in writing invalid output, instead of throwing an exception. It should instead fail; in future we may want to consider allowing this as an alias, but at any rate it should not produce invalid output.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_8": {
    "description": "Inconsistent TextBuffer#getTextBuffer behavior\nHi, I'm using 2.4.2. While I'm working on CBORParser, I noticed that CBORParser#getTextCharacters() returns sometimes `null` sometimes `[]` (empty array) when it's parsing empty string `\"\"`.\n\nWhile debugging, I noticed that TextBuffer#getTextBuffer behaves inconsistently.\n\n```\nTextBuffer buffer = new TextBuffer(new BufferRecycler());\nbuffer.resetWithEmpty();\nbuffer.getTextBuffer(); // returns null\nbuffer.contentsAsString(); // returns empty string \"\"\nbuffer.getTextBuffer(); // returns empty array []\n```\n\nI think getTextBuffer should return the same value. Not sure which (`null` or `[]`) is expected though.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_9": {
    "description": "`JsonParser.getValueAsString()` should return field name for `JsonToken.FIELD_NAME`, not `null`\n(note: offshoot of https://github.com/FasterXML/jackson-databind/issues/745)\n\nAlthough Javadocs do not specify expected behavior for `JsonParser.getValueAsString()`, when current token is `JsonToken.FIELD_NAME`, it makes more sense to return name as-is, instead of null.\nThis will simplify handling of code that requires a String representation; and code that does need to know the difference can use token type if that is relevant.\n\nWhile this can be seen as a fix it is still a minor API change, so it needs to go in 2.6.0, not a 2.5.x patch release.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_10": {
    "description": "ArrayIndexOutOfBoundsException in com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer\nThe following code demonstrates a bug in jackson-core, version 2.6.0, in the hash table implementation of `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer`. From a quick glance, it looks to me as if the \"primary hash information area\" `_hashArea` has a spillover area that is not accounted for properly in the `String` array `_names`.\n\n``` java\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.testng.annotations.Test;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Map;\n\n/**\n * Simple test case for demonstrating bug in class {@link ByteQuadsCanonicalizer}.\n *\n * <p>In some cases, it is possible to work around this bug by disabling the\n * {@link JsonFactory.Feature#CANONICALIZE_FIELD_NAMES} feature. In that case\n * {@link com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper#constructParser(int, com.fasterxml.jackson.core.ObjectCodec, ByteQuadsCanonicalizer, com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer, int)}\n * creates a {@link com.fasterxml.jackson.core.json.ReaderBasedJsonParser} instead of a\n * {@link com.fasterxml.jackson.core.json.UTF8StreamJsonParser}.\n */\npublic class UTF8ByteStreamTest {\n    private static final int SEED = -523743345;\n\n    private static void injectReproducibleSeed(ObjectMapper objectMapper) throws Exception {\n        JsonFactory jsonFactory = objectMapper.getFactory();\n        // As a workaround, uncomment the following line.\n        // jsonFactory.disable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES);\n        Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\n        byteSymbolCanonicalizerField.setAccessible(true);\n\n        Method factoryMethod = ByteQuadsCanonicalizer.class.getDeclaredMethod(\"createRoot\", int.class);\n        factoryMethod.setAccessible(true);\n        byteSymbolCanonicalizerField.set(jsonFactory, factoryMethod.invoke(null, SEED));\n    }\n\n    @Test\n    public void testRead() throws Exception {\n        ObjectMapper objectMapper = new ObjectMapper();\n        injectReproducibleSeed(objectMapper);\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"{\\n\");\n        stringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\n        for (int i = 0; i < 60; ++i) {\n            stringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n        }\n        stringBuilder.append(\"\\n}\");\n        objectMapper.readValue(stringBuilder.toString().getBytes(StandardCharsets.UTF_8), Map.class);\n    }\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_11": {
    "description": "ArrayIndexOutOfBoundsException: 128 when repeatedly serializing to a byte array\n```\njava.lang.ArrayIndexOutOfBoundsException: 128\n    at com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:853)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.findName(UTF8StreamJsonParser.java:2224)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseLongName(UTF8StreamJsonParser.java:1831)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseMediumName2(UTF8StreamJsonParser.java:1786)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseMediumName(UTF8StreamJsonParser.java:1743)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1678)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextFieldName(UTF8StreamJsonParser.java:1007)\n    at com.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBindStringMap(MapDeserializer.java:471)\n    at com.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:341)\n    at com.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:26)\n    at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3702)\n    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2824)\n    at com.kryptnostic.services.v1.SmokeTests.spamAddIndexPair(SmokeTests.java:605)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:497)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n```\n\nRepro: \n\n```\n@Test\npublic void spamTest() {\n        ObjectMapper mapper = new ObjectMapper();\n        Map<ObjectUserKey, ServerIndexPair> ssip = Maps.newConcurrentMap();\n        for ( int i = 0; i < 10000; ++i ) {\n            byte[] indexPairBytes = new byte[ 2080 ];\n            new Random().nextBytes( indexPairBytes );\n            ServerIndexPair sip = new ServerIndexPair( indexPairBytes );\n\n            byte[] s = mapper.writeValueAsBytes( ImmutableMap.of( UUID\n                    .randomUUID().toString(), sip ) );\n            Map<String, ServerIndexPair> metadata = mapper.readValue( s,\n                    new TypeReference<Map<String, ServerIndexPair>>() {} );\n            for ( Entry<String, ServerIndexPair> metadataEntry : metadata.entrySet() ) {\n                ServerIndexPair indexPair = metadataEntry.getValue();\n                ssip.put( new ObjectUserKey( metadataEntry.getKey(), user ),\n                        indexPair );\n            }\n            logger.error( \"Iteration: {}\", i );\n        }\n}\n```\n\n```\npublic class ServerIndexPair {\n    public static final String INDEX_PAIR_FIELD = \"indexPair\";\n    private final byte[]       indexPair;\n\n    @JsonCreator\n    public ServerIndexPair( @JsonProperty( INDEX_PAIR_FIELD ) byte[] indexPair ) {\n        Preconditions.checkState( indexPair.length == 2080, \"Index pair must be 2080 bytes long.\" );\n        this.indexPair = indexPair;\n    }\n\n    @JsonProperty( INDEX_PAIR_FIELD )\n    public byte[] getIndexPair() {\n        return indexPair;\n    }\n}\n```\n\n```\npublic class ObjectUserKey {\n    public static final String SEPARATOR = \":\";\n    private final String       objectId;\n    private final UUID         userKey;\n\n    @JsonCreator\n    public ObjectUserKey(\n            @JsonProperty( Names.ID_FIELD ) String objectId,\n            @JsonProperty( Names.USER_FIELD ) UUID userKey ) {\n        super();\n        this.objectId = objectId;\n        this.userKey = userKey;\n    }\n\n    @JsonProperty( Names.ID_FIELD )\n    public String getObjectId() {\n        return objectId;\n    }\n\n    @JsonProperty( Names.USER_FIELD )\n    public UUID getUserKey() {\n        return userKey;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ( ( objectId == null ) ? 0 : objectId.hashCode() );\n        return result;\n    }\n\n    @Override\n    public boolean equals( Object obj ) {\n        if ( this == obj ) {\n            return true;\n        }\n        if ( obj == null ) {\n            return false;\n        }\n        if ( !( obj instanceof ObjectUserKey ) ) {\n            return false;\n        }\n        ObjectUserKey other = (ObjectUserKey) obj;\n        if ( objectId == null ) {\n            if ( other.objectId != null ) {\n                return false;\n            }\n        }\n        if ( userKey == null ) {\n            if ( other.userKey != null ) {\n                return false;\n            }\n        }\n        if ( !objectId.equals( other.objectId ) ) {\n            return false;\n        }\n        if ( !userKey.equals( other.userKey ) ) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return userKey + SEPARATOR + objectId;\n    }\n\n    public static ObjectUserKey fromString( String value ) {\n        int index = value.lastIndexOf( ObjectUserKey.SEPARATOR );\n        Preconditions.checkState( index > -1, \"Separator character \" + SEPARATOR\n                + \" should be present for ObjectUserKey\" );\n        String userKeyString = value.substring( 0, index );\n        String objectIdString = value.substring( index + 1 );\n        UUID userKey = UUID.fromString( userKeyString );\n        return new ObjectUserKey( objectIdString, userKey );\n    }\n\n    public byte[] asBytes() {\n        return this.toString().getBytes();\n    }\n\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_12": {
    "description": "JsonParser.getTokenLocation() doesn't update after field names.\nThere's a unit test to repro the issue below.  Basically, when you're on a FIELD_NAME token, if you call getTokenLocation() and then nextToken() and then getTokenLocation() again, you'll get the same location for both calls to getTokenLocation(), even though you've advanced to a new token.\n\nThe issue seems to be the _nextToken logic in ReaderBasedJsonParser and UTF8StreamJsonParser.  When calling nextToken() on a FIELD_NAME, it calls _nextAfterName(), which updates _currToken but doesn't update _tokenInputRow and _tokenInputCol for the new token's location.\n\nI started to try to fix it, but the _nextToken logic is spread across so much code that it looked like it'd be a pretty major surgery.  Not something I'm willing to do at this point. :-)\n\n```\npublic void testTokenLocationAfterFieldName() throws Exception\n{\n    _testTokenLocationAfterFieldName(false);\n    _testTokenLocationAfterFieldName(true);\n}\n\nprivate void _testTokenLocationAfterFieldName(Boolean useStream) throws Exception\n{\n    final String DOC = \"{\\\"name\\\":123}\";\n    JsonFactory jf = new JsonFactory();\n    JsonParser jp = useStream ?\n            jf.createJsonParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n            : jf.createJsonParser(new StringReader(DOC));\n\n    assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n    assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n    assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n    assertEquals(1, jp.getTokenLocation().getLineNr());\n    assertEquals(9, jp.getTokenLocation().getColumnNr());\n    jp.close();\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_13": {
    "description": "Fix UTF8JsonGenerator to allow QUOTE_FIELD_NAMES to be toggled.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_14": {
    "description": "Relax ownership checks for buffers not to require increase in size\nChecks in `IOContext` expect buffer to either be the same or grow. But it should actually be completely legal to return another buffer with similar size, given that most allocation strategies will eventually converge into maximum allowed block size.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_15": {
    "description": "Make use of `_allowMultipleMatches` in `FilteringParserDelegate`\nCurrently, it looks like that the _allowMultipleMatches attribute in FilteringGeneratorDelegate is not utilised (i.e. no value is assigned to this variable). Re. the documentation this attribute offers some useful functionality. So it would be nice, if it could be implemented properly. See https://groups.google.com/d/msg/jackson-user/VzZ94G9hvrs/JGFozl6lCQAJ\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_16": {
    "description": "JsonParserSequence skips a token on a switched Parser.\nHaving 2 parsers concatenated with `JsonParserSequence.createFlattened(parser1, parser2)`.\n\nIf the second parser is on a token that is not null and should not be skipped, the JsonParserSequence will still skip it. JsonParserSequence's [nextToken()](https://github.com/FasterXML/jackson-core/blob/master/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java#L102) calls nextToken() on the new delegate which may cause that we miss a token.\n\nFor more details : [forum question](http://jackson-users.ning.com/forum/topics/jsonparsersequence-behaviour-seems-misleading)\n\nI'll open a PR for this.\nThanks.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_17": {
    "description": "JsonGenerationException: Split surrogate on writeRaw() input thrown for input of a certain size\nIn short, I am seeing the following exception while processing text that includes valid multi-byte Unicode characters, and adding or removing characters before the \"problematic\" characters can affect whether the exception is thrown.\n\n`$ java -classpath .:../../jackson-core/target/jackson-core-2.8.2-SNAPSHOT.jar BadMsg\ncom.fasterxml.jackson.core.JsonGenerationException: Split surrogate on writeRaw() input (last character)\n    at com.fasterxml.jackson.core.JsonGenerator._reportError(JsonGenerator.java:1887)\n    at com.fasterxml.jackson.core.json.UTF8JsonGenerator._outputRawMultiByteChar(UTF8JsonGenerator.java:1916)\n    at com.fasterxml.jackson.core.json.UTF8JsonGenerator._writeSegmentedRaw(UTF8JsonGenerator.java:697)\n    at com.fasterxml.jackson.core.json.UTF8JsonGenerator.writeRaw(UTF8JsonGenerator.java:611)\n    at com.fasterxml.jackson.core.json.UTF8JsonGenerator.writeRaw(UTF8JsonGenerator.java:560)\n    at com.fasterxml.jackson.core.base.GeneratorBase.writeRawValue(GeneratorBase.java:306)\n    at BadMsg.main(BadMsg.java:17)\n`\n\nThe simplest way to demonstrate this is code, so I will attach a sample program with a document that causes the error. Sorry for the ugly redacted text, but you can imagine some real words and other interesting strings in place of all the x's. Note that if I delete or add enough of the 'x' characters (doesn't matter where in the JSON they appear, as long as it's before the character that causes the exception) the exception will not be thrown. I believe the problem is in buffering the data that is passed to the lower level functions, but I have not debugged to that level.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_18": {
    "description": "`OutOfMemoryError` when writing BigDecimal\n(note: moved from https://github.com/FasterXML/jackson-databind/issues/1316 reported by @gmethvin)\n\nWhen I've enabled the `WRITE_BIGDECIMAL_AS_PLAIN` setting on Jackson 2.7.5, Jackson will attempt to write out the whole number, no matter how large the exponent.\n\nFor example, the following code:\n\n``` java\nObjectMapper mapper = new ObjectMapper().enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\nmapper.writeValueAsString(new java.math.BigDecimal(\"9.223372E+1010671858\"));\n```\n\ntriggers the exception:\n\n```\njava.lang.OutOfMemoryError: Java heap space\n  at java.lang.AbstractStringBuilder.<init>(AbstractStringBuilder.java:68)\n  at java.lang.StringBuilder.<init>(StringBuilder.java:101)\n  at java.math.BigDecimal.toPlainString(BigDecimal.java:2964)\n  at com.fasterxml.jackson.core.json.WriterBasedJsonGenerator.writeNumber(WriterBasedJsonGenerator.java:690)\n  at com.fasterxml.jackson.databind.ser.std.NumberSerializer.serialize(NumberSerializer.java:45)\n  at com.fasterxml.jackson.databind.ser.std.NumberSerializer.serialize(NumberSerializer.java:19)\n  at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:130)\n  at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3612)\n  at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:2980)\n  ... 23 elided\n```\n\nI know technically Jackson is doing what you're telling it to do (so if you don't feel this is an issue feel free to close it). But it would be nice if `WRITE_BIGDECIMAL_AS_PLAIN` set a reasonable length on the number, so as not to leave users open to denial of service vulnerabilities.\n\n(Actually, I think this might technically be an issue in jackson-core; let me know if I should resubmit.)\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_19": {
    "description": "ArrayIndexOutOfBoundsException: 200 on floating point number with exactly 200-length decimal part\nVery similar issue to #160 and #157 \nWith `jackson-core 2.8.1` when attempting to parse fractional number that has exactly 200 numbers in the decimal part and some random fractional part then java.lang.ArrayIndexOutOfBoundsException: 200 is thrown.\n\n```\npublic class Test {\n    public static void main(String[] args) throws IOException {\n        StringBuilder input = new StringBuilder();\n        for (int i = 1; i < 201; i++) {\n            input.append(1);\n        }\n        input.append(\".0\");\n\n        JsonFactory factory = new JsonFactory();\n\n        JsonParser parser =\n                factory.createParser(new ByteArrayInputStream(input.toString().getBytes(Charset.forName(\"UTF-8\"))));\n        parser.nextToken();\n    }\n}\n```\n\nProduces:\n`Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 200\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseFloat(UTF8StreamJsonParser.java:1576)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseNumber2(UTF8StreamJsonParser.java:1509)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parsePosNumber(UTF8StreamJsonParser.java:1410)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._nextTokenNotInObject(UTF8StreamJsonParser.java:876)\n    at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:772)`\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_20": {
    "description": "Add support for writing `byte[]` via `JsonGenerator.writeEmbeddedObject()`\n(note: should be safe for patch, that is, 2.8.3)\n\nDefault implementation of 2.8-added `writeEmbeddedObject()` throws exception (unsupported operation) for all values, since JSON does not have any native object types.\nThis is different from handling of `writeObject()`, which tries to either delegate to `ObjectCodec` (if one registered), or even encode \"simple\" values.\n\nHowever: since support for binary data is already handled in some cases using `VALUE_EMBEDDED_OBJECT`, it would actually make sense to handle case of `byte[]` (and, if feasible, perhaps `ByteBuffer` for extra points), and also ensure `null` can be written.\n\nThis is likely necessary to support https://github.com/FasterXML/jackson-databind/issues/1361 and should in general make system more robust.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_21": {
    "description": "`FilteringParserDelegate` seems to miss last closing `END_OBJECT`\n(note: adding a failing test for this case)\r\n\r\nLooks like with settings like:\r\n\r\n```java\r\n        JsonParser p = new FilteringParserDelegate(p0,\r\n               new NameMatchFilter(\"value\"),\r\n                   true, // includePath\r\n                   false // multipleMatches\r\n                );\r\n```\r\n\r\nand input\r\n\r\n```json\r\n{\r\n  \"a\":123,\r\n  \"array\":[1,2],\r\n  \"ob\": {\r\n    \"value0\":2,\r\n    \"value\":3,\r\n    \"value2\":4\r\n  },\r\n  \"b\":true\r\n}\r\n```\r\n\r\noutput will be like:\r\n\r\n```json\r\n{\"ob\":{\"value\":3}\r\n```\r\n\r\n(note the missing trailing `}` for closing `END_OBJECT`)\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_22": {
    "description": "Make use of `_matchCount` in `FilteringParserDelegate`\nCurrently, it looks like that the _matchCount attribute in FilteringGeneratorDelegate is not utilised (i.e. no value is assigned to this variable). Re. the documentation this attribute offers some useful functionality. So it would be nice, if it could be implemented properly. See https://groups.google.com/d/msg/jackson-user/VzZ94G9hvrs/JGFozl6lCQAJ\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_23": {
    "description": "Make `DefaultPrettyPrinter.createInstance()` to fail for sub-classes\nPattern of \"blueprint object\" (that is, having an instance not used as-is, but that has factory method for creating actual instance) is used by Jackson in couple of places; often for things that implement `Instantiatable`. But one problem is that unless method is left abstract, sub-classing can be problematic -- if sub-class does not override method, then calls will result in an instance of wrong type being created.\r\n\r\nAnd this is what can easily happen with `DefaultPrettyPrinter`.\r\n\r\nA simple solution is for base class to make explicit that if base implementation is called, then instance can not be a sub-class (that is, it is only legal to call on `DefaultPrettyPrinter`, but no sub-class). This is not optimal (ideally check would be done compile-time), but better than getting a mysterious failure.\r\n\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_24": {
    "description": "Add new exception type `InputCoercionException` to be used for failed coercions like overflow for `int`\nCurrently problems like overflow for numeric type (when JSON number value exceeds range of requested target type like `int`) simply use `JsonParseException` to indicate the problem (both at streaming and databind level).\r\n\r\nBut it would be better if we could use more targeted exception, to let calling application potentially handle problems differently. We can also add some metadata about type of failure, such as initial token type and expected target type.\r\nIt is also true that coercion failures -- where we start from valid JSON value, but fail to convert into desired target type -- are not parse (decode) problems at all, but rather mismatch problems.\r\n\r\nSo let's add something like `InputCoercionException`, which extends `JsonProcessingException`, but not `JsonParseException`.\r\n\r\nWith 3.x we may want to tackle other problems: for example, lack of context for \"lower level\" `JsonProcessingException`s (compared to `JsonMappingException`)\r\n\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_25": {
    "description": "Fix ArrayIndexOutofBoundsException found by LGTM.com\nSeen on LGTM.com [here](https://lgtm.com/projects/g/FasterXML/jackson-core/alerts/?mode=tree)\r\n\r\nAs `codes.length == maxCode` so if `i == maxCode` an `ArrayIndexOutOfBoundsException` is thrown. This happens when `ALLOW_UNQUOTED_FIELD_NAMES` is enabled and character `256` is found as part of a field name after needing to consume more data from the reader.\r\n\r\nA gist containing code to trigger this path can be found [here](https://gist.github.com/aeyerstaylor/90128cca75e69303254a0d5a5dbe6762). I could find any tests for this class but if there is a place to add tests I can add the example as a test.\r\n\r\n_(Full disclosure: I'm part of the company behind LGTM.com)_\n",
    "desc_source": "github_issue"
  },
  "JacksonCore_26": {
    "description": "Non-blocking parser reports incorrect locations when fed with non-zero offset\nWhen feeding a non-blocking parser, the input array offset leaks into the offsets reported by `getCurrentLocation()` and `getTokenLocation()`.\r\n\r\nFor example, feeding with an offset of 7 yields tokens whose reported locations are 7 greater than they should be. Likewise the current location reported by the parser is 7 greater than the correct location.\r\n\r\nIt's not possible for a user to work around this issue by subtracting 7 from the reported locations, because the token location may have been established by an earlier feeding with a different offset.\r\n\r\nJackson version: 2.9.8\r\n\r\nUnit test:\r\n```java\r\nimport com.fasterxml.jackson.core.JsonFactory;\r\nimport com.fasterxml.jackson.core.JsonParser;\r\nimport com.fasterxml.jackson.core.JsonToken;\r\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\r\nimport org.junit.Test;\r\n\r\nimport static java.nio.charset.StandardCharsets.UTF_8;\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class FeedingOffsetTest {\r\n\r\n  @Test\r\n  public void inputOffsetShouldNotAffectLocations() throws Exception {\r\n    JsonFactory jsonFactory = new JsonFactory();\r\n    JsonParser parser = jsonFactory.createNonBlockingByteArrayParser();\r\n    ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\r\n\r\n    byte[] input = \"[[[\".getBytes(UTF_8);\r\n\r\n    feeder.feedInput(input, 2, 3);\r\n    assertEquals(JsonToken.START_ARRAY, parser.nextToken());\r\n    assertEquals(1, parser.getCurrentLocation().getByteOffset()); // ACTUAL = 3\r\n    assertEquals(1, parser.getTokenLocation().getByteOffset());   // ACTUAL = 3\r\n\r\n    feeder.feedInput(input, 0, 1);\r\n    assertEquals(JsonToken.START_ARRAY, parser.nextToken());\r\n    assertEquals(2, parser.getCurrentLocation().getByteOffset());\r\n    assertEquals(2, parser.getTokenLocation().getByteOffset());\r\n  }\r\n}\r\n```\n",
    "desc_source": "github_issue"
  }
}