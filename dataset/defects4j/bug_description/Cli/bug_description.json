{
  "Cli_1": {
    "description": "[cli] CommandLine.getOptionValue() behaves contrary to docs\nHi\n\nIf I have:\n\nfinal String debugOpt = \"debug\";\n\tOption debug = OptionBuilder\n\t    .withArgName(debugOpt)\n\t    .withDescription(\"turn on debugging\")\n\t    .withLongOpt(debugOpt)\n\t    .create('d');\n\nand then later I do:\n\nString dbg = commandLine.getOptionValue(debugOpt);\n\nthen dbg will be null. Instead, I have to use getOptionValue('d'). This seems\ncontrary to the docs (see bottom of\nhttp://jakarta.apache.org/commons/cli/usage.html), which implies that I should\nbe able to query the commandLine object using a full string, rather than just\nthe string's first character.\n\nCan I suggest that the API of OptionBuilder be made clearer so that it is\nobvious that you can have long and short option names---perhaps make the\ncreate() method take no arguments (thus forcing long and short arg names to be\nset explicitly). (Also, there seems to be some confusion between the terms\n'argument' and 'option' in the API, but perhaps that is just me).\n\nAlso, I would hop to be able to query commandLine by either a single char or an\nentire string, as suggested by the docs.\n\nThanks,\n\nChris",
    "desc_source": "jira"
  },
  "Cli_2": {
    "description": "[cli] Parameter value \"-something\" misinterpreted as a parameter\nIf a parameter value is passed that contains a hyphen as the (delimited) first \ncharacter, CLI parses this a parameter. For example using the call\njava myclass -t \"-something\"\nResults in the parser creating the invalid parameter -o (noting that it is \nskipping the 's')\n\nMy code is using the Posix parser as follows\nOptions options = buildCommandLineOptions();\nCommandLineParser parser = new PosixParser();\nCommandLine commandLine = null;\ntry {\n\t\t\t\n\tcommandLine = parser.parse(options, args);\n}\ncatch (ParseException e) {\n\t\t\t\n\tSystem.out.println(\"Invalid parameters. \" + e.getMessage() + NEW_LINE);\n\tSystem.exit(EXIT_CODE_ERROR);\n}\n\nThis has been tested against the nightly build dated 20050503.",
    "desc_source": "jira"
  },
  "Cli_3": {
    "description": "PosixParser interupts \"-target opt\" as \"-t arget opt\"\nThis was posted on the Commons-Developer list and confirmed as a bug.\n\n> Is this a bug?  Or am I using this incorrectly?\n> I have an option with short and long values.  Given code that is \n> essentially what is below, with a PosixParser I see results as \n> follows:\n> \n> A command line with just \"-t\" prints out the results of the catch \n> block\n> (OK)\n> A command line with just \"-target\" prints out the results of the catch\n> block (OK)\n> A command line with just \"-t foobar.com\" prints out \"processing selected\n> target: foobar.com\" (OK)\n> A command line with just \"-target foobar.com\" prints out \"processing\n> selected target: arget\" (ERROR?)\n> \n> ======================================================================\n> ==\n> =======================\n>   private static final String OPTION_TARGET = \"t\";\n>   private static final String OPTION_TARGET_LONG = \"target\";\n>   // ...\n>   Option generateTarget = new Option(OPTION_TARGET, \n>                                      OPTION_TARGET_LONG, \n>                                      true, \n>                                      \"Generate files for the specified\n> target machine\");\n>   // ...\n>   try {\n>         parsedLine = parser.parse(cmdLineOpts, args);\n>       } catch (ParseException pe) {\n>         System.out.println(\"Invalid command: \" + pe.getMessage() +\n> \"\\n\");\n>         HelpFormatter hf = new HelpFormatter();\n>         hf.printHelp(USAGE, cmdLineOpts);\n>         System.exit(-1);\n>       }\n> \n>   if (parsedLine.hasOption(OPTION_TARGET)) {\n>     System.out.println(\"processing selected target: \" +\n> parsedLine.getOptionValue(OPTION_TARGET));        \n>   }\n\nIt is a bug but it is due to well defined behaviour (so that makes me feel a\nlittle better about myself ;).  To support *special* \n(well I call them special anyway) like -Dsystem.property=value we need to be\nable to examine the first character of an option.  If the first character is\nitself defined as an Option then the remainder of the token is used as the\nvalue, e.g. 'D' is the token, it is an option so 'system.property=value' is the\nargument value for that option.  This is the behaviour that we are seeing for\nyour example.  \n't' is the token, it is an options so 'arget' is the argument value.  \n\nI suppose a solution to this could be to have a way to specify properties for\nparsers.  In this case 'posix.special.option == true' for turning \non *special* options. I'll have a look into this and let you know.\n\nJust to keep track of this and to get you used to how we operate, can you log a\nbug in bugzilla for this.\n\nThanks,\n-John K",
    "desc_source": "jira"
  },
  "Cli_4": {
    "description": "PosixParser interupts \"-target opt\" as \"-t arget opt\"\nThis was posted on the Commons-Developer list and confirmed as a bug.\n\n> Is this a bug?  Or am I using this incorrectly?\n> I have an option with short and long values.  Given code that is \n> essentially what is below, with a PosixParser I see results as \n> follows:\n> \n> A command line with just \"-t\" prints out the results of the catch \n> block\n> (OK)\n> A command line with just \"-target\" prints out the results of the catch\n> block (OK)\n> A command line with just \"-t foobar.com\" prints out \"processing selected\n> target: foobar.com\" (OK)\n> A command line with just \"-target foobar.com\" prints out \"processing\n> selected target: arget\" (ERROR?)\n> \n> ======================================================================\n> ==\n> =======================\n>   private static final String OPTION_TARGET = \"t\";\n>   private static final String OPTION_TARGET_LONG = \"target\";\n>   // ...\n>   Option generateTarget = new Option(OPTION_TARGET, \n>                                      OPTION_TARGET_LONG, \n>                                      true, \n>                                      \"Generate files for the specified\n> target machine\");\n>   // ...\n>   try {\n>         parsedLine = parser.parse(cmdLineOpts, args);\n>       } catch (ParseException pe) {\n>         System.out.println(\"Invalid command: \" + pe.getMessage() +\n> \"\\n\");\n>         HelpFormatter hf = new HelpFormatter();\n>         hf.printHelp(USAGE, cmdLineOpts);\n>         System.exit(-1);\n>       }\n> \n>   if (parsedLine.hasOption(OPTION_TARGET)) {\n>     System.out.println(\"processing selected target: \" +\n> parsedLine.getOptionValue(OPTION_TARGET));        \n>   }\n\nIt is a bug but it is due to well defined behaviour (so that makes me feel a\nlittle better about myself ;).  To support *special* \n(well I call them special anyway) like -Dsystem.property=value we need to be\nable to examine the first character of an option.  If the first character is\nitself defined as an Option then the remainder of the token is used as the\nvalue, e.g. 'D' is the token, it is an option so 'system.property=value' is the\nargument value for that option.  This is the behaviour that we are seeing for\nyour example.  \n't' is the token, it is an options so 'arget' is the argument value.  \n\nI suppose a solution to this could be to have a way to specify properties for\nparsers.  In this case 'posix.special.option == true' for turning \non *special* options. I'll have a look into this and let you know.\n\nJust to keep track of this and to get you used to how we operate, can you log a\nbug in bugzilla for this.\n\nThanks,\n-John K",
    "desc_source": "jira"
  },
  "Cli_5": {
    "description": "NullPointerException in Util.stripLeadingHyphens when passed a null argument\nIf you try to do a hasOption(null), you get a NPE:\n\njava.lang.NullPointerException\n\tat org.apache.commons.cli.Util.stripLeadingHyphens(Util.java:39)\n\tat org.apache.commons.cli.CommandLine.resolveOption(CommandLine.java:166)\n\tat org.apache.commons.cli.CommandLine.hasOption(CommandLine.java:68)\n\nEither hasOption should reject the null argument, or the function should simply return false.  I think the latter makes more since, as this is how Java collections generally work.",
    "desc_source": "jira"
  },
  "Cli_7": {
    "description": "Tests fail under 1.6 + error at end that may or may not be related\nTestsuite: org.apache.commons.cli2.bug.Bug27575Test\nTests run: 1, Failures: 1, Errors: 0, Time elapsed: 0.058 sec\n\nTestcase: testRequiredOptions(org.apache.commons.cli2.bug.Bug27575Test):        FAILED\nexpected:<[-h]> but was:<-c <arg>>\njunit.framework.ComparisonFailure: expected:<[-h]> but was:<-c <arg>>\n        at org.apache.commons.cli2.bug.Bug27575Test.testRequiredOptions(Bug27575Test.java:36)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\n\nand error at end of:\n\nException in thread \"Thread-1\" javax.xml.transform.TransformerFactoryConfigurationError: Provider for javax.xml.transform.TransformerFactory cannot be found\n        at javax.xml.transform.TransformerFactory.newInstance(Unknown Source)\n        at java.util.prefs.XmlSupport.writeDoc(XmlSupport.java:246)\n        at java.util.prefs.XmlSupport.exportMap(XmlSupport.java:333)\n        at java.util.prefs.FileSystemPreferences$8.run(FileSystemPreferences.java:607)",
    "desc_source": "jira"
  },
  "Cli_8": {
    "description": "HelpFormatter wraps incorrectly on every line beyond the first\nThe method findWrapPos(...) in the HelpFormatter is a couple of bugs in the way that it deals with the \"startPos\" variable.  This causes it to format every line beyond the first line by \"startPos\" to many characters, beyond the specified width.  \n\nTo see this, create an option with a long description, and then use the help formatter to print it.  The first line will be the correct length.  The 2nd, 3rd, etc lines will all be too long.\n\nI don't have a patch (sorry) - but here is a corrected version of the method.\n\nI fixed it in two places - both were using \"width + startPos\" when they should have been using width.\n\n{code}\n protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos+1;\n        }\n        else if ((width) >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length())        ? (-1) : pos;\n    }\n{code}",
    "desc_source": "jira"
  },
  "Cli_9": {
    "description": "MissingOptionException.getMessage() changed from CLI 1.0 > 1.1\nThe MissingOptionException.getMessage() string changed from CLI 1.0 > 1.1. \n\nCLI 1.0 was poorly formatted but readable:\nMissing required options: -format-source-properties\n\nCLI 1.1 is almost unreadable:\nMissing required options: formatsourceproperties\n\nIn CLI 1.0 Options.addOption(Option) prefixed the stored options with a \"-\" and in CLI 1.1 it doesn't.\n\nI would suggest changing Parser.checkRequiredOptions() to add the options to the error message with a prefix of \" -\":\n\nOLD: \n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\nNEW: \n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(\" -\" + iter.next());\n            }\n\nResulting in:\nMissing required options: -format -source -properties\n",
    "desc_source": "jira"
  },
  "Cli_10": {
    "description": "Missing required options not throwing MissingOptionException\nWhen an Options object is used to parse a second set of command arguments it won't throw a MissingOptionException.\n\n{code:java}\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.GnuParser;\nimport org.apache.commons.cli.OptionBuilder;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\n\npublic class Example\n{\n\tpublic static void main(String[] args) throws ParseException\n\t{\n\t\tbrokenExample();\n\t\tworkingExample();\n\t}\n\n\t// throws exception as expected\n\tprivate static void workingExample() throws ParseException\n\t{\n\t\tString[] args = {};\n\n\t\tOptions opts = new Options();\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\t\tGnuParser parser = new GnuParser();\n\t\tCommandLine secondCL = parser.parse(opts, args);\n\n\t\tSystem.out.println(\"Done workingExample\");\n\t}\n\n\t// fails to throw exception on second invocation of parse\n\tprivate static void brokenExample() throws ParseException\n\t{\n\t\tString[] firstArgs = { \"-v\" };\n\t\tString[] secondArgs = {};\n\n\t\tOptions opts = new Options();\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\t\tGnuParser parser = new GnuParser();\n\t\tCommandLine firstCL = parser.parse(opts, firstArgs);\n\t\tCommandLine secondCL = parser.parse(opts, secondArgs);\n\n\t\tSystem.out.println(\"Done brokenExample\");\n\t}\n}\n{code}\n\nThis is a result of the Options object returning the reference to its own list and the parsers modifying that list. The first call is removing the required options as they are found and subsequent calls get back an empty list.",
    "desc_source": "jira"
  },
  "Cli_11": {
    "description": "PosixParser interupts \"-target opt\" as \"-t arget opt\"\nThis was posted on the Commons-Developer list and confirmed as a bug.\n\n> Is this a bug?  Or am I using this incorrectly?\n> I have an option with short and long values.  Given code that is \n> essentially what is below, with a PosixParser I see results as \n> follows:\n> \n> A command line with just \"-t\" prints out the results of the catch \n> block\n> (OK)\n> A command line with just \"-target\" prints out the results of the catch\n> block (OK)\n> A command line with just \"-t foobar.com\" prints out \"processing selected\n> target: foobar.com\" (OK)\n> A command line with just \"-target foobar.com\" prints out \"processing\n> selected target: arget\" (ERROR?)\n> \n> ======================================================================\n> ==\n> =======================\n>   private static final String OPTION_TARGET = \"t\";\n>   private static final String OPTION_TARGET_LONG = \"target\";\n>   // ...\n>   Option generateTarget = new Option(OPTION_TARGET, \n>                                      OPTION_TARGET_LONG, \n>                                      true, \n>                                      \"Generate files for the specified\n> target machine\");\n>   // ...\n>   try {\n>         parsedLine = parser.parse(cmdLineOpts, args);\n>       } catch (ParseException pe) {\n>         System.out.println(\"Invalid command: \" + pe.getMessage() +\n> \"\\n\");\n>         HelpFormatter hf = new HelpFormatter();\n>         hf.printHelp(USAGE, cmdLineOpts);\n>         System.exit(-1);\n>       }\n> \n>   if (parsedLine.hasOption(OPTION_TARGET)) {\n>     System.out.println(\"processing selected target: \" +\n> parsedLine.getOptionValue(OPTION_TARGET));        \n>   }\n\nIt is a bug but it is due to well defined behaviour (so that makes me feel a\nlittle better about myself ;).  To support *special* \n(well I call them special anyway) like -Dsystem.property=value we need to be\nable to examine the first character of an option.  If the first character is\nitself defined as an Option then the remainder of the token is used as the\nvalue, e.g. 'D' is the token, it is an option so 'system.property=value' is the\nargument value for that option.  This is the behaviour that we are seeing for\nyour example.  \n't' is the token, it is an options so 'arget' is the argument value.  \n\nI suppose a solution to this could be to have a way to specify properties for\nparsers.  In this case 'posix.special.option == true' for turning \non *special* options. I'll have a look into this and let you know.\n\nJust to keep track of this and to get you used to how we operate, can you log a\nbug in bugzilla for this.\n\nThanks,\n-John K",
    "desc_source": "jira"
  },
  "Cli_12": {
    "description": "PosixParser interupts \"-target opt\" as \"-t arget opt\"\nThis was posted on the Commons-Developer list and confirmed as a bug.\n\n> Is this a bug?  Or am I using this incorrectly?\n> I have an option with short and long values.  Given code that is \n> essentially what is below, with a PosixParser I see results as \n> follows:\n> \n> A command line with just \"-t\" prints out the results of the catch \n> block\n> (OK)\n> A command line with just \"-target\" prints out the results of the catch\n> block (OK)\n> A command line with just \"-t foobar.com\" prints out \"processing selected\n> target: foobar.com\" (OK)\n> A command line with just \"-target foobar.com\" prints out \"processing\n> selected target: arget\" (ERROR?)\n> \n> ======================================================================\n> ==\n> =======================\n>   private static final String OPTION_TARGET = \"t\";\n>   private static final String OPTION_TARGET_LONG = \"target\";\n>   // ...\n>   Option generateTarget = new Option(OPTION_TARGET, \n>                                      OPTION_TARGET_LONG, \n>                                      true, \n>                                      \"Generate files for the specified\n> target machine\");\n>   // ...\n>   try {\n>         parsedLine = parser.parse(cmdLineOpts, args);\n>       } catch (ParseException pe) {\n>         System.out.println(\"Invalid command: \" + pe.getMessage() +\n> \"\\n\");\n>         HelpFormatter hf = new HelpFormatter();\n>         hf.printHelp(USAGE, cmdLineOpts);\n>         System.exit(-1);\n>       }\n> \n>   if (parsedLine.hasOption(OPTION_TARGET)) {\n>     System.out.println(\"processing selected target: \" +\n> parsedLine.getOptionValue(OPTION_TARGET));        \n>   }\n\nIt is a bug but it is due to well defined behaviour (so that makes me feel a\nlittle better about myself ;).  To support *special* \n(well I call them special anyway) like -Dsystem.property=value we need to be\nable to examine the first character of an option.  If the first character is\nitself defined as an Option then the remainder of the token is used as the\nvalue, e.g. 'D' is the token, it is an option so 'system.property=value' is the\nargument value for that option.  This is the behaviour that we are seeing for\nyour example.  \n't' is the token, it is an options so 'arget' is the argument value.  \n\nI suppose a solution to this could be to have a way to specify properties for\nparsers.  In this case 'posix.special.option == true' for turning \non *special* options. I'll have a look into this and let you know.\n\nJust to keep track of this and to get you used to how we operate, can you log a\nbug in bugzilla for this.\n\nThanks,\n-John K",
    "desc_source": "jira"
  },
  "Cli_13": {
    "description": "[cli] argument defaults prevent commandline usage.\nI have found a bug in the following scenario:\n\nYou have an option which can take a single argument which in turn has a default\nvalue. You supply a value on the command line which is intended to override\nthis default however as the CommandLine already has a value for this Option,\nthis second value is not allowed and the command line cannot be parsed.\n\nI have created a patch which adds a method to WritableCommandLine and its Impl\nwhich allows you to retrieve the undefaulted values for an Option. I have then\nchanged ArgumentImpl to use this method to determine the argument count",
    "desc_source": "jira"
  },
  "Cli_14": {
    "description": "adding a FileValidator results in ClassCastException in parser.parseAndHelp(args)\nWhen I add a FileValidator.getExistingFileInstance() to an Argument, I get a ClassCastException when I parse args.\n\nBelow is a testcase invoke with\n\n   java org.apache.commons.cli2.issues.CLI2Sample -classpath commons-cli-2.0-SNAPSHOT.jar --file-name path-to-an-existing-file\n\nRun it and you get:\n\nException in thread \"main\" java.lang.ClassCastException: java.io.File cannot be cast to java.lang.String\n\tat org.apache.commons.cli2.validation.FileValidator.validate(FileValidator.java:122)\n\tat org.apache.commons.cli2.option.ArgumentImpl.validate(ArgumentImpl.java:250)\n\tat org.apache.commons.cli2.option.ParentImpl.validate(ParentImpl.java:123)\n\tat org.apache.commons.cli2.option.DefaultOption.validate(DefaultOption.java:175)\n\tat org.apache.commons.cli2.option.GroupImpl.validate(GroupImpl.java:264)\n\tat org.apache.commons.cli2.commandline.Parser.parse(Parser.java:105)\n\tat org.apache.commons.cli2.commandline.Parser.parseAndHelp(Parser.java:125)\n\tat org.apache.commons.cli2.issues.CLI2Sample.main(CLI2Sample.java:38)\n\nComment out the withValidator call and it runs with no exception. \n\nI also get a similar ClassCastException if I add a \n\n  .withValidator(NumberValidator.getIntegerInstance())\n\nto another option/argument.\n\nHere is the source\n\n\npackage org.apache.commons.cli2.issues;\n\nimport java.io.File;\nimport org.apache.commons.cli2.CommandLine;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.builder.ArgumentBuilder;\nimport org.apache.commons.cli2.builder.DefaultOptionBuilder;\nimport org.apache.commons.cli2.builder.GroupBuilder;\nimport org.apache.commons.cli2.commandline.Parser;\nimport org.apache.commons.cli2.option.DefaultOption;\nimport org.apache.commons.cli2.validation.FileValidator;\n\npublic class CLI2Sample\n{\n   public static void main(String[] args)\n   {\n      final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n      final ArgumentBuilder abuilder = new ArgumentBuilder();\n      final GroupBuilder gbuilder = new GroupBuilder();\n      DefaultOption fileNameOption = obuilder\n            .withShortName(\"f\")\n            .withLongName(\"file-name\")\n            .withRequired(true)\n            .withDescription(\"name of an existing file\")\n            .withArgument(abuilder\n                  .withName(\"file-name\")\n                  .withValidator(FileValidator.getExistingFileInstance())\n                  .create())\n            .create();\n      Group options = gbuilder\n            .withName(\"options\")\n            .withOption(fileNameOption)\n            .create();\n      Parser parser = new Parser();\n      parser.setHelpTrigger(\"--help\");\n      parser.setGroup(options);\n      CommandLine cl = parser.parseAndHelp(args);\n     }\n}\n",
    "desc_source": "jira"
  },
  "Cli_15": {
    "description": "deafult arguments only works if no arguments are submitted\nWhen using multple arguments and defaults, the behaviour is counter-intuitive and will only pick up a default if no args are passed in.\n\nFor instance in the code below I have set up so 0, 1, or 2 args may bve accepted, with defaults 100 and 1000.\n\nI expect it to behave as follows.\n1. for 2 args, 1 and 2 the values should be 1 and 2. This works as expected.\n2. for 0 args passed in the values should be 100 and 1000, picking up both of the defaults. This works as expected\n\n\n3. for 1 arg passed in the values should be 1 and 1000, so the second argument picks up the second default value. The valuse become just 1, which is not as expected..\n\n\nCurrently, in the second case will only return 1 and ignore the defaults.\n\n\n\n    public void testSingleOptionSingleArgument() throws Exception {\n        String defaulValue1 = \"100\";\n        String defaultValue2 = \"1000\";\n        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n\n        DefaultOption bOption = obuilder.withShortName(\"b\")\n                .withLongName(\"b\")\n                .withArgument(abuilder.withName(\"b\")\n                        .withMinimum(0)\n                        .withMaximum(2)\n                        .withDefault(defaulValue1)\n                        .withDefault(defaultValue2)\n                        .create())\n                .create();\n\n        Group options = gbuilder\n                .withName(\"options\")\n                .withOption(bOption)\n                .create();\n\n        Parser parser = new Parser();\n        parser.setHelpTrigger(\"--help\");\n        parser.setGroup(options);\n        String enteredValue1 = \"1\";\n        String[] args = new String[]{\"-b\", enteredValue1};\n        CommandLine cl = parser.parse(args);\n        CommandLine cmd = cl;\n        assertNotNull(cmd);\n        List b = cmd.getValues(\"-b\");\n        assertEquals(\"[\" + enteredValue1 + \"]\", b + \"\");\n    }\n\n",
    "desc_source": "jira"
  },
  "Cli_16": {
    "description": "the minimum and maximum constraints on a group do not take other groups into account\nIf you have a Group A as a child of Group B and you set a minimum or maximum on Group B, the presence or not of Group A will not affect GroupB. This is because Groups are never added to a CommandLine so .hasOption(A) returns false and so it isn't counted. WriteableCommandLine#addOption(Option) should be used to indicate that a Group is present if any of a Groups children is present.",
    "desc_source": "jira"
  },
  "Cli_17": {
    "description": "PosixParser keeps bursting tokens even if a non option character is found\nPosixParser doesn't stop the bursting process of a token if stopAtNonOption is enabled and a non option character is encountered.\n\nFor example if the options a and b are defined, with stopAtNonOption=true the following command line:\n\n{code}-azb{code}\n\nis turned into:\n\n{code}-a zb -b{code}\n\nthe right output should be:\n\n{code}-a zb{code}\n",
    "desc_source": "jira"
  },
  "Cli_18": {
    "description": "PosixParser ignores unrecognized tokens starting with '-'\nPosixParser doesn't handle properly unrecognized tokens starting with '-' when stopAtNonOption is enabled, the token is simply ignored.\n\nFor example, if the option 'a' is defined, the following command line:\n\n{code}-z -a foo{code}\n\nis interpreted as:\n\n{code}-a foo{code}",
    "desc_source": "jira"
  },
  "Cli_19": {
    "description": "PosixParser ignores unrecognized tokens starting with '-'\nPosixParser doesn't handle properly unrecognized tokens starting with '-' when stopAtNonOption is enabled, the token is simply ignored.\n\nFor example, if the option 'a' is defined, the following command line:\n\n{code}-z -a foo{code}\n\nis interpreted as:\n\n{code}-a foo{code}",
    "desc_source": "jira"
  },
  "Cli_20": {
    "description": "PosixParser keeps processing tokens after a non unrecognized long option\nPosixParser keeps processing tokens after a non unrecognized long option when stopAtNonOption is enabled. The tokens after the unrecognized long option are burst, split around '=', etc.. instead of being kept as is.\n\nFor example, with the options 'a' and 'b' defined, 'b' having an argument, the following command line:\n\n{code}--zop -abfoo{code}\n\nis interpreted as:\n\n{code}--zop -a -b foo{code}\n\nbut the last token should remain unchanged.",
    "desc_source": "jira"
  },
  "Cli_21": {
    "description": "Negative numbers mistaken for options\nIf an option has a negative numerical argument, the parser mistakes it for another option and throws an error. For example, consider:\n\n{{Argument numArg = aBuilder.withValidator(NumberValidator.getNumberInstance()).withMinimum(1).withMaximum(1).create();}}\n{{Option numOpt = oBuilder.withLongName(\"num\").withArgument(numArg).create();}}\n{{Group options = gBuilder.withOption(numOpt).create();}}\n\nThen parsing {{--num -0.1}} results in:\n\n{{Unexpected -0.1 while processing --num}}\n\n\n\n",
    "desc_source": "jira"
  },
  "Cli_22": {
    "description": "PosixParser interupts \"-target opt\" as \"-t arget opt\"\nThis was posted on the Commons-Developer list and confirmed as a bug.\n\n> Is this a bug?  Or am I using this incorrectly?\n> I have an option with short and long values.  Given code that is \n> essentially what is below, with a PosixParser I see results as \n> follows:\n> \n> A command line with just \"-t\" prints out the results of the catch \n> block\n> (OK)\n> A command line with just \"-target\" prints out the results of the catch\n> block (OK)\n> A command line with just \"-t foobar.com\" prints out \"processing selected\n> target: foobar.com\" (OK)\n> A command line with just \"-target foobar.com\" prints out \"processing\n> selected target: arget\" (ERROR?)\n> \n> ======================================================================\n> ==\n> =======================\n>   private static final String OPTION_TARGET = \"t\";\n>   private static final String OPTION_TARGET_LONG = \"target\";\n>   // ...\n>   Option generateTarget = new Option(OPTION_TARGET, \n>                                      OPTION_TARGET_LONG, \n>                                      true, \n>                                      \"Generate files for the specified\n> target machine\");\n>   // ...\n>   try {\n>         parsedLine = parser.parse(cmdLineOpts, args);\n>       } catch (ParseException pe) {\n>         System.out.println(\"Invalid command: \" + pe.getMessage() +\n> \"\\n\");\n>         HelpFormatter hf = new HelpFormatter();\n>         hf.printHelp(USAGE, cmdLineOpts);\n>         System.exit(-1);\n>       }\n> \n>   if (parsedLine.hasOption(OPTION_TARGET)) {\n>     System.out.println(\"processing selected target: \" +\n> parsedLine.getOptionValue(OPTION_TARGET));        \n>   }\n\nIt is a bug but it is due to well defined behaviour (so that makes me feel a\nlittle better about myself ;).  To support *special* \n(well I call them special anyway) like -Dsystem.property=value we need to be\nable to examine the first character of an option.  If the first character is\nitself defined as an Option then the remainder of the token is used as the\nvalue, e.g. 'D' is the token, it is an option so 'system.property=value' is the\nargument value for that option.  This is the behaviour that we are seeing for\nyour example.  \n't' is the token, it is an options so 'arget' is the argument value.  \n\nI suppose a solution to this could be to have a way to specify properties for\nparsers.  In this case 'posix.special.option == true' for turning \non *special* options. I'll have a look into this and let you know.\n\nJust to keep track of this and to get you used to how we operate, can you log a\nbug in bugzilla for this.\n\nThanks,\n-John K",
    "desc_source": "jira"
  },
  "Cli_23": {
    "description": "infinite loop in the wrapping code of HelpFormatter\nIf there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n\nTest case:\n\n{code}\nOptions options = new Options();\noptions.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\"app\", options); // hang & crash\n{code}\n\nAn helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.",
    "desc_source": "jira"
  },
  "Cli_24": {
    "description": "infinite loop in the wrapping code of HelpFormatter\nIf there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n\nTest case:\n\n{code}\nOptions options = new Options();\noptions.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\"app\", options); // hang & crash\n{code}\n\nAn helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.",
    "desc_source": "jira"
  },
  "Cli_25": {
    "description": "infinite loop in the wrapping code of HelpFormatter\nIf there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n\nTest case:\n\n{code}\nOptions options = new Options();\noptions.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\"app\", options); // hang & crash\n{code}\n\nAn helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.",
    "desc_source": "jira"
  },
  "Cli_26": {
    "description": "OptionBuilder is not reseted in case of an IAE at create\nIf the call to OptionBuilder.create() fails with an IllegalArgumentException, the OptionBuilder is not resetted and its next usage may contain unwanted settings. Actually this let the CLI-1.2 RCs fail on IBM JDK 6 running on Maven 2.0.10.",
    "desc_source": "jira"
  },
  "Cli_27": {
    "description": "Unable to select a pure long option in a group\nOptionGroup doesn't play nice with options with a long name and no short name. If the selected option hasn't a short name, group.setSelected(option) has no effect.\n",
    "desc_source": "jira"
  },
  "Cli_28": {
    "description": "Default options may be partially processed\nThe Properties instance passed to the Parser.parse() method to initialize the default options may be partially processed. This happens when the properties contains an option that doesn't accept arguments and has a default value that isn't evaluated to \"true\". When this case occurs the processing of the properties is stopped and the remaining options are never handled.\n\nThis is caused by the break statement in Parser.processProperties(Properties), a continue statement should have been used instead.\n\nThe related test in ValueTest is also wrong, there are two assertions that need to be changed:\n\n{code}\nOptions opts = new Options();\nopts.addOption(\"a\", false, \"toggle -a\");\nopts.addOption(\"c\", \"c\", false, \"toggle -c\");\nopts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\nproperties = new Properties();\nproperties.setProperty( \"a\", \"false\" );\nproperties.setProperty( \"c\", \"no\" );\nproperties.setProperty( \"e\", \"0\" );\n\ncmd = parser.parse(opts, null, properties);\nassertTrue( !cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( !cmd.hasOption(\"e\") ); // Wrong, this option accepts an argument and should receive the value \"0\"\n{code}\n\n and the second one:\n\n{code}\nproperties = new Properties();\nproperties.setProperty( \"a\", \"just a string\" );\nproperties.setProperty( \"e\", \"\" );\n\ncmd = parser.parse(opts, null, properties);\nassertTrue( !cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( !cmd.hasOption(\"e\") ); // Wrong, this option accepts an argument and should receive an empty string as value\n{code}\n",
    "desc_source": "jira"
  },
  "Cli_29": {
    "description": "Commons CLI incorrectly stripping leading and trailing quotes\norg.apache.commons.cli.Parser.processArgs() calls Util.stripLeadingAndTrailingQuotes() for all argument values. IMHO this is incorrect and totally broken.\n\nIt is trivial to create a simple test for this. Output:\n\n    $ java -cp target/clitest.jar Clitest --balloo \"this is a \\\"test\\\"\"\n    Value of argument balloo is 'this is a \"test'.\n\nThe argument 'balloo' should indeed keep its trailing double quote. It is what the shell gives it, so don't try to do something clever to it.\n\nThe offending code was committed here:\n    http://svn.apache.org/viewvc?view=rev&revision=129874\nand has been there for more than 6 years (!). Why was this committed in the first place?\n\nThe fix is trivial, just get rid of Util.stripLeadingAndTrailingQuotes(), and consequently avoid calling it from Parser.processArgs().",
    "desc_source": "jira"
  },
  "Cli_30": {
    "description": "The state of the option groups is not updated by the default options\nThe state of the option groups is neither checked nor updated when the default options passed as a Properties instance to the parse method are processed. For example if 'a' and 'b' are two mutually exclusive options, the command line argument could specify 'a' and the default options could contain 'b', the parser will not complain and the resulting CommandLine will contain 'a' and 'b'.\n",
    "desc_source": "jira"
  },
  "Cli_31": {
    "description": "HelpFormatter.setArgName() has no effect\nThe default argument name set on the HelpFormatter has no effect because the Option and the OptionBuilder bring automatically a default value 'arg'.",
    "desc_source": "jira"
  },
  "Cli_32": {
    "description": "StringIndexOutOfBoundsException in HelpFormatter.findWrapPos\nIn the last while loop in HelpFormatter.findWrapPos, it can pass text.length() to text.charAt(int), which throws a StringIndexOutOfBoundsException. The first expression in that while loop condition should use a <, not a <=.\n\nThis is on line 908 in r779646:\n  http://svn.apache.org/viewvc/commons/proper/cli/trunk/src/java/org/apache/commons/cli/HelpFormatter.java?revision=779646&view=markup",
    "desc_source": "jira"
  },
  "Cli_33": {
    "description": "HelpFormatter strips leading whitespaces in the footer\nI discovered a bug in Commons CLI while using it through Groovy's CliBuilder. See the following issue:\n\nhttp://jira.codehaus.org/browse/GROOVY-4313?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel\n\nCopied:\nThe following code:\n\ndef cli = new CliBuilder(footer: \"line1:\\n line2:\\n\")\ncli.usage()\n\nProduces the following output:\n\nline1\nline2\n\nNote that there are no whitespaces before \"line2\". Replacing them with \"\\t\" doesn't solve the problem either.",
    "desc_source": "jira"
  },
  "Cli_34": {
    "description": "String as default Option type\ngetParsedOptionValue returns null unless Option.type gets explicitly set. The user expects it to be String unless set to any other type.\nThis coult be either fixed in the Option constructor or in CommandLine.getParsedOptionValue. Mentioning this behaviour in Javadoc would be advisable.\n\n",
    "desc_source": "jira"
  },
  "Cli_35": {
    "description": "LongOpt falsely detected as ambiguous\nOptions options = new Options();\noptions.addOption(Option.builder().longOpt(\"importToOpen\").hasArg().argName(\"FILE\").build());\noptions.addOption(Option.builder(\"i\").longOpt(\"import\").hasArg().argName(\"FILE\").build());\n\nParsing \"--import=FILE\" is not possible since 1.3 as it throws a AmbiguousOptionException stating that it cannot decide whether import is import or importToOpen. In 1.2 this is not an issue. \n\nThe root lies in the new DefaultParser which does a startsWith check internally. \n",
    "desc_source": "jira"
  },
  "Cli_36": {
    "description": "HelpFormatter#setOptionComparator(null) doesn't display the values in inserted order\n{code:java}\nOptionGroup group = new OptionGroup();\nOption h = Option.builder(\"h\").build();\nOption s = Option.builder(\"s\").build();\nOption b = Option.builder(\"b\").build();\nOption t = Option.builder(\"t\").build();\ngroup.addOption(h)\n    .addOption(s)\n    .addOption(b)\n    .addOption(t);\nOptions options = new Options();\noptions.addOptionGroup(group);\noptions.addOption(Option.builder(\"o\").build());\nHelpFormatter formatter = new HelpFormatter();\nformatter.setOptionComparator(null);\nformatter.printHelp(\"cmd\", \"\", options, null);\n{code}\n\nThis code does print the options(1. Group, 2. Option \"o\") in the order of insertion but the groups order of display is messed up.\n\nThe OptionGroup internally uses a HashMap. If that could be replaced with a *LinkedHashMap* this issue can be solved.",
    "desc_source": "jira"
  },
  "Cli_37": {
    "description": "Optional argument picking up next regular option as its argument\nNone",
    "desc_source": "jira"
  },
  "Cli_38": {
    "description": "Optional argument picking up next regular option as its argument\nNone",
    "desc_source": "jira"
  },
  "Cli_39": {
    "description": "Option parser type EXISTING_FILE_VALUE not check file existing\nWhen the user pass option type FileInputStream.class, I think the expected behavior for the return value is the same type, which the user passed.\n\nOptions options = new Options();\noptions.addOption(Option.builder(\"f\").hasArg().type(FileInputStream.class).build());\nCommandLine cline = new DefaultParser().parse(options, args);\nFileInputStream file = (FileInputStream) cline.getParsedOptionValue(\"f\"); // it returns \"File\" object, without check File exist.\n\n\nI attach a solution for it:\nhttps://github.com/schaumb/commons-cli/commit/abfcc8211f529ab75f3b3edd4a827e484109eb0b\n\n",
    "desc_source": "jira"
  },
  "Cli_40": {
    "description": "TypeHandler should throw ParseException for an unsupported class\nJavaDoc for TypeHandler states that createValue will\r\n{noformat}\r\n* @throws ParseException if the value creation for the given object type failedtype{noformat}\r\n\u00a0However createValue(String str, Class<?> clazz) will return null if the clazz is unknown.",
    "desc_source": "jira"
  }
}