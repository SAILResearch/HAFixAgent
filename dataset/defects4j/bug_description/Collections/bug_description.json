{
  "Collections_1": {
    "description": "Flat3Map.Entry.setValue() overwrites other Entry values\nFlat3Map's Entry objects will overwrite other Entry's values if Entry.setValue() is called on one.  It should only overwrite the Entry at hand.\n\nI've looked at the source, and the case statement incorrectly falls through, rather than returning like it should:\n\nFlat3Map.java, lines 646-660:\n\n        public Object setValue(Object value) {\n            if (canRemove == false) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            Object old = getValue();\n            switch (nextIndex) {\n                case 3: \n                    parent.value3 = value;\n                case 2:\n                    parent.value2 = value;\n                case 1:\n                    parent.value1 = value;\n            }\n            return old;\n        }\n\nWith this code, if I set the value of the third item in the EntrySet, then all three values are set to the new value.\n",
    "desc_source": "jira"
  },
  "Collections_2": {
    "description": "ExtendedProperties - field include should be non-static and private\nThe field \"include\" in ExtendedProperties is currently static and protected, yet has instance get/set accessors.\n\nGiven that there are accessors, it seems unnecessary for the field to be protected - it could be private.\n\nThe field should also surely be non-static - or the accessors should be made static, if the field really is supposed to be shared among instances.",
    "desc_source": "jira"
  },
  "Collections_3": {
    "description": "The CollectionUtils.removeAll method calls the ListUtils.retainAll method instead of the ListUtils.removeAll method.\nThe CollectionUtils.removeAll method calls the ListUtils.retainAll method instead of the ListUtils.removeAll method.",
    "desc_source": "jira"
  },
  "Collections_4": {
    "description": "MultiValueMap put and putAll do not return the correct values\nMultiValueMap put and putAll do not return the correct values.\n\nputAll(Object, Collection) should return true if the map is changed. But if the key is new then this behaviour fails.\n\nput(Object, Object) should return the added value if the map is changed. But if the key is new then this behaviour fails.\n\nThis was hidden because the test case referred to MultiHashMap and not MultValueMap.",
    "desc_source": "jira"
  },
  "Collections_5": {
    "description": "SetUniqueList.addAll(int index, Collection coll) adds to end of list instead of at specified index\nWhen you call SetUniqueList.addAll(int index, Collection coll), it incorrectly adds the new elements to the end of the list instead of at the specified index.",
    "desc_source": "jira"
  },
  "Collections_6": {
    "description": "Flat3Map.remove() does not return the correct value when size <= 3\n        final Flat3Map m = new Flat3Map();\n        m.put( new Integer( 1 ), new Integer( 1 ) );\n        m.put( new Integer( 0 ), new Integer( 0 ) );\n        System.out.println( m.remove( new Integer( 1 ) ) );\n\nThe above code will print \"0\" when it should print \"1\"",
    "desc_source": "jira"
  },
  "Collections_7": {
    "description": "put() and putAll() don't update the getKeys() map\nIf you use the put() or putAll() methods of the ExtendedProperties class, it will  not update the contents of the internal keysAsListed map which in turn will return a different list of keys using the getKeys() method than the keySet() method does.\n\nThe attached patchs fix this behaviour and add test cases. ",
    "desc_source": "jira"
  },
  "Collections_8": {
    "description": "Serialization/Deserialization doesn't work well with empty buffers.\nWhen I serialize the queue to disk an it has elements, all works ok, but when I serialize an empty queue I have some problems when I create a new object using the serialized file.\n\nWhen I deserialize the queue it has a 'buffer' with size 1 (with null content), 'tail' and 'head' fields are 0 (they are declared transient). So, when I try to add a new object to the queue, the sentence:\n\n Object[] tmp = new Object[((buffer.length - 1) * 2) + 1];\n\nIs executed in the add() method to increase the buffer length, but the buffer remains with the same size! (buffer.length = 1 --> (1 - 1) * 2 + 1 = 1). So, the object is added and when the tail is going to be incremented, it is reset to 0!! \n\n    private int increment(int index) {\n        index++;\n        if (index >= buffer.length) {\n            index = 0;\n        }\n        return index;\n    }\n\n\nSo it is impossible to add new elements after an empty queue has been serialized / deserialized.\n\nI attach a simple TestCase where this is proved. The example works when you use XMLEncoder to serialize the buffer but doesn't work if you use ObjectOutputStream or XStream.",
    "desc_source": "jira"
  },
  "Collections_9": {
    "description": "org.apache.commons.collections.ExtendedProperties#combine don't import string properly\nWhen we set property with escaped characters, after combine propertySets we got them unescaped.\n\nSimple Example\n\nExtendedProperties props = new ExtendedProperties();\nprops.setProperty(\"test\", \"\\\\\\\\\\\\\\\\192.168.1.91\\\\\\\\test\");\nprops.getProperty(\"test\"); // => \\\\192.168.1.91\\test\n\nExtendedProperties props2 = new ExtendedProperties();\nprops2.combine(props);\nprops.getProperty(\"test\"); // => \\192.168.1.91\\test -- Wrong!",
    "desc_source": "jira"
  },
  "Collections_10": {
    "description": "MultiValueMap should implement Serializable\nCollection classes should be serializable as they are frequently used in model classes which need to be serializable, for example in a HttpSession object within a servlet container cluster.",
    "desc_source": "jira"
  },
  "Collections_11": {
    "description": "Issue with MultiKey when serialized/deserialized via RMI\nThis is because the hash code of MultiKey is calculated only once. \n\nSo if the MultiKey is deserialized in an other jvm, and if one at least of the subkeys defines its hash code with System.identityHashCode() (for example all the enums does), then the hash code of the MultiKey is no longer valid, and you can't retreive the key in your Map.\n\nI fixed it by making the cached hash code field transient, and by recalculating the hash code during deserialization. ",
    "desc_source": "jira"
  },
  "Collections_12": {
    "description": "org.apache.commons.collections.ExtendedProperties#combine don't import string properly\nWhen we set property with escaped characters, after combine propertySets we got them unescaped.\n\nSimple Example\n\nExtendedProperties props = new ExtendedProperties();\nprops.setProperty(\"test\", \"\\\\\\\\\\\\\\\\192.168.1.91\\\\\\\\test\");\nprops.getProperty(\"test\"); // => \\\\192.168.1.91\\test\n\nExtendedProperties props2 = new ExtendedProperties();\nprops2.combine(props);\nprops.getProperty(\"test\"); // => \\192.168.1.91\\test -- Wrong!",
    "desc_source": "jira"
  },
  "Collections_13": {
    "description": "ExtendedProperties.convertProperties loses non-String values\nA Properties object normally has Strings as its values. But it does partially support non-String-typed values via the raw put and get methods inherited from Hashtable. And other Properties methods are aware that the value might not be a String; see documentation for methods propertyNames() and stringPropertyNames() for example.\n\nExtendedProperties.convertProperties does this:\n{code}\nfor (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n      String s = (String) e.nextElement();\n      c.setProperty(s, props.getProperty(s));\n}\n{code}\n\nProperties.propertyNames() returns the names of all keys in the set, regardless of the associated value's type. But Properties.getProperty(key) returns null if the value type is not a String. The call to c.setProperty invokes setPropertyInternal, which can pass this null value to Hashtable.put, which then throws a NullPointerException.\n\nIt's rather puzzling to have a valid (string-key, non-string-value) entry in the Properties object and get a NullPointerException.\n\nPerhaps the call\n  props.getProperty(s)\ncan be changed to\n  props.get(s)\n\nAlternately, at least documenting that this method does not support non-string values in the input Properties object would be useful.\n",
    "desc_source": "jira"
  },
  "Collections_14": {
    "description": "Fix case-insensitive string handling\nFor example, the behavior of the {{CaseInsensitiveMap}} is currently platform-dependent, please see [Common Bug #3|http://www.nabble.com/Re%3A-Common-Bugs-p14931921s177.html] for details.",
    "desc_source": "jira"
  },
  "Collections_15": {
    "description": "SetUniqueList set method use corrupts uniqness\nWhen set method is used to put element (Strawberry) on list, then it is possible to add the same element (Strawberry) with add method. Also you cannot add element (Lemon) that has been once removed with set method. Reproduction code below:\n\n\nList<String> list = new LinkedList<String>();\nSetUniqueList decoratedList = SetUniqueList.decorate(list);\n\ndecoratedList.add(\"Apple\");\ndecoratedList.add(\"Lemon\");\ndecoratedList.add(\"Orange\");\n\nSystem.out.println(decoratedList.toString());\n\ndecoratedList.set(1, \"Strawberry\");\n\nSystem.out.println(decoratedList.toString());\n\ndecoratedList.add(1, \"Strawberry\");\n\nSystem.out.println(decoratedList.toString());\n\ndecoratedList.add(1, \"Lemon\");\n\nSystem.out.println(decoratedList.toString());\n",
    "desc_source": "jira"
  },
  "Collections_16": {
    "description": "SetUniqueList.subList().contains() method checks against full parent list, not sublist range\nThe view returned by the subList() method of a SetUniqueList checks contains() against the set of the original list.\n\nAs shown by the following test snippet.\n\n\t\tList list = new ArrayList();\n\t\tList uniqueList = SetUniqueList.decorate(list);\n\t\tuniqueList.add(\"Hello\");\n\t\tuniqueList.add(\"World\");\n\t\tList subList = list.subList(0, 0);\n\t\tList subUniqueList = uniqueList.subList(0, 0);\n\t\tassertFalse(subList.contains(\"World\")); // passes\n\t\tassertFalse(subUniqueList.contains(\"World\")); // fails\n",
    "desc_source": "jira"
  },
  "Collections_17": {
    "description": "In LinkIterator hasPrevious() is not working properly for the first entry\nIn hasPrevious() method of LinkIterator 'next' field is used, that is not correct  - method returns 'true' for the first entry. 'last' field should be used insted.",
    "desc_source": "jira"
  },
  "Collections_18": {
    "description": "performance problem in ListOrderedSet.retainAll()\nHi,\n\nI am encountering a performance problem in ListOrderedSet.retainAll().\nIt appears in version 3.2.1 and also in revision 1365132.  I attached\na test that exposes this problem and a patch that fixes it.  On my\nmachine, for this test, the patch provides a 263X speedup.\n\nTo run the test, just do:\n\n$ java Test\n\nThe output for the un-patched version is:\nTime is 3682\n\nThe output for the patched version is:\nTime is 14\n\nThe problem is that the code for method\n\"ListOrderedSet.retainAll(Collection<?> coll)\" is:\n\n{code:java|borderStyle=solid}\npublic boolean retainAll(Collection<?> coll) {\n    boolean result = collection.retainAll(coll);\n....\n}\n{code}\n\nbecause \"collection.retainAll(coll)\" has quadratic complexity if\nparameter \"coll\" is a List.  Conceptually, the solution is to call\n\"coll.retainAll(collection)\" which has linear complexity (not\nquadratic), because \"collection\" is always a HashSet (we know this,\nbecause \"collection\" is an inherited field of ListOrderedSet, and thus\ncannot have another type).  See the\n\"java.util.AbstractCollection.retainAll()\" code inlined below for why\none call has quadratic complexity, and the other has linear\ncomplexity.\n\nDirectly calling \"coll.retainAll(collection)\" would change the\nbehavior of ListOrderedSet.retainAll(), which is why the patch seems a\nbit involved.  In reality, the patch simulates the behavior of\n\"coll.retainAll(collection)\" (which is just the intersection of two\ncollections).  You can easily see this by looking at the patch and at\nthe \"java.util.AbstractCollection.retainAll()\" code inlined below.\n\n\"collection.retainAll(coll)\" is \"java.util.HashSet.retainAll()\", which\nis \"java.util.AbstractCollection.retainAll()\", which has the code:\n\n{code:java|borderStyle=solid}\npublic boolean retainAll(Collection<?> c) {\n    boolean modified = false;\n    Iterator<E> e = iterator();\n    while (e.hasNext()) {\n        if (!c.contains(e.next())) {\n            e.remove();\n            modified = true;\n        }\n    }\n    return modified;\n}\n{code} \n\n\nIs this a bug, or am I misunderstanding the intended behavior?  If so,\ncan you please confirm if the patch is correct?\n\nThanks,\n\nAdrian\n",
    "desc_source": "jira"
  },
  "Collections_19": {
    "description": "SetUniqueList may become inconsistent\nI found this bug during my work on issue COLLECTIONS-310 : \n\nWhen you 'set' an element to a position that contains this element, it is removed from the internal set. This leads to the situation that \n- invocing get() returns the element\n- invocing contains() returns false.\n\nExtending the existing test method for set:\n{code}\n   public void testSet() {\n        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n\n        // Duplicate element\n        final E obj1 = (E) new Integer(1);\n        final E obj2 = (E) new Integer(2);\n        final E obj3 = (E) new Integer(3);\n\n        lset.add(obj1);\n        lset.add(obj2);\n        lset.set(0, obj1);\n        assertEquals(2, lset.size());\n        assertSame(obj1, lset.get(0));\n        assertSame(obj2, lset.get(1));\n\n        assertTrue(lset.contains(obj1));  // fails !\n        assertTrue(lset.contains(obj2));\n\n{code}\n\n\n",
    "desc_source": "jira"
  },
  "Collections_20": {
    "description": "TreeListIterator can return incorrect results after remove() is called\n{{TreeList.TreeListIterator}} can get in a bad state when {{remove()}} is called, causing it to subsequently return incorrect results. This is because {{TreeListIterator}} caches an {{AVLNode}} reference in its field {{next}}, and this node reference may become stale when {{remove()}} is called (it may contain a reference to a node that no longer exists in the tree).\n\nI will attach two patches: {{testcase.patch}} will contain a test case illustrating the bug, and {{fix.patch}} will contain a fix. (To fix the bug, I simply clear the cached {{next}} value in {{TreeListIterator.remove}}.)\n\nThis was originally reported in a comment to COLLECTIONS-433; I am creating a separate issue for this at Thomas Neidhart's suggestion.",
    "desc_source": "jira"
  },
  "Collections_21": {
    "description": "Modifications of a SetUniqueList.subList() invalidate the parent list\nThe List returned by SetUniqueList.subList() is again a SetUniqueList. The contract for List.subList() says that the returned list supports all the operations of the parent list, and it is backed by the parent list.\n\nWe have a SetUniqueList uniqueList equal to {\"Hello\", \"World\"}. We get a subList containing the last element. Now we add the element \"Hello\", contained in the uniqueList but not in the subList, to the subList.\n\nWhat should happen?\n\nShould the subList behave like a SetUniqueList and add the element - meaning that it changes position in the uniqueList because at the old place it gets removed, so now uniqueList equals {\"World\", \"Hello\"} (which fails)?\nOr should the element not be added, because it is already contained in the parent list, thereby violating the SetUniqueList-ness of the subList (which fails)?\nI prefer the former behaviour, because modifications should only be made through the subList and not through the parent list (as explained in List.subList()).\n\nWhat should happen if we replace (using set) the subList element \"World\" with \"Hello\" instead of adding an element?\n\nThe subList should contain only \"Hello\", and for the parent list, the old element 0 (now a duplicate of the just set element 1) should be removed (which fails).\n\nAnd of course the parent list should know what happens to it (specifically, its uniqueness Set) (which fails in the current snapshot).\n\n\n\tpublic void testSubListAddNew() {\n\t\tList uniqueList = SetUniqueList.decorate(new ArrayList());\n\t\tuniqueList.add(\"Hello\");\n\t\tuniqueList.add(\"World\");\n\t\tList subList = uniqueList.subList(1, 2);\n\n\t\tsubList.add(\"Goodbye\");\n\n\t\tList expectedSubList = Arrays.asList(new Object[] { \"World\", \"Goodbye\" });\n\t\tList expectedParentList = Arrays.asList(new Object[] { \"Hello\", \"World\", \"Goodbye\" });\n\t\tassertEquals(expectedSubList, subList);\n\t\tassertEquals(expectedParentList, uniqueList);\n\t\tassertTrue(uniqueList.contains(\"Goodbye\")); // fails\n\t}\n\n\tpublic void testSubListAddDuplicate() {\n\t\tList uniqueList = SetUniqueList.decorate(new ArrayList());\n\t\tuniqueList.add(\"Hello\");\n\t\tuniqueList.add(\"World\");\n\t\tList subList = uniqueList.subList(1, 2);\n\n\t\tsubList.add(\"Hello\");\n\n\t\tList expectedSubList = Arrays.asList(new Object[] { \"World\", \"Hello\" });\n\t\tList expectedParentList = Arrays.asList(new Object[] { \"World\", \"Hello\" });\n\t\tassertEquals(expectedSubList, subList);\n\t\tassertEquals(expectedParentList, uniqueList); // fails\n\t}\n\n\tpublic void testSubListSetDuplicate() {\n\t\tList uniqueList = SetUniqueList.decorate(new ArrayList());\n\t\tuniqueList.add(\"Hello\");\n\t\tuniqueList.add(\"World\");\n\t\tList subList = uniqueList.subList(1, 2);\n\n\t\tsubList.set(0, \"Hello\");\n\n\t\tList expectedSubList = Arrays.asList(new Object[] { \"Hello\" });\n\t\tList expectedParentList = Arrays.asList(new Object[] { \"Hello\" });\n\t\tassertEquals(expectedSubList, subList);\n\t\tassertEquals(expectedParentList, uniqueList); // fails\n\t}\n",
    "desc_source": "jira"
  },
  "Collections_22": {
    "description": "Exception in ListOrderedMap#putAll if map contains null values\nDear apache developers, thanks for the great project. Recently, I encountered an IndexOutOfBoundsException in ListOrderedMap in the latest revision (r1495998) with the crash stack trace: \nException in thread \"main\" java.lang.IndexOutOfBoundsException: Index: 2, Size: 1\n\tat java.util.ArrayList.add(ArrayList.java:367)\n\tat org.apache.commons.collections4.map.ListOrderedMap.put(ListOrderedMap.java:448)\n\tat org.apache.commons.collections4.map.ListOrderedMap.putAll(ListOrderedMap.java:246)\n\tat Test.main(Test.java:15)\n\nI've also attached a test case that can reproduce this crash.\n\nI think this test case actually reveals the bug reported in COLLECTIONS-411 (https://issues.apache.org/jira/browse/COLLECTIONS-411). However, it seems that the original patch for COLLECTIONS-411 missed a corner case.\n\nCould you please check if this is indeed a bug? Thanks!",
    "desc_source": "jira"
  },
  "Collections_23": {
    "description": "UnmodifiableTrie should not decorate an already unmodifiable Trie\nAn already unmodifiable trie was decorated again.\nTo be consistent with the other Unmodifiable wrappers, in this case the object itself shall be returned.\n\nAlso the return type shall be changed to Trie.",
    "desc_source": "jira"
  },
  "Collections_24": {
    "description": "UnmodifiableBoundedCollection does not implement Unmodifiable marker interface\nThe UnmodifiableBoundedCollection does not implement the Unmodifiable interface.",
    "desc_source": "jira"
  },
  "Collections_25": {
    "description": "IteratorUtils.collatedIterator do not use natural ordering if no comparator was provided\nIn case a null comparator was provided natural ordering should be used, as stated in the javadoc.\n\nIn fact an exception is thrown the first time the returned iterator is used.",
    "desc_source": "jira"
  },
  "Collections_26": {
    "description": "MultiKey subclassing has deserialization problem since COLLECTIONS-266: either declare protected readResolve() or MultiKey must be final\nMultiKey from collections 4 provides a transient hashCode and a *private* readResolve to resolve COLLECTIONS-266: Issue with MultiKey when serialized/deserialized via RMI.\n\nUnfortunately the solution does not work in case of *subclassing*: readResolve in MultiKey should be declared *protected* readResolve() to be called during deserialization of the subclass. Otherwise MultiKey must be final to avoid such subclassing.\n\n*Testcase*:\n{code:java|title=MultiKeySerializationTest.java}\npackage de.ivu.test.common.collections4;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.apache.commons.collections4.keyvalue.MultiKey;\nimport org.junit.Test;\n\npublic class MultiKeySerializationTest {\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReadResolveEqualHashCode()\n            throws IOException, ClassNotFoundException {\n        class MultiKey2<A, B>\n                extends MultiKey {\n\n            private static final long serialVersionUID = 1928896152249821416L;\n\n            public MultiKey2(A key1, B key2) {\n                super(key1, key2);\n            }\n\n            public A getFirst() {\n                return (A) getKey(0);\n            }\n\n            public B getSecond() {\n                return (B) getKey(1);\n            }\n            \n            // FIXME: MultiKey should either declare protected readResolve() or must be final.\n        }\n        MultiKey2<String, String> one = new MultiKey2<>(\"bla\", \"blub\");\n        System.out.println(one.hashCode());\n        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n        ObjectOutputStream out = new ObjectOutputStream(byteOut);\n        out.writeObject(one);\n        out.close();\n        byte[] serialized = byteOut.toByteArray();\n        ByteArrayInputStream byteIn = new ByteArrayInputStream(serialized);\n        ObjectInputStream in = new ObjectInputStream(byteIn);\n        MultiKey2<String, String> two = (MultiKey2<String, String>) in.readObject();\n        System.out.println(two.hashCode());\n        assertEquals(\"hashCode must be equal - please check for protected readResolve in MultiKey*\", one.hashCode(),\n            two.hashCode());\n    }\n}\n{code}\n\n*Fix:*\n{code:java|title=MultiKey.java}\n@@ -274,7 +274,7 @@\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+    protected Object readResolve() {\n         calculateHashCode(keys);\n         return this;\n     }\n{code}",
    "desc_source": "jira"
  },
  "Collections_27": {
    "description": "Arbitrary remote code execution with InvokerTransformer\nWith {{InvokerTransformer}} serializable collections can be build that execute arbitrary Java code. {{sun.reflect.annotation.AnnotationInvocationHandler#readObject}} invokes {{#entrySet}} and {{#get}} on a deserialized collection. If you have an endpoint that accepts serialized Java objects (JMX, RMI, remote EJB, ...) you can combine the two to create arbitrary remote code execution vulnerability.\n\nI don't know of a good fix short of removing {{InvokerTransformer}} or making it not Serializable. Both probably break existing applications.\n\nThis is not my research, but has been discovered by other people.\n\nhttps://github.com/frohoff/ysoserial\n\nhttp://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/\n",
    "desc_source": "jira"
  },
  "Collections_28": {
    "description": "PatriciaTrie prefixMap clear throws NullPointerException\nClearing all entries of a prefixMap returned by PatriciaTrie using the {{clear}} method throws a NullPointerException. The workaround of removing each entry using the {{remove}} method seems to work.\n\nHere are the test cases for the bug and the workaround:\n\n{code:java}\npublic class PatriciaTrieTest {\n\n    private Trie<String, Integer> trie;\n\n    @Before\n    public void setUp() {\n        trie = new PatriciaTrie<Integer>();\n        trie.put(\"Anna\", 1);\n        trie.put(\"Anael\", 2);\n        trie.put(\"Analu\", 3);\n        trie.put(\"Andreas\", 4);\n        trie.put(\"Andrea\", 5);\n        trie.put(\"Andres\", 6);\n        trie.put(\"Anatole\", 7);\n    }\n\n    @Test\n    public void testPrefixMapClear() {\n        SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n        assertEquals(new HashSet<>(Arrays.asList(\"Andrea\", \"Andreas\", \"Andres\")), prefixMap.keySet());\n        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));\n\n        prefixMap.clear();\n        assertTrue(prefixMap.keySet().isEmpty());\n        assertTrue(prefixMap.values().isEmpty());\n        assertEquals(new HashSet<>(Arrays.asList(\"Anael\", \"Analu\", \"Anatole\", \"Anna\")), trie.keySet());\n        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));\n    }\n\n    @Test\n    public void testPrefixMapClearUsingRemove() {\n        SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n        assertEquals(new HashSet<>(Arrays.asList(\"Andrea\", \"Andreas\", \"Andres\")), prefixMap.keySet());\n        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));\n\n        Set<String> keys = new HashSet<String>(prefixMap.keySet());\n        for (final String key : keys) {\n            prefixMap.remove(key);\n        }\n        assertTrue(prefixMap.keySet().isEmpty());\n        assertTrue(prefixMap.values().isEmpty());\n        assertEquals(new HashSet<>(Arrays.asList(\"Anael\", \"Analu\", \"Anatole\", \"Anna\")), trie.keySet());\n        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));\n    }\n\n}\n{code}\n\nThe stacktrace of the NullPointerException thrown by the {{testPrefixMapClear}} test case is:\n{noformat}\njava.lang.NullPointerException\n\tat org.apache.commons.collections4.trie.AbstractPatriciaTrie$PrefixRangeEntrySet$EntryIterator.remove(AbstractPatriciaTrie.java:2370)\n\tat java.util.AbstractCollection.clear(AbstractCollection.java:432)\n\tat java.util.AbstractMap.clear(AbstractMap.java:288)\n\tat PatriciaTrieTest.testPrefixMapClear(PatriciaTrieTest.java:39)\n{noformat}",
    "desc_source": "jira"
  }
}