{
  "JxPath_1": {
    "description": "Descendant or self axis does not work correctly at root node\nGiven the following XML document: <root id=\"1234\"/>\nand the XPath: //root/@id/text().\n\nJXPath returns null instead of \"1234\".\n\nJXPathContext context = JXPathContext.newContext(doc);\nassertEquals(value, context.selectSingleNode(\"//root/@id/text()\"));\n\nThe attached JUnit test highlights the problem. It seems that JXPath does not\nfind the root node if it is accessed with the axis descendant-or-self.",
    "desc_source": "jira"
  },
  "JxPath_2": {
    "description": "does not properly handle NodeSet returned by extension function\nPer the documentation, my function is returning a BasicNodeSet containing zero\nor more pointers:\n\n  public static NodeSet observations(ExpressionContext context) {\n    // the cast below shouldn't break, as this is the only pointer type that\n    // makes sense in this context\n    List<NodePointer> ptrs = extractObservations(\n                                  (NodePointer)context.getContextNodePointer(), \n                                  new ArrayList<NodePointer>());\n    BasicNodeSet result = new BasicNodeSet();\n    for (NodePointer ptr : ptrs) {\n      result.add(ptr);\n    }\n    return result;\n  }\n\nHowever, if I call JXPathContext.selectNodes(\"ems:observations()\"), I'm getting\na single node containing the BasicNodeSet. I notice that there is a testcase for\nfunctions that return NodeSets, but that it uses expressions that actually\nreturn the children of the NodeSet (\"test:nodeSet()/name\").\n\nThere appear to be two problems. First, Expression.iterate() and\nExpression.iteratePointers() do not correctly recognize a NodeSet as something\niterable. I've resolved this by reaching into the NodeSet and getting an\niterator over its pointers.\n\nSecond, Expression.PointerIterator doesn't recognize when it already has a\npointer, and instead tries to wrap it in a new pointer. This ends up treating\nthe pointer as a bean.\n\nI've made these changes, and written a testcase that uses an unadorned NodeSet\nfunction. I also found a class that used a variable named \"enum\", and changed\nthis so that it would compile under 1.5.\n\nThe patch is attached. It's relative to \"commons-jxpath-1.2\" (root of extract\ndirectory).",
    "desc_source": "jira"
  },
  "JxPath_3": {
    "description": "StackOverflow error on a call to 'JXPathContext.createPath()'\nI'm running into a StackOverflow error on a call to\n'JXPathContext.createPath()' whenever I have a path that looks like\n'a/b[1]/c'.  I took a quick look at the code and it appears JXPath, when\ntrying to create its parent pointer, simply recreates an equivalent\npointer(???).\n\nHere is code to reproduce the problem.\n\n\n    Map map = new HashMap();\n    map.put(\"a\", null);\n    \n    JXPathContext pathContext = JXPathContext.newContext(map);\n    pathContext.setFactory(new AbstractFactory() {\n      public boolean createObject(\n          JXPathContext context, Pointer pointer, Object parent, String\nname, int index) {\n\n        Map parentMap = (Map)parent;\n        System.out.println(parent + \":\" + name + \":\" + index);\n        if (index > -1) {\n          List list = (List)parentMap.get(name);\n          if (list == null) {\n            list = new ArrayList();\n          }\n          int size = list.size();\n          for (int i = size; i <= index; i++) {\n            list.add(i, null);\n          }\n          parentMap.put(name, list);\n        } else {\n          parentMap.put(name, new HashMap());\n        }\n        return true;\n      }\n      \n    });\n    pathContext.createPath(\"a/b[1]/c\");\n\n***************\n\nI have continued looking into this, and found that the problem is that, if\nthe List is created with a 'null' element, JXPath gets stuck in infinite\nrecursion.\n\nTo discover this, I changed my Factory to implement the following method:\n\n      public boolean createObject(\n          JXPathContext context, Pointer pointer, Object parent, \n          String name, int index) {\n\n        if (pointer instanceof NodePointer) {\n          index = ((NodePointer)pointer).getIndex();\n        }\n        System.out.println(parent + \":\" + name + \":\" + index);\n        Map parentMap = (Map)parent;\n        if (index > -1) {\n          List list = (List)parentMap.get(name);\n          if (list == null) {\n            list = new ArrayList();\n          }\n          int size = list.size();\n          for (int i = size; i <= index; i++) {\n            list.add(i, new HashMap());  // !!!!!!  Don't set to 'null'\n          }\n          parentMap.put(name, list);\n        } else {\n          parentMap.put(name, new HashMap());\n        }\n        return true;\n      }\n\nThen I ran the following code:\n\n    pathContext.createPath(\"a/b[1]/c\");\n    pathContext.createPath(\"a/b[2]/c\");  // STACK OVERFLOW HERE\n\nHere is the stack trace at the beginning, where\n'ValueUtils.expandCollection()' is called.  It puts 'null' into the list,\nthus causing the stack overflow as we cycle between createPath() &\ncreateChild().\n\nThread [main] (Suspended (breakpoint at line 227 in DynamicPropertyPointer))\n\tDynamicPropertyPointer.createPath(JXPathContext) line: 227\n\tDynamicPropertyPointer(PropertyPointer).createChild(JXPathContext,\nQName, int) line: 188\n\tNullElementPointer.createPath(JXPathContext) line: 82\n\tNullPointer.createPath(JXPathContext) line: 86\n\tNullPropertyPointer.createPath(JXPathContext) line: 103\n\tNullPointer.createPath(JXPathContext) line: 86\n\tNullPropertyPointer.createPath(JXPathContext) line: 103\n\tJXPathContextReferenceImpl.createPath(String, Expression) line: 447\n\tJXPathContextReferenceImpl.createPath(String) line: 427\n\tTest.test4() line: 75\n\tTest.main(String[]) line: 38",
    "desc_source": "jira"
  },
  "JxPath_4": {
    "description": "JXpath automatically trims string values\nWhen an xml contains a value with leading or trailing spaces, JXPath trims this value.\nexample: <value>     12324 56</value> is retrieved by JXPath as : '1234 56' while I expect '     1234 56'.\n",
    "desc_source": "jira"
  },
  "JxPath_5": {
    "description": "Cannot compare pointers that do not belong to the same tree\nFor XPath \"$var | /MAIN/A\" exception is thrown:\n\norg.apache.commons.jxpath.JXPathException: Cannot compare pointers that do not belong to the same tree: '$var' and ''\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:665)\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:649)\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:649)\n\tat org.apache.commons.jxpath.ri.model.NodePointer.compareTo(NodePointer.java:639)\n\tat java.util.Arrays.mergeSort(Arrays.java:1152)\n\tat java.util.Arrays.sort(Arrays.java:1079)\n\tat java.util.Collections.sort(Collections.java:113)\n\tat org.apache.commons.jxpath.ri.EvalContext.constructIterator(EvalContext.java:176)\n\tat org.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:100)\n\tat org.apache.commons.jxpath.JXPathContext.selectNodes(JXPathContext.java:648)\n\tat org.apache.commons.jxpath.ri.model.VariablePointerTestCase.testUnionOfVariableAndNode(VariablePointerTestCase.java:76)",
    "desc_source": "jira"
  },
  "JxPath_6": {
    "description": "equality test for multi-valued variables does not conform to spec\ngiven e.g. variable d={\"a\", \"b\"}, the spec implies that \"$d = 'a'\" and that \"$d = 'b'\".  Instead of iterating the variable's components its immediate content (here, the String[]) is compared, causing the aforementioned assertions to fail.",
    "desc_source": "jira"
  },
  "JxPath_7": {
    "description": "Binary operators behaviour involving node-sets is incorrect\nAccording to XPath specification:\n\"If both objects to be compared are node-sets, then the comparison will be true if and only if there is a node in the first node-set and a node in the second node-set such that the result of performing the comparison on the string-values of the two nodes is true. If one object to be compared is a node-set and the other is a number, then the comparison will be true if and only if there is a node in the node-set such that the result of performing the comparison on the number to be compared and on the result of converting the string-value of that node to a number using the number function is true.\"\n\nBut following example illustrates, that this is not a JXPath behaviour:\n\n\n        JXPathContext pathContext = JXPathContext\n                .newContext(DocumentBuilderFactory.newInstance()\n                        .newDocumentBuilder().parse(\n                                new InputSource(new StringReader(\n                                        \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\"\n                                                + \"<doc/>\"))));\n        Boolean result = (Boolean) pathContext.getValue(\"2.0 > child1\",\n                Boolean.class);\n        assertFalse(result.booleanValue());\n\n\"child1\" is not found - right operand node set is empty, but result is TRUE, instead of FALSE.\n\nPlease, check greaterThan(), lesserThan(), etc methods of org.apache.xpath.objects.XObject for possible solution :)",
    "desc_source": "jira"
  },
  "JxPath_8": {
    "description": "Comparing with NaN is incorrect\n'NaN' > 'NaN' is true, but should be FALSE",
    "desc_source": "jira"
  },
  "JxPath_9": {
    "description": "Comparing with NaN is incorrect\n'NaN' > 'NaN' is true, but should be FALSE",
    "desc_source": "jira"
  },
  "JxPath_10": {
    "description": "Binary operators behaviour involving node-sets is incorrect\nAccording to XPath specification:\n\"If both objects to be compared are node-sets, then the comparison will be true if and only if there is a node in the first node-set and a node in the second node-set such that the result of performing the comparison on the string-values of the two nodes is true. If one object to be compared is a node-set and the other is a number, then the comparison will be true if and only if there is a node in the node-set such that the result of performing the comparison on the number to be compared and on the result of converting the string-value of that node to a number using the number function is true.\"\n\nBut following example illustrates, that this is not a JXPath behaviour:\n\n\n        JXPathContext pathContext = JXPathContext\n                .newContext(DocumentBuilderFactory.newInstance()\n                        .newDocumentBuilder().parse(\n                                new InputSource(new StringReader(\n                                        \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\"\n                                                + \"<doc/>\"))));\n        Boolean result = (Boolean) pathContext.getValue(\"2.0 > child1\",\n                Boolean.class);\n        assertFalse(result.booleanValue());\n\n\"child1\" is not found - right operand node set is empty, but result is TRUE, instead of FALSE.\n\nPlease, check greaterThan(), lesserThan(), etc methods of org.apache.xpath.objects.XObject for possible solution :)",
    "desc_source": "jira"
  },
  "JxPath_11": {
    "description": "Incomplete handling of undefined namespaces\nMcduffey, Joe <jdmcduf@nsa.gov>\n\nCan someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: xsi\n\nFor example the following\n<ElementA  A:myAttr=\"Mytype\">\n  <B:ElementB>MY VALUE</B:ElementB>\n</ElementA>\n\nWould result in the following exception:\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: A\n\nFYI: In this example there was a namespace decaration in the file and I also manually called the\nregisterNamespace(A,\"/http...\");\nregisterNamespace(B,\"/http...\");\n\nThere was no problem encountered for elements. Only attributes. Can someone help? Thanks.",
    "desc_source": "jira"
  },
  "JxPath_12": {
    "description": "Incomplete handling of undefined namespaces\nMcduffey, Joe <jdmcduf@nsa.gov>\n\nCan someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: xsi\n\nFor example the following\n<ElementA  A:myAttr=\"Mytype\">\n  <B:ElementB>MY VALUE</B:ElementB>\n</ElementA>\n\nWould result in the following exception:\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: A\n\nFYI: In this example there was a namespace decaration in the file and I also manually called the\nregisterNamespace(A,\"/http...\");\nregisterNamespace(B,\"/http...\");\n\nThere was no problem encountered for elements. Only attributes. Can someone help? Thanks.",
    "desc_source": "jira"
  },
  "JxPath_13": {
    "description": "Incomplete handling of undefined namespaces\nMcduffey, Joe <jdmcduf@nsa.gov>\n\nCan someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: xsi\n\nFor example the following\n<ElementA  A:myAttr=\"Mytype\">\n  <B:ElementB>MY VALUE</B:ElementB>\n</ElementA>\n\nWould result in the following exception:\norg.apache.common.ri.model.dom.DOMNodePointer.createAttribute\nunknown namespace prefix: A\n\nFYI: In this example there was a namespace decaration in the file and I also manually called the\nregisterNamespace(A,\"/http...\");\nregisterNamespace(B,\"/http...\");\n\nThere was no problem encountered for elements. Only attributes. Can someone help? Thanks.",
    "desc_source": "jira"
  },
  "JxPath_14": {
    "description": "Core rounding functions don't handle NaN or infinite values correctly\n        assertXPathValue(context, \"floor('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"floor(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"floor(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n\n        assertXPathValue(context, \"ceiling('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"ceiling(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"ceiling(2 div 0)\", new Double(Double.POSITIVE_INFINITY));\n\n        assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN));\n        assertXPathValue(context, \"round(-2 div 0)\", new Double(Double.NEGATIVE_INFINITY));\n        assertXPathValue(context, \"round(2 div 0)\", new Double(Double.POSITIVE_INFINITY));",
    "desc_source": "jira"
  },
  "JxPath_15": {
    "description": "Core union operation does not sort result nodes according to document order\nSource document:\n<MAIN><A>avalue</A><B>bvalue</B></MAIN>\n\nAccording to string() function defintion:\n\"A node-set is converted to a string by returning the string-value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned.\"\n\nFollowing XPath calculated incorrectly:\n string(/MAIN/B | /MAIN/A)\n\nExpected result: \"avalue\"\nActual value: \"bvalue\"\n\nReason:\nsorting of result nodes is missing from CoreOperationUnion",
    "desc_source": "jira"
  },
  "JxPath_16": {
    "description": "node() implementation in DOM and JDOM model\nI think that the code in DOMNodePointer.java, line 120 is wrong because considers only element and document to be matched by node().\nwhile instead it matches any node that pass from there.\n\ncase Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n\nshould be changed to \n\ncase Compiler.NODE_TYPE_NODE :\n                    return true;\n\nSame in JDOMNodePointer, line 391\n\n                  return true;//(node instanceof Element) || (node instanceof Document);\n\n",
    "desc_source": "jira"
  },
  "JxPath_17": {
    "description": "Namespaced attribute not selected with wildcard\nWith expression:\n\nxml/@*\n\nOn xml:\n\n<xml xmlns:x='foo' x:pop='a'/>\n\nselectSingleNode returns null, @x:* works fine.\n\nPossible Fix:\n\nIn DOMAttributeIterator, line 84\n\nif (equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n\nshould probably be changed to\n\nif (testPrefix==null || equalStrings(testPrefix, nodePrefix)) {\n                return true;\n            }\n",
    "desc_source": "jira"
  },
  "JxPath_18": {
    "description": "Issue with attribute::\nChecking test (Issue172_CountAttributeNode) I came with the following fix for the code in AttributeContext  line 72\nfrom \n-----\nif (!(nodeTest instanceof NodeNameTest)) {\n                return false;\n            }\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            \n------\n'\nto \n--- (outside method)\nprivate static final QName WILDCARD = new QName(\"\", \"*\");\n--- (in method)\n    \nfinal QName name ;\nif (nodeTest instanceof NodeTypeTest)\n{\n\t if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE_TYPE_NODE)\n\t\t name = WILDCARD;\n\t else return false;\n}\nelse if (nodeTest instanceof NodeNameTest) {\n\tname = ((NodeNameTest) nodeTest).getNodeName();\n}\nelse\n{\n\treturn false;\n}\n\n\n",
    "desc_source": "jira"
  },
  "JxPath_19": {
    "description": "JXPathContext.iteratePointers() does not work with multiple prefixes for a single namespace URI\nHave a look at the following document:\n\n<a:doc xmlns:a=\"ns\">\n  <a:elem />\n  <b:elem xmlns:b=\"ns\" />\n</a:doc>\n\nWe have two elements 'elem' in the same namespace 'ns'.\nThey have a different prefix, however.\n\nWhen we use JXPathContext.iteratePointers() to iterate over them, the first element is returned two times. The second element is not returned.\n\nThis is because\nin class org.apache.commons.jxpath.ri.model.dom.DOMNodePointer\nin method getRelativePositionByName() (line 546)\nwe have:\n\nif (nm.equals(node.getNodeName()))\n\nIn the example, we have\nnm  == \"a:elem\" and node == \"b:elem\"\n\nThus, equals() returns false. But since 'a' and 'b' are just different prefixes for the same namespace URI, we should have 'true'.\n\nI attached a testcase which reproduces the bug.",
    "desc_source": "jira"
  },
  "JxPath_20": {
    "description": "relational operations do not function properly when comparing a non-Iterator LHS to an Iterator RHS\nI have a simple JXpathContext, with the following variables: var1=0, var2=0, var3=1. When I try to evaluate the following expression - \"$var1 + $var2 <= $var3\", it returns false.",
    "desc_source": "jira"
  },
  "JxPath_21": {
    "description": "null handling is inconsistent\nComparing a vaule to null using unequals (\\!=) yields false!\n{noformat}\n        Map<String, Integer> m = new HashMap<String, Integer>();\n        m.put(\"a\", 1);\n        m.put(\"b\", null);\n        m.put(\"c\", 1);\n        JXPathContext c = JXPathContext.newContext(m);\n        System.out.println(c.getValue(\"a != b\") + \" should be true\");\n        System.out.println(c.getValue(\"a != c\") + \" should be false\");\n        System.out.println(c.getValue(\"a = b\") + \" should be false\");\n        System.out.println(c.getValue(\"a = c\") + \" should be true\");\n        System.out.println(c.getValue(\"not(a = b)\") + \" should be true\");\n        System.out.println(c.getValue(\"not(a = c)\") + \" should be false\");\n{noformat} \n\nOutput using 1.3:\n{color:red} false should be true{color}\nfalse should be false\nfalse should be false\ntrue should be true\ntrue should be true\nfalse should be false\n\n\nIn 1.2 it works correctly!",
    "desc_source": "jira"
  },
  "JxPath_22": {
    "description": "Resetting the default namespace causes a serious endless loop when requesting .asPath() on a node.\nsample smaller case:\n{code}\n<...>\n <b:foo xmlns:b=\"bla\" xmlns=\"test111\">    <!--  No nodes are placed in the tree within ns \"test111\" but the attribute is still there.-->\n  <b:bar>a</b:bar>                         <!-- is in ns 'bla' -->\n  <test xmlns=\"\"></test>                   <!-- does not have a namespace -->\n </b:foo>\n</...>\n{code}\n\nwhen requesting .asPath() on the 'test' node, it loops in org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer, String), \nand if it didn't loop it would create a wrong xpath '//b:fo/null:test' DOMNodePointer.asPath().\n\n\nSo I think that the fix should be in org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.asPath()\n\n{code}\n....\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n...\n{code}\n\nshould become\n{code}\n...\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null || nsURI.length() == 0) { // check for empty string which means that the node doesn't have a namespace.\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n...\n{code}\n",
    "desc_source": "jira"
  }
}