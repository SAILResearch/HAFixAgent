{
  "Lang_1": {
    "description": "NumberUtils does not handle Long Hex numbers\nNumberUtils.createLong() does not handle hex numbers, but createInteger() handles hex and octal.\nThis seems odd.\n\nNumberUtils.createNumber() assumes that hex numbers can only be Integer.\nAgain, why not handle bigger Hex numbers?\n\n==\n\nIt is trivial to fix createLong() - just use Long.decode() instead of valueOf().\nIt's not clear why this was not done originally - the decode() method was added to both Integer and Long in Java 1.2.\n\nFixing createNumber() is also fairly easy - if the hex string has more than 8 digits, use Long.\n\nShould we allow for leading zeros in an Integer? \nIf not, the length check is trivial.",
    "desc_source": "jira"
  },
  "Lang_3": {
    "description": "Method createNumber from NumberUtils doesn't work for floating point numbers other than Float\nMethod createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.",
    "desc_source": "jira"
  },
  "Lang_4": {
    "description": "LookupTranslator accepts CharSequence as input, but fails to work with implementations other than String\nThe core of {{org.apache.commons.lang3.text.translate}} is a {{HashMap<CharSequence, CharSequence> lookupMap}}.\n\nFrom the Javadoc of {{CharSequence}} (emphasis mine):\n{quote}\nThis interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. *It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map.*\n{quote}\n\nThe current implementation causes code such as the following to not work as expected:\n\n{code}\nCharSequence cs1 = \"1 < 2\";\nCharSequence cs2 = CharBuffer.wrap(\"1 < 2\".toCharArray());\n\nSystem.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1));\nSystem.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));\n{code}\n\n... which gives the following results (but should be identical):\n{noformat}\n1 &lt; 2\n1 < 2\n{noformat}\n\nThe problem, at a minimum, is that {{CharBuffer.equals}} is even documented in the Javadoc that:\n{quote}\nA char buffer is not equal to any other type of object.\n{quote}\n\n... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains.\n\nAn obvious work-around is to instead use something along the lines of either of the following:\n{code}\nSystem.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString()));\nSystem.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));\n{code}\n\n... which forces everything back to a {{String}}.  However, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns.  (As such, I was actually trying to use the {{translate}} method that outputs to a {{Writer}} - but simplified the above examples to omit this.)\n\nAnother option that I'm considering is to use a custom {{CharSequence}} wrapper around a {{char[]}} that implements {{hashCode()}} and {{equals()}} to work with those implemented on {{String}}.  (However, this will be interesting due to the symmetric assumption - which is further interesting that {{String.equals}} is currently implemented using {{instanceof}} - even though {{String}} is {{final}}...)",
    "desc_source": "jira"
  },
  "Lang_5": {
    "description": "LocaleUtils.toLocale does not parse strings starting with an underscore\nHi,\n\nJavadocs of Locale.toString() states that \"If the language is missing, the string will begin with an underbar.\". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString().\n\nThe fix for the ticket 328 does not handle well the case \"fr__P\", which I found out during fixing the first bug.\n\nI am attaching the patch for both problems.",
    "desc_source": "jira"
  },
  "Lang_6": {
    "description": "StringIndexOutOfBoundsException in CharSequenceTranslator\nI found that there is bad surrogate pair handling in the CharSequenceTranslator\n\nThis is a simple test case for this problem.\n\\uD83D\\uDE30 is a surrogate pair.\n\n{code:java}\n@Test\npublic void testEscapeSurrogatePairs() throws Exception {\n    assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\"));\n}\n{code}\n\nYou'll get the exception as shown below.\n\n{code}\njava.lang.StringIndexOutOfBoundsException: String index out of range: 2\n\tat java.lang.String.charAt(String.java:658)\n\tat java.lang.Character.codePointAt(Character.java:4668)\n\tat org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95)\n\tat org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)\n\tat org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)\n{code}\n\nPatch attached, the method affected:\n# public final void translate(CharSequence input, Writer out) throws IOException",
    "desc_source": "jira"
  },
  "Lang_7": {
    "description": "NumberUtils#createNumber - bad behaviour for leading \"--\"\nNumberUtils#createNumber checks for a leading \"--\" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal.\n\nReturning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException.\n\nIt's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.",
    "desc_source": "jira"
  },
  "Lang_8": {
    "description": "FastDateFormat's \"z\" pattern does not respect timezone of Calendar instances passed to format()\nThe work on LANG-462 has introduced a time zone formatting bug in FastDateFormat in commons-lang3.\n\nThe problem can be seen by this snippet:\n{code}\n// Always prints timezone name of machine's default timezone, ignoring TZ\n// set on calendar, even though the printed time itself respects calendar's TZ.\nCalendar myCal = Calendar.getInstance(TimeZone.getTimeZone(\"US/Central\"));\nSystem.out.println(FastDateFormat.getInstance(\"h:mma z\").format(myCal));\n{code}\n\nIf you happen to be in US/Central, this will print the right thing, but just try it with US/Eastern, US/Pacific, etc.  It will print the time in the correct timezone, but the timezone name at the end (the \"z\" pattern) will always be the system default timezone.  This is a regression against commons-lang 2.x.\n\nBasically, when the \"forced time zone\" code was removed, the TimeZoneNameRule class stopped respecting the Calendar instance's timezone, and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long).\n\nThe removal of the forced time zone stuff is surely the right thing to do (it was a mess).  I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance, but rather to use the TimeZone on the Calendar instance passed into appendTo(), just like TimeZoneNumberRule does.  Presumably then for efficiency, one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezone's display name.",
    "desc_source": "jira"
  },
  "Lang_9": {
    "description": "FastDateParser does not handle unterminated quotes correctly\nFDP does not handled unterminated quotes the same way as SimpleDateFormat\n\nFor example:\n\nFormat: 'd'd'\nDate: d3\n\nThis should fail to parse the format and date but it actually works.\nThe format is parsed as:\n\nPattern: d(\\p{IsNd}++)",
    "desc_source": "jira"
  },
  "Lang_10": {
    "description": "FastDateParser does not handle white-space properly\nThe SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters.\n\nThis means that FDP will parse dates that fail when parsed by SDP.",
    "desc_source": "jira"
  },
  "Lang_11": {
    "description": "RandomStringUtils throws confusing IAE when end <= start\nRandomUtils invokes Random#nextInt(n) where n = end - start.\n\nIf end <= start, then Random throws:\n\njava.lang.IllegalArgumentException: n must be positive\n\nThis is confusing, and does not identify the source of the problem.",
    "desc_source": "jira"
  },
  "Lang_12": {
    "description": "RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException\nIn commons-lang 2.6 line 250 :\n{code}ch = chars[random.nextInt(gap) + start];{code}\n-This line of code takes a random int to fetch a char in the _chars_ array regardless of its size.-\n-(Besides _start_ is useless here)-\n\n-Fixed version would be :-\n{code}//ch = chars[random.nextInt(gap)%chars.length];{code}\n\nWhen user pass 0 as _end_ or when the array is not null but empty this line ends up with an exception",
    "desc_source": "jira"
  },
  "Lang_13": {
    "description": "SerializationUtils throws ClassNotFoundException when cloning primitive classes\nIf a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.\n\n{noformat}\nimport org.apache.commons.lang3.SerializationUtils;\nimport org.junit.Test;\n\n\npublic class SerializationUtilsTest {\n\n\t\n\t@Test\n\tpublic void primitiveTypeClassSerialization(){\n\t\tClass<?> primitiveType = int.class;\n\t\t\n\t\tClass<?> clone = SerializationUtils.clone(primitiveType);\n\t\tassertEquals(primitiveType, clone);\n\t}\n}\n{noformat} \n\nThe problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4.\nThe SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's\nresoleClass method without delegating to the super method in case of a ClassNotFoundException.\n\nI understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation.\n\nFor example:\n{noformat}\n        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n            String name = desc.getName();\n            try {\n                return Class.forName(name, false, classLoader);\n            } catch (ClassNotFoundException ex) {\n            \ttry {\n            \t     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n            \t} catch (Exception e) {\n\t\t     return super.resolveClass(desc);\n\t\t}\n            }\n        }\n{noformat}\n\nHere is the code in ObjectInputStream that fixed the java bug.\n{noformat}\n    protected Class<?> resolveClass(ObjectStreamClass desc)\n\tthrows IOException, ClassNotFoundException\n    {\n\tString name = desc.getName();\n\ttry {\n\t    return Class.forName(name, false, latestUserDefinedLoader());\n\t} catch (ClassNotFoundException ex) {\n\t    Class cl = (Class) primClasses.get(name);\n\t    if (cl != null) {\n\t\treturn cl;\n\t    } else {\n\t\tthrow ex;\n\t    }\n\t}\n    }\n{noformat}\n",
    "desc_source": "jira"
  },
  "Lang_14": {
    "description": "StringUtils equals() relies on undefined behavior\nSince the {{java.lang.CharSequence}} class was first introduced in 1.4, the JavaDoc block has contained the following note:\n\n{quote}\nThis interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other.\n{quote}\n\nWhen the signature of the StringUtils equals() method was changed from {{equals(String, String)}} to {{equals(CharSequence, CharSequence)}} in R920543, the implementation still relied on calling CharSequence#equals(Object) even though, in general, the result is undefined.\n\nOne example where {{equals(Object)}} returns {{false}} even though, as CharSequences, two objects represent equal sequences is when one object is an instance of {{javax.lang.model.element.Name}} and the other object is a String.",
    "desc_source": "jira"
  },
  "Lang_15": {
    "description": "TypeUtils.getTypeArguments() misses type arguments for partially-assigned classes\nfailing test code to add to TypeUtilsTest.testGetTypeArguments():\n{code}\ntypeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\nAssert.assertEquals(2, typeVarAssigns.size());\nAssert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));\nAssert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));\n{code}\n\nThese should pass based on:\n{code}\n\npublic interface This<K, V> {\n}\n\npublic class Other<T> implements This<String, T> {\n}\n{code}\n\nThis case fails because the current code ignores the Other class due to its specifying its own type variables, which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.",
    "desc_source": "jira"
  },
  "Lang_16": {
    "description": "NumberUtils does not handle upper-case hex: 0X and -0X\nNumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException\n\nInteger.decode() handles both upper and lower case hex.",
    "desc_source": "jira"
  },
  "Lang_17": {
    "description": "StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.\nHello.\n\nI use StringEscapeUtils.escapeXml(input) to escape special characters for XML.\nThis method outputs wrong results when input contains characters in Supplementary Planes.\n\nString str1 = \"\\uD842\\uDFB7\" + \"A\";\nString str2 = StringEscapeUtils.escapeXml(str1);\n\n// The value of str2 must be equal to the one of str1,\n// because str1 does not contain characters to be escaped.\n// However, str2 is diffrent from str1.\n\nSystem.out.println(URLEncoder.encode(str1, \"UTF-16BE\")); //%D8%42%DF%B7A\nSystem.out.println(URLEncoder.encode(str2, \"UTF-16BE\")); //%D8%42%DF%B7%FF%FD\n\nThe cause of this problem is that the loop to translate input character by character is wrong.\nIn CharSequenceTranslator.translate(CharSequence input, Writer out),\nloop counter \"i\" moves from 0 to Character.codePointCount(input, 0, input.length()),\nbut it should move from 0 to input.length().\n",
    "desc_source": "jira"
  },
  "Lang_19": {
    "description": "StringIndexOutOfBoundsException when calling unescapeHtml4(\"&#03\")\nWhen calling unescapeHtml4() on the String \"&#03\" (or any String that contains these characters) an Exception is thrown:\n\nException in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 4\n\tat java.lang.String.charAt(String.java:686)\n\tat org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49)\n\tat org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53)\n\tat org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88)\n\tat org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60)\n\tat org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)",
    "desc_source": "jira"
  },
  "Lang_20": {
    "description": "StringUtils.join throws NPE when toString returns null for one of objects in collection\nTry\n{code} \nStringUtils.join(new Object[]{\n        new Object() {\n          @Override\n          public String toString() {\n            return null;\n          }\n        }\n    }, ',');\n{code}\n\nToString should probably never return null, but it does in javax.mail.internet.InternetAddress",
    "desc_source": "jira"
  },
  "Lang_21": {
    "description": "DateUtils.isSameLocalTime does not work correct\nHi, I think I found a bug in the DateUtils class in the method isSameLocalTime.\n\nExample: \nCalendar a = Calendar.getInstance();\na.setTimeInMillis(1297364400000L);\n\nCalendar b = Calendar.getInstance();\nb.setTimeInMillis(1297321200000L);\n\nAssert.assertFalse(DateUtils.isSameLocalTime(a, b));\n\nThis is because the method compares \ncal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) \n\nbut I think it has to be \ncal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY)\n\n\n\t",
    "desc_source": "jira"
  },
  "Lang_22": {
    "description": "org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)\nThe greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method.\n\n{code:title=FractionTest.java|borderStyle=solid}\n\t// additional test cases\n\tpublic void testReducedFactory_int_int() {\n\t\t// ...\n\t\tf = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n\t\tassertEquals(Integer.MIN_VALUE / 2, f.getNumerator());\n\t\tassertEquals(1, f.getDenominator());\n\n\tpublic void testReduce() {\n\t\t// ...\n\t\tf = Fraction.getFraction(Integer.MIN_VALUE, 2);\n\t\tresult = f.reduce();\n\t\tassertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n\t\tassertEquals(1, result.getDenominator());\n{code} \n",
    "desc_source": "jira"
  },
  "Lang_23": {
    "description": "text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object)\nFindbugs:\n\nBug: org.apache.commons.lang3.text.ExtendedMessageFormat doesn't override java.text.MessageFormat.equals(Object)\nPattern id: EQ_DOESNT_OVERRIDE_EQUALS, type: Eq, category: STYLE\n\nThis class extends a class that defines an equals method and adds fields, but doesn't define an equals method itself. Thus, equality on instances of this class will ignore the identity of the subclass and the added fields. Be sure this is what is intended, and that you don't need to override the equals method. Even if you don't need to override the equals method, consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super.equals(o). \n",
    "desc_source": "jira"
  },
  "Lang_24": {
    "description": "NumberUtils.isNumber(String)  is not right when the String is \"1.1L\"\n\"1.1L\"  is not a Java Number . but NumberUtils.isNumber(String) return true.\n\nperhaps change:\n{code:java}\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n{code}\nto:\n{code:java}\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp && !hasDecPoint;\n            }\n{code}",
    "desc_source": "jira"
  },
  "Lang_26": {
    "description": "FastDateFormat.format() outputs incorrect week of year because locale isn't respected\nFastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. \"ww\") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output.\n\nHere is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:\n{code}\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.text.SimpleDateFormat;\n\nimport org.apache.commons.lang.time.FastDateFormat;\n\npublic class FastDateFormatWeekBugDemo {\n    public static void main(String[] args) {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Locale locale = new Locale(\"sv\", \"SE\");\n\n        Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome\n        cal.set(2010, 0, 1, 12, 0, 0);\n        Date d = cal.getTime();\n        System.out.println(\"Target date: \" + d);\n\n        FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n        SimpleDateFormat sdf = new SimpleDateFormat(\"EEEE', week 'ww\", locale);\n        System.out.println(\"FastDateFormat:   \" + fdf.format(d)); // will output \"FastDateFormat:   fredag, week 01\"\n        System.out.println(\"SimpleDateFormat: \" + sdf.format(d)); // will output \"SimpleDateFormat: fredag, week 53\"\n    }\n}\n{code}\nIf sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.\n",
    "desc_source": "jira"
  },
  "Lang_27": {
    "description": "NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing \"e\" and \"E\" is passed in\nNumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in.\nOne example of such a String is \"1eE\".\n",
    "desc_source": "jira"
  },
  "Lang_28": {
    "description": "StringEscapeUtils.escapeXML() can't process UTF-16 supplementary characters\nSupplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/\n\nCurrently, StringEscapeUtils.escapeXML() isn't aware of this coding scheme and treats each char as one character, which is not always right.\n\nA possible solution in class Entities would be:\n\n    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; i++) {\n            int code = str.codePointAt(i);\n            String entityName = this.entityName(code);\n            if (entityName != null) {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            } else if (code > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(code);\n                    writer.write(';');\n            } else {\n                    writer.write((char) code);\n            }\n\n            if (code > 0xffff) {\n                    i++;\n            }\n        }\n    }\n\nBesides fixing escapeXML(), this will also affect HTML escaping functions. I guess that's a good thing, but please remember I have only tested escapeXML().\n",
    "desc_source": "jira"
  },
  "Lang_29": {
    "description": "SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM\nCan be replicated in the Android emulator quite easily.\n\nStack trace:\n\n{noformat}\n\nat org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98)\nE/AndroidRuntime( 1681): \t... 17 more\nE/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError\nE/AndroidRuntime( 1681): \tat org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle.<init>(ToStringStyle.java:2276)\nE/AndroidRuntime( 1681): \tat org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94)\nE/AndroidRuntime( 1681): \t... 18 more\nE/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException\nE/AndroidRuntime( 1681): \tat java.lang.String.substring(String.java:1571)\nE/AndroidRuntime( 1681): \tat org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153)\nE/AndroidRuntime( 1681): \tat org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)\n{noformat}",
    "desc_source": "jira"
  },
  "Lang_30": {
    "description": "StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.\nStringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters.\n\nFor example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as \"\\uD840\\uDC00\"\n\n\tprivate static final String CharU20000 = \"\\uD840\\uDC00\";\n\tprivate static final String CharU20001 = \"\\uD840\\uDC01\";\n\nYou can see Unicode supplementary characters correctly implemented in the JRE call:\n\n\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\nBut this is broken:\n\n\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n\nThis is fine:\n\n\tassertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000));\n\tassertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001));\n\tassertEquals(true, StringUtils.contains(CharU20000, CharU20000));\n\tassertEquals(false, StringUtils.contains(CharU20000, CharU20001));\n\nbecause the method calls the JRE to perform the match.\n\nMore than you want to know:\n- http://java.sun.com/developer/technicalArticles/Intl/Supplementary/",
    "desc_source": "jira"
  },
  "Lang_31": {
    "description": "StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.\nStringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters.\n\nFor example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as \"\\uD840\\uDC00\"\n\n\tprivate static final String CharU20000 = \"\\uD840\\uDC00\";\n\tprivate static final String CharU20001 = \"\\uD840\\uDC01\";\n\nYou can see Unicode supplementary characters correctly implemented in the JRE call:\n\n\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\nBut this is broken:\n\n\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n\nThis is fine:\n\n\tassertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000));\n\tassertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001));\n\tassertEquals(true, StringUtils.contains(CharU20000, CharU20000));\n\tassertEquals(false, StringUtils.contains(CharU20000, CharU20001));\n\nbecause the method calls the JRE to perform the match.\n\nMore than you want to know:\n- http://java.sun.com/developer/technicalArticles/Intl/Supplementary/",
    "desc_source": "jira"
  },
  "Lang_32": {
    "description": "Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments\nThe thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload.\n\nSee http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.",
    "desc_source": "jira"
  },
  "Lang_33": {
    "description": "ClassUtils.toClass(Object[]) throws NPE on null array element\nsee summary",
    "desc_source": "jira"
  },
  "Lang_34": {
    "description": "Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments\nThe thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload.\n\nSee http://markmail.org/thread/uetw2fdrsqgbh2cv for more info.",
    "desc_source": "jira"
  },
  "Lang_35": {
    "description": "ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException\nArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException.\n\nFor example, the following code compiles without a warning:\n\n{code}\nString[] sa = ArrayUtils.add(stringArray, aString);\n{code}\n\nand works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception.\n\nIf both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed.\n\nI think the method ought to be changed to throw IllegalParameterException when both parameters are null.\n",
    "desc_source": "jira"
  },
  "Lang_36": {
    "description": "NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal Place\nNumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g., \"2.\" should be considered a number because new BigDecimal(\"2.\") works fine.  This could be done by adding the code below after line 1444, which is the if (chars[i] == 'e' || chars[i] == 'E') block.\n\nif (chars[i] == '.') {\n    if (hasDecPoint || hasExp) {\n        // two decimal points or dec in exponent   \n        return false;\n    }\n    return foundDigit; // single trailing decimal point after non-exponent is ok\n}",
    "desc_source": "jira"
  },
  "Lang_37": {
    "description": "ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed types very well\nArrayUtils.addAll(T[] array1, T... array2) does not handle mixed array types very well.\n\nThe stack trace for \n\nNumber[] st = ArrayUtils.addAll(new Integer[]{1}, new Long[]{2L});\n\nstarts:\n\njava.lang.ArrayStoreException\n\tat java.lang.System.arraycopy(Native Method)\n\tat org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962)\n\nwhich is not all that obvious.\n\nIt would be a lot clearer if the method threw an IlegalArgumentException or similar.",
    "desc_source": "jira"
  },
  "Lang_38": {
    "description": "DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations\nIf a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem.\n\nFor example, the following unit test fails:\n\n{noformat}\n  public void testFormat_CalendarIsoMsZulu() {\n    final String dateTime = \"2009-10-16T16:42:16.000Z\";\n\n    // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n    // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n    cal.clear();\n    cal.set(2009, 9, 16, 8, 42, 16);\n\n\n    FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n    assertEquals(\"dateTime\", dateTime, format.format(cal));\n  }\n{noformat}\n\nHowever, this unit test passes:\n\n{noformat}\n  public void testFormat_CalendarIsoMsZulu() {\n    final String dateTime = \"2009-10-16T16:42:16.000Z\";\n    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n    cal.clear();\n    cal.set(2009, 9, 16, 8, 42, 16);\n    cal.getTime();\n\n    FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n    assertEquals(\"dateTime\", dateTime, format.format(cal));\n  }\n{noformat}",
    "desc_source": "jira"
  },
  "Lang_39": {
    "description": "StringUtils replaceEach - Bug or Missing Documentation \nThe following Test Case for replaceEach fails with a null pointer exception.\nI have expected that all StringUtils methods are \"null-friendly\"\nThe use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null.\nI admit the use case is not perfect, because it is unclear what happens on the replace.\nI outlined three expectations in the test case, of course only one should be met.\n\nIf it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string\n\n{code}\nimport static org.junit.Assert.assertEquals;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.junit.Test;\n\n\npublic class StringUtilsTest {\n\n\t@Test\n\tpublic void replaceEach(){\n\t\tString original = \"Hello World!\";\n\t\tString[] searchList = {\"Hello\", \"World\"};\n\t\tString[] replacementList = {\"Greetings\", null};\n\t\tString result = StringUtils.replaceEach(original, searchList, replacementList);\n\t\tassertEquals(\"Greetings !\", result);\n\t\t//perhaps this is ok as well\n                //assertEquals(\"Greetings World!\", result);\n                //or even\n\t\t//assertEquals(\"Greetings null!\", result);\n\t}\n\n\t\n}\n{code}",
    "desc_source": "jira"
  },
  "Lang_40": {
    "description": "Fix case-insensitive string handling\n{{String.to*Case()}} is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see [Common Bug #3|http://www.nabble.com/Re%3A-Common-Bugs-p14931921s177.html] for details.",
    "desc_source": "jira"
  },
  "Lang_41": {
    "description": "ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.\nA semicolon is introduced into the class name at the end for all arrays...\n\nString sArray[] = new String[2];\nsArray[0] = \"mark\";\nsArray[1] = \"is cool\";\nString simpleString = \"chris\";\n\t\t\nassertEquals(\"String\", ClassUtils.getShortClassName(simpleString, null));\nassertEquals(\"String;\", ClassUtils.getShortClassName(sArray, null));",
    "desc_source": "jira"
  },
  "Lang_42": {
    "description": "StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 characters\nCharacters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely:\n\nimport org.apache.commons.lang.*;\n\npublic class J2 {\n    public static void main(String[] args) throws Exception {\n        // this is the utf8 representation of the character:\n        // COUNTING ROD UNIT DIGIT THREE\n        // in unicode\n        // codepoint: U+1D362\n        byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n\n        //output is: &amp;#55348;&amp;#57186;\n        // should be: &amp;#119650;\n        System.out.println(\"'\" + StringEscapeUtils.escapeHtml(new String(data, \"UTF8\")) + \"'\");\n    }\n}\n\nShould be very quick to fix, feel free to drop me an email if you want a patch.",
    "desc_source": "jira"
  },
  "Lang_43": {
    "description": "ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes\nWhen using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur.\n\nExample that will cause error:\n\n{code:title=ExtendedMessageFormatTest.java|borderStyle=solid}\n\nprivate static Map<String, Object> formatRegistry = new HashMap<String, Object>();    \n    static {\n        formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());\n    }\n    \n    public static void main(String[] args) {\n        ExtendedMessageFormat mf = new ExtendedMessageFormat(\"it''s a {dummy} 'test'!\", formatRegistry);\n        String formattedPattern = mf.format(new String[] {\"great\"});\n        System.out.println(formattedPattern);\n    }\n}\n\n{code}\n\nThe following change starting at line 421 on the 2.4 release seems to fix the problem:\n\n{code:title=ExtendedMessageFormat.java|borderStyle=solid}\nCURRENT (Broken):\nif (escapingOn && c[start] == QUOTE) {\n        return appendTo == null ? null : appendTo.append(QUOTE);\n}\n\nWORKING:\nif (escapingOn && c[start] == QUOTE) {\n        next(pos);\n        return appendTo == null ? null : appendTo.append(QUOTE);\n}\n{code}",
    "desc_source": "jira"
  },
  "Lang_44": {
    "description": "NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an \"l\" is passed in.\nSeems to be similar to LANG-300, except that if you don't place a digit in front of the \"l\" or \"L\" it throws a StringIndexOutOfBoundsException instead.",
    "desc_source": "jira"
  },
  "Lang_45": {
    "description": "WordUtils.abbreviate bug when lower is greater than str.length\nIn WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower.\nBut lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too...\nThen, str.substring(0, upper) throw a StringIndexOutOfBoundsException\n\nThe fix is to adjust lower to the length of the string",
    "desc_source": "jira"
  },
  "Lang_46": {
    "description": "StringEscapeUtils.escapeJava(String) escapes '/' characters\nCommons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes '/' characters, which is not a valid \"escapable\" character in Java strings.  I haven't tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java \"escapable\" characters are escaped by escapeJava(String).\n\nThis bug may have appeared as an unintended side-effect of the fix for LANG-363.\n\nAlso the javadoc for escapeJava is now a little off, in that '/' should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules.\n\nThe following is a JUnit3 test demonstrating the bug.\n\nimport junit.framework.TestCase;\n\nimport org.apache.commons.lang.StringEscapeUtils;\n\npublic class StringEscapeUtilsTest extends TestCase {\n    public void testEscapeJavaWithSlash() {\n        final String input = \"String with a slash (/) in it\";\n        \n        final String expected = input;\n        final String actual   = StringEscapeUtils.escapeJava( input );\n\n        /**\n         * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters,\n         * which are not a valid character to escape in a Java string.  \n         */\n        assertEquals( expected, actual );\n    }\n}\n\n",
    "desc_source": "jira"
  },
  "Lang_47": {
    "description": "StrBuilder appendFixedWidth does not handle nulls\nAppending a null value with fixed width causes a null pointer exception if getNullText() has not been set.",
    "desc_source": "jira"
  },
  "Lang_49": {
    "description": "infinite loop in Fraction.reduce when numerator == 0\nSummary pretty much says it all.",
    "desc_source": "jira"
  },
  "Lang_50": {
    "description": "FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change\nThe FastDateFormat getDateInstance() and getDateTimeInstance()  methods create the HashMap key from various items including the locale.\n\nIf the locale is null, then it is not made part of the key, but the stored object is created using the current default locale.\n\nIf the Locale is changed subsequently, then the wrong locale is applied.\n\nPatch for test case to follow.\n",
    "desc_source": "jira"
  },
  "Lang_51": {
    "description": "BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException\nThe method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test:\n\nassertEquals(false, BooleanUtils.toBoolean(\"tru\"));\n\nThe end of case 3 should return false.\n\nPatch to follow for source and unit test.",
    "desc_source": "jira"
  },
  "Lang_52": {
    "description": "StringEscapeUtils.escapeJavaScript() method did not escape '/' into '\\/', it will make IE render page uncorrectly\nIf Javascripts including'/', IE will parse the scripts uncorrectly, actually '/' should be escaped to '\\/'.\nFor example, document.getElementById(\"test\").value = '<script>alert(\\'aaa\\');</script>';this expression will make IE render page uncorrect, it should be document.getElementById(\"test\").value = '<script>alert(\\'aaa\\');<\\/script>';\n\nBtw, Spring's JavascriptEscape behavor is correct.\nTry  to run below codes, you will find the difference:\n  String s = \"<script>alert('aaa');</script>\";\n  String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);\n  System.out.println(\"Spring JS Escape : \"+str);\n  str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);\n  System.out.println(\"Apache Common Lang JS Escape : \"+ str);",
    "desc_source": "jira"
  },
  "Lang_53": {
    "description": "Dates.round() behaves incorrectly for minutes and seconds\nGet unexpected output for rounding by minutes or seconds.\n\npublic void testRound()\n{\n    Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n    testCalendar.set(2007, 6, 2, 8, 9, 50);\n    Date date = testCalendar.getTime();\n    System.out.println(\"Before round() \" + date);\n    System.out.println(\"After round()  \" + DateUtils.round(date, Calendar.MINUTE));\n}\n\n--2.1 produces\nBefore round() Mon Jul 02 03:09:50 CDT 2007\nAfter round()  Mon Jul 02 03:10:00 CDT 2007 -- this is what I would expect\n\n--2.2 and 2.3 produces\nBefore round() Mon Jul 02 03:09:50 CDT 2007\nAfter round()  Mon Jul 02 03:01:00 CDT 2007 -- this appears to be wrong\n",
    "desc_source": "jira"
  },
  "Lang_54": {
    "description": "LocaleUtils.toLocale() rejects strings with only language+variant\nLocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX\n\nThis string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale(\"fr\", \"\", \"POSIX\").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code.\n\nCommons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.",
    "desc_source": "jira"
  },
  "Lang_55": {
    "description": "StopWatch: suspend() acts as split(), if followed by stop()\nIn my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:\n\n        StopWatch sw = new StopWatch();\n\n        sw.start();\n        Thread.sleep(1000);\n        sw.suspend();\n        // Time 1 (ok)\n        System.out.println(sw.getTime());\n\n        Thread.sleep(2000);\n        // Time 1 (again, ok)\n        System.out.println(sw.getTime());\n\n        sw.resume();\n        Thread.sleep(3000);\n        sw.suspend();\n        // Time 2 (ok)\n        System.out.println(sw.getTime());\n\n        Thread.sleep(4000);\n        // Time 2 (again, ok)\n        System.out.println(sw.getTime());\n\n        Thread.sleep(5000);\n        sw.stop();\n        // Time 2 (should be, but is Time 3 => NOT ok)\n        System.out.println(sw.getTime());\n\n\nsuspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?\n",
    "desc_source": "jira"
  },
  "Lang_56": {
    "description": "FastDateFormat.mRules is not transient or serializable\nReported by FindBugs.\n\nEither we need to make the Rule interface Serializable, or make mRules transient and add deserializing code to kick off init().",
    "desc_source": "jira"
  },
  "Lang_57": {
    "description": "NullPointerException in isAvailableLocale(Locale)\nFindBugs pointed out:\n\n   UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet\n\ncAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.",
    "desc_source": "jira"
  },
  "Lang_58": {
    "description": "NumberUtils.createNumber throws NumberFormatException for one digit long\nNumberUtils.createNumber throws a NumberFormatException when parsing \"1l\", \"2l\" .. etc...\n\nIt works fine if you try to parse \"01l\" or \"02l\".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for \"1l\"",
    "desc_source": "jira"
  },
  "Lang_59": {
    "description": "Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException\nThere's a bug in method appendFixedWidthPadRight of class StrBuilder:\n\npublic StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n ==>            str.getChars(0, strLen, buffer, size);   <==== BUG: it should be str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\nThis is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width.\n\nIt's counterpart method appendFixedWidthPadLeft seems to be ok.",
    "desc_source": "jira"
  },
  "Lang_60": {
    "description": "StrBuilder contains usages of thisBuf.length when they should use size\nWhile fixing LANG-294 I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.",
    "desc_source": "jira"
  },
  "Lang_61": {
    "description": "StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.\nStrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem:\n\nStrBuilder.deleteAll() - added to testDeleteAll_String():\n\n        sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n        sb.deleteAll(\"\\n%BLAH%\");\n        assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString());\n\nthis causes the following error:\njava.lang.ArrayIndexOutOfBoundsException\n\tat java.lang.System.arraycopy(Native Method)\n\tat org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114)\n\tat org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188)\n\tat org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n\n\nStrBuilder.replaceAll() - added to testReplaceAll_String_String():\n\n        sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n        sb.replaceAll(\"\\n%BLAH%\", \"\");\n        assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString());\n\nthis causes the exception:\n\njava.lang.ArrayIndexOutOfBoundsException\n\tat java.lang.System.arraycopy(Native Method)\n\tat org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256)\n\tat org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339)\n\tat org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)",
    "desc_source": "jira"
  },
  "Lang_62": {
    "description": "unescapeXml(\"&12345678;\") should be \"&12345678;\"\nFollowing test (in EntitiesTest.java) fails:\n\n    public void testNumberOverflow() throws Exception {\n        doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\");\n        doTestUnescapeEntity(\"x&#12345678;y\", \"x&#12345678;y\");\n        doTestUnescapeEntity(\"&#x12345678;\", \"&#x12345678;\");\n        doTestUnescapeEntity(\"x&#x12345678;y\", \"x&#x12345678;y\");\n    }\n\nMaximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is.",
    "desc_source": "jira"
  },
  "Lang_63": {
    "description": "DurationFormatUtils returns wrong result\nDurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005\n\nThe following code will result in a String of -2 which is way off.\n\nI've tested against 2.1 and 2.2.\n\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 31);\n        cal.set(Calendar.YEAR, 2005);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), \"MM\");\n        System.out.println(result);\n",
    "desc_source": "jira"
  },
  "Lang_64": {
    "description": "ValuedEnum.compareTo(Object other) not typesafe - it easily could be...\nint org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)\n is not typesafe - if the int-values are the same, it will return \"0\" even for two totally different sub-classes of ValuedEnum",
    "desc_source": "jira"
  },
  "Lang_65": {
    "description": "[lang] DateUtils.truncate method is buggy when dealing with DST switching hours\nTry to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10-\n31 01:00:00 MST, which is one hour after the input hour.\n\n    // truncate 2004-10-31 01:00:00 MDT\n    Date oct31_01MDT = new Date(1099206000000L);    \n    Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);\n    assertEquals(oct31_01MDT, result);",
    "desc_source": "jira"
  }
}