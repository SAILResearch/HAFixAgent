{
  "JacksonDatabind_1": {
    "description": "NULL values are duplicated when serializing as array [via @JsonFormat(shape = JsonFormat.Shape.ARRAY)]\nExample:\n\n``` java\npublic class TestOuter {\n\n    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n    public ArrayList<TestInner> array;\n\n    public TestOuter() {\n        this.array = new ArrayList<TestInner>();\n        this.array.add(new TestInner(1, \"one\"));\n        this.array.add(new TestInner(0, null));\n    }\n\n    private class TestInner {\n        public int i;\n        public String mayBeNull;\n\n        public TestInner(int i, String s) {\n            this.i = i;\n            this.mayBeNull = s;\n        }\n    }\n}\n```\n\nSerializing an instance of TestOuter will produce the following incorrect result (as of Jackson 2.2.1):\n\n``` json\n\"array\": [[1, \"one\"], [0, null, null]]\n```\n\nwhere the null value is duplicated. The expected result would be:\n\n``` json\n\"array\": [[1, \"one\"], [0, null]]\n```\n\nI tracked the issue down to:\n\n``` java\npackage com.fasterxml.jackson.databind.ser;\n// ...\npublic class BeanPropertyWriter {\n// ...\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n    // ... ...\n```\n\nwhere I suspect there is a missing \"return\", to exit the function once handling of the null value in the dedicated branch is done.\nAs it is now, a null value is first serialized in the dedicated branch (jgen.writeNull()), and then execution continues on the \"normal\" (non-null) path and eventually the value is serialized once again.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_2": {
    "description": "Unwanted POJO's embedded in tree via serialization to tree\nI have a class, more or less:\n\n```\n   class X<T> {\n       String s;\n       List<T> items;\n  };\n```\n\nIt has a custom serializer.\n\nWhen I serialize to a tree, the entire list ends up as a\nVALUE_EMBEDDED_OBJECT: the ArrayList itself.\n\nHere's the serializer class, note the use of writeObjectField.\n\n```\npublic class ListAttributeSerializer extends JsonSerializer<ListAttribute> {\n    @Override\n    public void serialize(ListAttribute value, JsonGenerator jgen,\nSerializerProvider provider) throws IOException {\n        jgen.writeStartObject();\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        jgen.writeEndObject();\n    }\n\n    @Override\n    public void serializeWithType(ListAttribute value, JsonGenerator\njgen, SerializerProvider provider, TypeSerializer typeSer) throws\nIOException {\n        typeSer.writeTypePrefixForObject(value, jgen);\n        jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n        jgen.writeObjectField(\"items\", value.getItems());\n        typeSer.writeTypeSuffixForObject(value, jgen);\n}\n}\n```\n\nAnd Tatu wrote me:\n\nOk. valueToTree() uses TokenBuffer as target, so it probably then simply retains Object passed as-is, to defer conversion/serialization, for common use case of buffering. But in your case you would rather get actual serialization into JsonNodes.\n\nYou will probably want to write conversion out then, something like:\n\nbyte[] json = mapper.writeValueAsBytes(referenceText);\nJsonNode tree = mapper.readTree(json);\n\nThis is just the work-around on short term.\nBut this is one thing where configurability might be needed; or possibly different methods. One that forces full serialization into JSON with no POJONodes, other that leaves things as is.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_3": {
    "description": "Regression updating from 2.3.3 to 2.4.0: `null` won't deserialize in `String[]`\nSteps to reproduce\n1. Clone the repository at https://github.com/huxi/sulky\n2. Execute the contained `./gradlew` or `gradlew.bat`\n3. Clone the repository at https://github.com/huxi/lilith/\n4. Change jackson-version [in the project.ext.versions map of dependencyDefinitions.gradle](https://github.com/huxi/lilith/blob/master/dependencyDefinitions.gradle#L6) from `'2.3.3'` to `'2.4.0'`.\n5. Execute the contained `./gradlew` or `gradlew.bat`\n\nThere will be six test-failures with 2.4.0 that won't happen with 2.3.3.\n\nThere are actually only 2 test-methods that fail 3 times each.\n\nThose methods reside at [full()](https://github.com/huxi/lilith/blob/master/lilith-data/logging-io-test/src/main/java/de/huxhorn/lilith/data/logging/test/LoggingEventIOTestBase.java#L230) and [nullArgument()](https://github.com/huxi/lilith/blob/master/lilith-data/logging-io-test/src/main/java/de/huxhorn/lilith/data/logging/test/LoggingEventIOTestBase.java#L120).\n\nI first suspected that `AfterburnerModule` might be the culprit but removing it from `LoggingJsonDecoder`/`LoggingJsonEncoder` didn't fix the problem.\n\nSorry for not narrowing down the problem further. I'll give this another look tomorrow but you may already be able to find the issue in the meantime.\n\nThe interesting thing is that several other test cases are working as intended...\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_4": {
    "description": "Index is never set for Collection and Array in InvalidFormatException.Reference\nWhen a InvalidFormatException is created, index values is always '-1'.\nIndeed, in StringCollectionDeserializer, and CollectionDeserializer the exception is not caught.\nThe JsonMappingException shoud be caught and the index should be added and based on the \"result\" size.\nWithout this information, there is no way to get the index of the item involved in the mapping error.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_5": {
    "description": "Mixin annotations lost when using a mixin class hierarchy with non-mixin interfaces\nIn summary, mixin annotations are lost when Jackson scans a parent mixin class with Json annotations followed by an interface implemented by the parent mixin class that does not have the same Json annotations.\nJackson version: 2.4.0\n\nDetail:\nI have the following class structure\n\n``` java\npublic interface Contact {\n    String getCity();\n}\n\npublic class ContactImpl implements Contact {\n    public String getCity() { ... }\n}\n\npublic class ContactMixin implements Contact {\n    @JsonProperty\n    public String getCity() { return null; }\n}\n\npublic interface Person extends Contact {}\n\npublic class PersonImpl extends ContactImpl implements Person {}\n\npublic class PersonMixin extends ContactMixin implements Person {}\n```\n\nand I configure a module as\n\n``` java\n// There are other getters/properties in the Impl class that do not need to be serialized and so\n// I am using the Mixin to match the interface and explicitly annotate all the inherited methods\nmodule.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)\n    .disable(MapperFeature.AUTO_DETECT_FIELDS)\n    .disable(MapperFeature.AUTO_DETECT_GETTERS)\n    .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)\n    .disable(MapperFeature.INFER_PROPERTY_MUTATORS);\nmodule.setMixInAnnotation(Person.class, PersonMixin.class);\n```\n\nWhen a `PersonImpl` instance is serialized, `city` is not included.\n\nI debugged the code and this is what happens:\nIn `AnnotatedClass.resolveMemberMethods()` the supertypes of `PersonImpl` are `[Person.class, Contact.class, ContactImpl.class]` in that order.\n\nIt starts with `Person` for which it finds `PersonMixin` and proceeds to `AnnotatedClass._addMethodMixIns()`. Here the `parents` list has `[PersonMixin, ContactMixin, Contact]`. When it processes `ContactMixin` it adds `getCity()` with the `JsonProperty` annotation. Then it processes `Contact`, doesn't find `getCity()` in `methods` map and so creates a new `AnnotatedMethod` for `getCity()` with the one from the interface which has no annotation which replaces the one from `ContactMixin`\n\nThe workaround for this issue is to explicitly add any parent mixins to the module i.e.\n\n``` java\nmodule.setMixInAnnotation(Contact.class, ContactMixin.class);\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_6": {
    "description": "Add Support for Parsing All Compliant ISO-8601 Date Formats\nSome providers create JSON date stamps in ISO-8601 formats that cannot be parsed by the jackson-databind library. Here is a sampling of some valid formats that do not parse correctly:\n\n2014-10-03T18:00:00.6-05:00\n2014-10-03T18:00:00.61-05:00\n1997-07-16T19:20+01:00\n1997-07-16T19:20:30.45+01:00\n\nThe last two actually come from the ISO-8601 notes on http://www.w3.org/TR/NOTE-datetime.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_7": {
    "description": "Possibly wrong `TokenBuffer` delegate deserialization using `@JsonCreator`\n``` java\nclass Value {\n@JsonCreator\npublic static Value from(TokenBuffer buffer) {\n...\n}\n```\n\nGiven JSON string is  `{ \"a\":1, \"b\":null }`, it is expected that while deserializing using delegate buffer,\ncurrent token will be start object `{`, and rest of the tokens will be available in buffer:\n\n```\n[START_OBJECT, FIELD_NAME, VALUE_NUMBER_INT, FIELD_NAME, VALUE_NULL, END_OBJECT]\n```\n\nBut, buffers ends up being started with field name and then contains single attribute value\n\n```\n[FIELD_NAME, VALUE_NUMBER_INT]\n```\n\nIt's due to how `TokenBuffer#copyCurrentStructure` works when we have current token as a `FIELD_NAME`, rather than `START_OBJECT`, because it's forced to move to next token [BeanDeserializer.java:120](https://github.com/FasterXML/jackson-databind/blob/2.4/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java#L120)\n\nHope this helps to nail it down. Is it an intended behavior, or it's regression/bug? \n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_8": {
    "description": "Problem with bogus conflict between single-arg-String vs `CharSequence` constructor\nAlthough it is good idea to allow recognizing `CharSequence` as almost like an alias for `String`, this can cause problems for classes like `StringBuilder` that have separate constructors for both.\nThis actually throws a bogus exception for 2.5.0, due to introduction of ability to recognize `CharSequence`.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_9": {
    "description": "Deserializing Map<Class<? extends Object>, String>\nI am having problems deserializing my `Map<Class<? extends Object>, String>`. Simple test case demonstrates it:\n\n``` java\n@Test\npublic void testMapWithClassAsKey() throws Exception {\n    Map<Class<? extends Object>, String> map = new HashMap<>();\n    map.put(ArrayList.class, \"ArrayList\");\n    map.put(HashMap.class, \"HashMap\");\n\n    ObjectMapper mapper = new ObjectMapper();\n\n    String json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map);\n    System.out.println(json);\n    mapper.readValue(json, new TypeReference<Map<Class<? extends Object>, String>>(){});\n}\n```\n\nThis test serializes the map as:\n\n``` json\n{\n    \"class java.util.ArrayList\" : \"ArrayList\",\n    \"class java.util.HashMap\" : \"HashMap\"\n}\n```\n\n`mapper.readValue(json, new TypeReference<Map<Class<? extends Object>, String>>(){});` then throws a `Exception`:\n\n```\ncom.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct     Map key of type java.lang.Class from String \"class java.util.ArrayList\": not a valid representation: Can not construct Map key of type java.lang.Class from String \"class java.util.ArrayList\": unable to parse key as Class\n at [Source: ...\n```\n\nAs i understood from #630 the KeyDeserializer for Class should be part of Jackson. Am I missing something?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_10": {
    "description": "JsonAnyGetter doesn't work with JsonSerialize (except with keyUsing)\n(This is happening with 2.5.0. Haven't tried 2.5.1 but I couldn't see any related issue anyway)\n\nJackson ignores JsonSerialize annotation when there is JsonAnyGetter annotation.\n\n``` java\n  @JsonSerialize(using = MySerializer.class)\n  // or\n  @JsonSerialize(converter = MyConverter.class)\n  @JsonAnyGetter\n  public Map<String, String> getParameters(){\n    return parameters;\n  }\n```\n\nexcept \n\n``` Java\n@JsonSerialize(keyUsing = MyKeySerializer.class)\n```\n\n(haven't tried each setting. Only tried keyUsing because I've seen a different issue (#661) with it)\nThen it works. But I need the converter, so..\n\nFor the time being I will use\n\n``` Java\n  @JsonAnyGetter\n  public Map<String, JsonNode> getParameters(){\n    return new MyConverter().convert(parameters);\n  }\n```\n\nbut I'd prefer to stick to annotations.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_11": {
    "description": "Problem resolving locally declared generic type\n(reported by Hal H)\n\nCase like:\n\n``` java\nclass Something {\n    public <T extends Ruleform> T getEntity()\n    public <T extends Ruleform> void setEntity(T entity) \n}\n```\n\nappears to fail on deserialization.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_12": {
    "description": "@JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\nI recently updated from version 2.3.3 to 2.5.1 and encountered a new issue with our custom deserializers. They either seemed to stop working or were active on the wrong fields.\nI could narrow it down to some change in version 2.4.4 (2.4.3 is still working for me)\n\nI wrote a test to show this behavior. It seems to appear when there a two maps with the same key and value types in a bean, and only one of them has a custom deserializer. The deserializer is then falsely used either for both or none of the maps.\n\nThis test works for me in version 2.4.3 and fails with higher versions.\n\n``` java\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport org.junit.Test;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n\npublic class DeserializeTest {\n\n    @Test\n    public void testIt() throws Exception {\n        ObjectMapper om = new ObjectMapper();\n        String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n        TestBean bean = om.readValue(json.getBytes(), TestBean.class);\n\n        assertEquals(100, bean.getMap1().get(\"a\").intValue());\n        assertEquals(1, bean.getMap2().get(\"a\").intValue());\n    }\n\n    public static class TestBean {\n\n        @JsonProperty(\"map1\")\n        @JsonDeserialize(contentUsing = CustomDeserializer.class)\n        Map<String, Integer> map1;\n\n        @JsonProperty(\"map2\")\n        Map<String, Integer> map2;\n\n        public Map<String, Integer> getMap1() {\n            return map1;\n        }\n\n        public void setMap1(Map<String, Integer> map1) {\n            this.map1 = map1;\n        }\n\n        public Map<String, Integer> getMap2() {\n            return map2;\n        }\n\n        public void setMap2(Map<String, Integer> map2) {\n            this.map2 = map2;\n        }\n    }\n\n    public static class CustomDeserializer extends StdDeserializer<Integer> {\n\n        public CustomDeserializer() {\n            super(Integer.class);\n        }\n\n        @Override\n        public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n            Integer value = p.readValueAs(Integer.class);\n            return value * 100;\n        }\n    }\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_13": {
    "description": "Allow deserialization of `null` Object Id\n(note: related to https://github.com/FasterXML/jackson-annotations/issues/56)\n\nFor some use cases (one known case being use from ORM like Hibernate) it makes sense to allow use of `null` (or missing) Object Id, in cases where actual Id will be generated by something other than Jackson. It may also make sense to add matching `DeserializationFeature` which allows such a condition to either be acceptable (default), or not (throw an exception), to allow for strict checks in cases where null/missing Object Id is not a legal use case.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_14": {
    "description": "Custom deserializer with parent object update\nHi, I have custom deserializer for `DataA`. An instance of `DataA` is contained in `DataB`, when updating an existing instance of `DataB` (as opposed to creating a new one) I get an exception when deserializing via a `JsonNode` object (deserializing via a `String` object works). \n\n``` java\nimport java.io.IOException;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.deser.std.StdDeserializer;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\n\npublic class TestDeserTest {\n    static class DataA {\n        public int i = 1;\n        public int j = 2;\n\n    }\n\n    static class DataB {\n        public DataA da = new DataA();\n        public int k = 3;\n    }\n\n    static class DataADeserializer extends StdDeserializer<DataA> {\n        private static final long serialVersionUID = 1L;\n\n        DataADeserializer() {\n            super(DataA.class);\n        }\n\n        public DataA deserialize(JsonParser jp, DeserializationContext ctxt)\n                throws JsonProcessingException, IOException {\n            assert (jp.getCurrentToken() == JsonToken.START_OBJECT);\n            JsonNode node = jp.getCodec().readTree(jp);\n\n            DataA da = new DataA();\n            da.i = 5;\n            return da;\n        }\n    }\n\n    @Test\n    public void test() throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        SimpleModule module = new SimpleModule();\n        module.addDeserializer(DataA.class, new DataADeserializer());\n        mapper.registerModule(module);\n\n        DataB db = new DataB();\n        db.da.i = 11;\n        db.k = 13;\n        String jsonBString = mapper.writeValueAsString(db);\n        JsonNode jsonBNode = mapper.valueToTree(db);\n\n        // create parent\n        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n        Assert.assertEquals(5, dbNewViaString.da.i);\n        Assert.assertEquals(13, dbNewViaString.k);\n\n        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n        Assert.assertEquals(5, dbNewViaNode.da.i);\n        Assert.assertEquals(13, dbNewViaNode.k);\n\n        // update parent\n        DataB dbUpdViaString = new DataB();\n        DataB dbUpdViaNode = new DataB();\n\n        Assert.assertEquals(1, dbUpdViaString.da.i);\n        Assert.assertEquals(3, dbUpdViaString.k);\n        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n        Assert.assertEquals(5, dbUpdViaString.da.i);\n        Assert.assertEquals(13, dbUpdViaString.k);\n\n        Assert.assertEquals(1, dbUpdViaNode.da.i);\n        Assert.assertEquals(3, dbUpdViaNode.k);\n        // FAILS HERE:\n        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);\n        Assert.assertEquals(5, dbUpdViaNode.da.i);\n        Assert.assertEquals(13, dbUpdViaNode.k);\n    }\n}\n```\n\nThe trace:\n\n``` java\ncom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"i\" (class myorg.TestDeserTest$DataB), not marked as ignorable (2 known properties: \"da\", \"k\"])\n at [Source: N/A; line: -1, column: -1] (through reference chain: myorg.DataB[\"da\"]->myorg.DataB[\"i\"])\n    at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:51)\n    at com.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:817)\n    at com.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:954)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1324)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1302)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:249)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:136)\n    at com.fasterxml.jackson.databind.ObjectReader._bindAsTree(ObjectReader.java:1478)\n    at com.fasterxml.jackson.databind.ObjectReader.readTree(ObjectReader.java:1020)\n    at myorg.TestDeserTest$DataADeserializer.deserialize(TestDeserTest.java:39)\n    at myorg.TestDeserTest$DataADeserializer.deserialize(TestDeserTest.java:1)\n    at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:523)\n    at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n    at com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.findDeserializeAndSet(BeanPropertyMap.java:285)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:220)\n    at com.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:1443)\n    at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1154)\n    at myorg.TestDeserTest.test(TestDeserTest.java:81)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_15": {
    "description": "XmlAdapter result marshaling error in case of ValueType=Object \nHi,\n\nI have an error \"com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class java.lang.String and no properties discovered to create BeanSerializer\" in case of using custom XmlAdapter with such declaration:\n\n``` java\npublic static class IntegerListXmlAdapter extends XmlAdapter<Object, List<Integer>> {\n        ...\n        @Override\n        public Object marshal(List<Integer> list) throws Exception {\n            return Joiner.on(\",\").join(list);\n        }\n}\n```\n\nIf change declaration of this class to \"extends XmlAdapter<String, List<Integer>>\" it works good.\n\nFull example:\n\n``` java\npublic class IntegerListXmlAdapterTest {\n    @Test\n    public void testBasic() throws JsonProcessingException {\n        ObjectMapper mapper = (new ObjectMapper()).setAnnotationIntrospector(new JaxbAnnotationIntrospector());\n        SomeIntListHolder listHolder = new SomeIntListHolder();\n        listHolder.setListOne(asList(1, 2, 3));\n        System.out.println(mapper.writeValueAsString(listHolder));\n    }\n\n    public static class IntegerListXmlAdapter extends XmlAdapter<Object, List<Integer>> {\n        @Override\n        public List<Integer> unmarshal(Object value) throws Exception {return null;}\n\n        @Override\n        public Object marshal(List<Integer> list) throws Exception {\n            return Joiner.on(\",\").join(list);\n        }\n    }\n\n    public static class IntegerListToStringXmlAdapter extends XmlAdapter<String, List<Integer>> {\n        public List<Integer> unmarshal(String value) throws Exception {return null;}\n\n        public String marshal(List<Integer> list) throws Exception {\n            return Joiner.on(\",\").join(list);\n        }\n    }\n\n    @XmlRootElement\n    @XmlAccessorType(XmlAccessType.NONE)\n    public static class SomeIntListHolder {\n\n        @XmlAttribute\n        @XmlJavaTypeAdapter(IntegerListXmlAdapter.class)\n        private List<Integer> listOne;\n\n        public List<Integer> getListOne() {\n            return listOne;\n        }\n\n        public void setListOne(List<Integer> listOne) {\n            this.listOne = listOne;\n        }\n    }\n}\n```\n\nIn this state with last Jackson version we will get an error\n\n```\ncom.fasterxml.jackson.databind.JsonMappingException: No serializer found for class java.lang.String and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) ) (through reference chain: SomeIntListHolder[\"listOne\"])\n    at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:59)\n    at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:26)\n    at com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer.serialize(StdDelegatingSerializer.java:157)\n    at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:575)\n    at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:663)\n    at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:156)\n    at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:129)\n    at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3385)\n    at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:2779)\n```\n\nBut if we change XmlJavaTypeAdapter to IntegerListToStringXmlAdapter error will be fixed and code will work fine.\nThis error exists only in Jackson 2, we have this code with Object generic on Jackson 1 and get an issue only during migration to new major version.\n\nThis concrete error can be fixed by hack in com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer:\n\n``` java\n    @Override\n    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n    {\n        Object delegateValue = convertValue(value);\n        // should we accept nulls?\n        if (delegateValue == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n\n        //original code:\n        //_delegateSerializer.serialize(delegateValue, gen, provider);\n\n        JsonSerializer<Object> delegateSerializer;\n        if (_delegateSerializer instanceof UnknownSerializer) {\n            delegateSerializer =  provider.findValueSerializer(delegateValue.getClass());\n        } else {\n            delegateSerializer = _delegateSerializer;\n        }\n\n        delegateSerializer.serialize(delegateValue, gen, provider);\n    }\n```\n\nYou can find test class here: https://github.com/Spikhalskiy/jackson_xmladapter__bug/blob/master/src/test/java/IntegerListXmlAdapterTest.java\n\nand hacked serializer code here: https://github.com/Spikhalskiy/jackson_xmladapter__bug/blob/master/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n\nNow test passing in this repo because of fake StdDelegatingSerializer in classpath - try to delete it to get an issue.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_16": {
    "description": "Annotation bundles ignored when added to Mixin\nWhen updating from v 2.4.4 to 2.5.\\* it appears as though annotation bundles created with `@JacksonAnnotationsInside` are ignored when placed on a mixin.  Moving the annotation bundel to the actual class seems to resolve the issue.  Below is a simple test that attempts to rename a property.  I have more complicated test cases that are also failing but this should provide some context.\n\n``` java\npublic class Fun {\n\n    @Test\n    public void test() throws JsonProcessingException {\n        ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n        String result = mapper.writeValueAsString(new Foo(\"result\"));\n        Assert.assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result);\n    }\n\n    @Target(value={ ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD })\n    @Retention(value=RetentionPolicy.RUNTIME)\n    @JacksonAnnotationsInside\n    @JsonProperty(\"bar\")\n    public @interface ExposeStuff {\n\n    }\n\n    public abstract class FooMixin {\n        @ExposeStuff\n        public abstract String getStuff();\n    }\n\n    public class Foo {\n\n        private String stuff;\n\n        Foo(String stuff) {\n            this.stuff = stuff;\n        }\n\n        public String getStuff() {\n            return stuff;\n        }\n    }\n}\n```\n\nI'm expecting the \"stuff\" property to be serialized as \"bar\".\n\nI apologize I haven't been able to identify the culprit (and perhaps it's in my usage).  Let me know your thoughts. I'm always happy to provide more details!\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_17": {
    "description": "readTree does not work with defaultTyping enabled but no type info provided\nI have enabled `defaultTyping`, and serialized `Foo` entity with no type info. I'm trying to read json as a tree with `mapper.readTree(json)`, and it throws an exception \n\n``` java\nException in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: \nUnexpected token (START_OBJECT), expected START_ARRAY: need JSON Array to contain As.WRAPPER_ARRAY \ntype information for class com.fasterxml.jackson.databind.JsonNode\n at [Source: {\n  \"bar\" : \"bar\"\n}; line: 1, column: 1]\n    at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n    at com.fasterxml.jackson.databind.DeserializationContext.wrongTokenException(DeserializationContext.java:927)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._locateTypeId(AsArrayTypeDeserializer.java:127)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:93)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromAny(AsArrayTypeDeserializer.java:68)\n    at com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer.deserializeWithType(JsonNodeDeserializer.java:144)\n    at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserializeWithType(JsonNodeDeserializer.java:14)\n    at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:42)\n    at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3562)\n    at com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2136)\n    at test.App.main(App.java:23)\n```\n\nHowever, if I disable `defaultTyping`, the same code works fine. So, `readTree(json)` does not actually need type info for the root element, because it works when `defaultTyping` is disabled (i.e. `{\"bar\" : \"bar\"}`), but it throws the exception when `defaultTyping` is enabled, that's why it looks like a bug. The same thing happens for `valueToTree(foo)`. \nJackson version is `2.5.3`\nFull code is provided.\n\n``` java\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.MapperFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport java.io.IOException;\n\npublic class App {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper()\n                .enableDefaultTyping() // works fine with disableDefaultTyping()\n                .enable(MapperFeature.AUTO_DETECT_GETTERS)\n                .enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)\n                .disable(MapperFeature.USE_GETTERS_AS_SETTERS)\n                .disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)\n                .enable(SerializationFeature.INDENT_OUTPUT)\n                .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n\n        Foo foo = new Foo(\"bar\");\n        String serialized = mapper.writeValueAsString(foo); // {\"bar\" : \"bar\"}\n\n        JsonNode jsonNode = mapper.readTree(serialized); // exception here\n        JsonNode node = mapper.valueToTree(foo); // and here\n    }\n\n    public static class Foo {\n        private String bar;\n\n        public Foo() {\n        }\n\n        public Foo(String bar) {\n            this.bar = bar;\n        }\n\n        public String getBar() {\n            return bar;\n        }\n\n        public void setBar(String bar) {\n            this.bar = bar;\n        }\n    }\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_18": {
    "description": "Add basic error-recovery for `ObjectReader.readValues()`\n(follow up for #733)\n\nIn case of `JsonProcessingException`, `MappingIterator` will currently be left pointing right after whatever token was last tokenized (or character following tokenization error). While this is better than indeterminate state, ideally it should try to do some error recover. And although it may not be possible to recover successfully from all kinds of issues, it should be possible to do best effort given that iterator has some knowledge of state when it was opened; that is, it can try to heuristically match closing `END_OBJECT`, depending on nesting level it was created at.\n\nIn addition it may make sense to add a switch to prevent using of any automated heuristics, for those users who want full control over recovery.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_19": {
    "description": "Force value coercion for `java.util.Properties`, so that values are `String`s\nCurrently there is no custom handling for `java.util.Properties`, and although it is possible to use it (since it really is a `Map` under the hood), results are only good if values are already `String`s.\nThe problem here is that `Properties` is actually declared as `Map<String,Object>`, probably due to backwards-compatibility constraints.\n\nBut Jackson should know better: perhaps by `TypeFactory` tweaking parameterizations a bit?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_20": {
    "description": "Presence of PropertyNamingStrategy Makes Deserialization Fail\nI originally came across this issue using Dropwizard - https://github.com/dropwizard/dropwizard/issues/1095.  But it looks like this is a Jackson issue.  Here's the rerproducer:\n\n``` java\npublic class TestPropertyNamingStrategyIssue {\n  public static class ClassWithObjectNodeField {\n    public String id;\n    public ObjectNode json;\n  }\n\n  @Test\n  public void reproducer() throws Exception {\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);\n    ClassWithObjectNodeField deserialized =\n        mapper.readValue(\n            \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\n            ClassWithObjectNodeField.class);\n  }\n}\n```\n\nLooks like the presence of any PropertyNamingStrategy make deserialization to ObjectNode fail.  This works fine if I remove the property naming strategy.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_21": {
    "description": "Specifying `Enum` value serialization using `@JsonProperty`\nCurrently, if I want to deserialize an enum with a value that isn't its `Enum.name()`, I can do either\n\n``` java\npublic enum TestEnum {\n    VALUE_ONE(\"value1\");\n\n    private String valueInJson;\n\n    private TestEnum(String valueInJson) {\n        this.valueInJson = valueInJson;\n    }\n\n    @JsonCreator\n    public static TestEnum getEnumFromValue(String value) {\n        for (TestEnum testEnum : values()) {\n            if (testEnum.valueInJson.equals(value)) {\n                return testEnum;\n            }\n        }\n        throw new IllegalArgumentException();\n    }\n}\n```\n\nor, using `DeserializationFeature.READ_ENUMS_USING_TO_STRING`,\n\n``` java\npublic enum TestEnum {\n    VALUE_ONE(\"value1\");\n\n    private String valueInJson;\n\n    private TestEnum(String valueInJson) {\n        this.valueInJson = valueInJson;\n    }\n\n    @Override\n    public String toString() {\n        return valueInJson;\n    }\n}\n```\n\nThis seems like a lot of boilerplate - is there a simpler way to do this, similar to how `Gson` handles it?\n\n``` java\npublic enum TestEnum {\n    @SerializedName(\"value1\")\n    VALUE_ONE\n}\n```\n\nIt's both more concise and handles both serialization and deserialization.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_22": {
    "description": "Custom serializer not used if POJO has `@JsonValue`\nLooks like serializers constructed for `@JsonValue` have higher precedence than custom serializers; that is, registered custom serializer is not found if POJO type has `@JsonValue` annotation.\nThis is wrong.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_23": {
    "description": "Possible problem with `NON_EMPTY` exclusion, `int`s, `Strings`\n(from https://github.com/FasterXML/jackson-module-afterburner/issues/55)\n\nIt appears like default handling might not work as expected with 2.5.4, whereas Afterburner does seem to handle things better. Need to investigate, and also see if 2.6.0-rc3 works better.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_24": {
    "description": "Configuring an ObjectMapper's DateFormat changes time zone when serialising Joda DateTime\nThe serialisation of Joda `DateTime` instances behaves differently in 2.6.0 vs 2.5.4 when the `ObjectMapper`'s had its `DateFormat` configured. The behaviour change is illustrated by the following code:\n\n``` java\npublic static void main(String[] args) throws JsonProcessingException {\n    System.out.println(createObjectMapper()\n            .writeValueAsString(new DateTime(1988, 6, 25, 20, 30, DateTimeZone.UTC)));\n}\n\nprivate static ObjectMapper createObjectMapper() {\n    ObjectMapper mapper = new ObjectMapper();\n    mapper.registerModule(createJodaModule());\n    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n    System.out.println(mapper.getSerializationConfig().getTimeZone());\n    mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n    System.out.println(mapper.getSerializationConfig().getTimeZone());\n    return mapper;\n}\n\nprivate static SimpleModule createJodaModule() {\n    SimpleModule module = new SimpleModule();\n    module.addSerializer(DateTime.class, new DateTimeSerializer(\n            new JacksonJodaDateFormat(DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\")\n                    .withZoneUTC())));\n        return module;\n    }\n```\n\nWhen run with Jackson 2.5.4 the output is:\n\n```\nsun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]\nsun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]\n\"1988-06-25 20:30:00\"\n```\n\nWhen run with Jackson 2.6.0 the output is:\n\n```\nsun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]\nsun.util.calendar.ZoneInfo[id=\"Europe/London\",offset=0,dstSavings=3600000,useDaylight=true,transitions=242,lastRule=java.util.SimpleTimeZone[id=Europe/London,offset=0,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\n\"1988-06-25 21:30:00\"\n```\n\nIt looks like the fix for #824 is the cause. In 2.6, the call to `mapper.setDateFormat` causes the `ObjectMapper`'s time zone to be set to the JVM's default time zone. In 2.5.x, calling `mapper.setDateFormat` has no effect on its time zone.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_25": {
    "description": "Exception deserializing a byte[] when the target type comes from an annotation\nWhen trying to deserialize a `byte[]` from a `Map` when the deserialization type comes from an annotation, I'm seeing the following exception:\n\n```\njava.lang.IllegalArgumentException: Can not deserialize Class [B (of type array) as a Bean\n        at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:808)\n        at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:138)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n        at com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)\n        at com.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)\n        at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n        at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n        at com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)\n        at com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)\n        at com.fasterxml.jackson.databind.ObjectMapper._convert(ObjectMapper.java:3418)\n        at com.fasterxml.jackson.databind.ObjectMapper.convertValue(ObjectMapper.java:3351)\n```\n\nThe below is a repro.\n\n``` java\npublic class JacksonTest {\n\n    static class Foo {\n        @JsonProperty\n        @JsonDeserialize(as=byte[].class)\n        Object someBytes;\n    }\n\n    public void testFooFromMap() {\n\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"someBytes\", \"HelloWorld\".getBytes());\n\n        ObjectMapper m = new ObjectMapper();\n        m.convertValue(map, Foo.class);\n    }\n}\n```\n\nI discovered this on 2.5.1, but I tried 2.6.0 and it's exhibiting the same behavior.\n\nThanks!\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_26": {
    "description": "Problem serializing `ObjectReader` (and possibly `ObjectMapper`) in 2.6\nLooks like serializability is missing for one of new (2.6) helper classes, `CompactStringObjectMap`, leading to problems with systems like Apache Spark that may need to serialize handlers like `ObjectReader` and/or `ObjectWriter`.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_27": {
    "description": "Problem deserializing External Type Id if type id comes before POJO\n(note: seems to be similar or related to https://github.com/FasterXML/jackson-module-afterburner/issues/58)\n\nWith 2.6, looks like handling of External Type Id is broken in some rare (?) cases; existing unit tests did not catch this. At this point I am speculating this is due to some refactoring, or change to use more efficient 'nextFieldName()' method.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_28": {
    "description": "Deserialization from \"{}\" to ObjectNode field causes \"out of END_OBJECT token\" error\nI found that deserializing from an empty object (`{}`) to ObjectNode field in a class field fails.\n\nHere is the minimum code to reproduce:\n\n``` java\npublic class Main\n{\n    public static class MyValue\n    {\n        private final ObjectNode object;\n\n        @JsonCreator\n        public MyValue(ObjectNode object) { this.object = object; }\n\n        @JsonValue\n        public ObjectNode getObject() { return object; }\n    }\n\n    public static void main(String[] args)\n            throws Exception\n    {\n        ObjectMapper om = new ObjectMapper();\n\n        ObjectNode object = new ObjectNode(JsonNodeFactory.instance);\n\n        String json = om.writeValueAsString(object);\n        System.out.println(\"json: \"+json);\n\n        ObjectNode de1 = om.readValue(json, ObjectNode.class);  // this works\n        System.out.println(\"Deserialized to ObjectNode: \"+de1);\n\n        MyValue de2 = om.readValue(json, MyValue.class);  // but this throws exception\n        System.out.println(\"Deserialized to MyValue: \"+de2);\n    }\n}\n```\n\nResult is:\n\n```\njson: {}\nDeserialized to ObjectNode: {}\nException in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token\n at [Source: {}; line: 1, column: 2]\n        at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n        at com.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:854)\n        at com.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:850)\n        at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer.deserialize(JsonNodeDeserializer.java:104)\n        at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer.deserialize(JsonNodeDeserializer.java:83)\n        at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1095)\n        at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:294)\n        at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:131)\n        at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3731)\n        at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2724)\n        at Main.main(Main.java:35)\n```\n\nIf the object is not empty (e.g. `{\"k\":\"v\"}`), it works:\n\n``` java\n        ...\n        ObjectNode object = new ObjectNode(JsonNodeFactory.instance);\n        object.put(\"k\", \"v\");  // added\n        ...\n```\n\n```\njson: {\"k\":\"v\"}\nDeserialized to ObjectNode: {\"k\":\"v\"}\nDeserialized to MyValue: io.digdag.cli.Main$MyValue@17550481\n```\n\nEnvironment:\n- jackson-core 2.6.2\n- jackson-databind 2.6.2\n- Java 8 (`Java(TM) SE Runtime Environment (build 1.8.0_20-b26)`)\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_29": {
    "description": "Handle null type id for polymorphic values that use external type id\nRemove exceptions thrown when polymorphic value is null.\nIf there is a need to force non-null value, this could be provided as an extra property in @JsonTypeInfo, or perhaps use an existing property such as JsonProperty.required.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_30": {
    "description": "BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded\nWhen using an `ObjectMapper` to serialize/deserialize a class with an `Object` field annotated with a `@JsonSubTypes.Type` that indicate `BigDecimal`, it looks like the value is getting rounded to a double.\n\nI tried configuring `DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS`, but that didn't seem to help.\n\nWhat I think is a valid repro is below, but let me know if I'm actually doing something wrong here.\n\nThanks!\n\n``` java\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport java.math.BigDecimal;\n\nimport com.fasterxml.jackson.annotation.*;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class JacksonTest {\n\n    enum Type { BIG_DECIMAL }\n\n    static class Wrapper {\n\n        @JsonIgnore\n        Type typeEnum;\n\n        @JsonIgnore\n        Object value;\n\n        Wrapper() { }\n\n        @JsonGetter(value = \"type\")\n        String getTypeString() {\n            return typeEnum.name();\n        }\n\n        @JsonSetter(value = \"type\")\n        void setTypeString(String type) {\n            this.typeEnum = Type.valueOf(type);\n        }\n\n        @JsonGetter(value = \"objectValue\") \n        Object getValue() {\n            return value;\n        }\n\n        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXTERNAL_PROPERTY, property = \"type\")\n        @JsonSubTypes({ @JsonSubTypes.Type(name = \"BIG_DECIMAL\", value = BigDecimal.class) })\n        @JsonSetter(value = \"objectValue\") \n        private void setValue(Object value) {\n            this.value = value;\n        }\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        ObjectMapper m = new ObjectMapper();\n        m.configure(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS, true);\n\n        Wrapper w = new Wrapper();\n        w.typeEnum = Type.BIG_DECIMAL;\n        w.value = new BigDecimal(\"-10000000000.0000000001\");\n\n        String json = m.writeValueAsString(w);\n        Wrapper w2 = m.readValue(json, Wrapper.class);\n\n        Assert.assertEquals(w.typeEnum, w2.typeEnum);\n        Assert.assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n            w.value.equals(w2.value));\n    }\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_31": {
    "description": "JsonStreamContexts are not build the same way for write.. and convert methods\nHI\nI got an issue reported in my jackson-antpathfilter project that the filtering is not working correctly when it is used together with Jackson's convert feature: https://github.com/Antibrumm/jackson-antpathfilter/issues/2\n\nDuring the investigation i found out that the cause is that the writeContext is created differently and I am wondering if this is the desired behavior or if that's a bug for you.\n\nIn this comment (https://github.com/Antibrumm/jackson-antpathfilter/issues/2#issuecomment-145211847) I print out what is found in the writeContext and I have created a TestCase to reproduce the error. \n\nPlease let me know what you think.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_32": {
    "description": "Deserialization from \"{}\" to java.lang.Object causes \"out of END_OBJECT token\" error\nHi, I've faced with a problem that is too similar this one #941. I expect that \"{}\" will be parsed correctly to empty Map when I'm using `@JsonCreator`\n\nI've found that this case is invalid https://github.com/FasterXML/jackson-databind/blob/jackson-databind-2.6.3/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java#L272, but why?\n\nHere is the minimum code to reproduce:\n\n```\nimport java.io.IOException;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.readValue(\"[]\", SomeObjectThatCanBeAggregated.class);\n        mapper.readValue(\"[{}]\", SomeObjectThatCanBeAggregated.class);\n        mapper.readValue(\"{\\\"key\\\":null}\", SomeObjectThatCanBeAggregated.class);\n        mapper.readValue(\"{}\", SomeObjectThatCanBeAggregated.class);\n    }\n}\nclass SomeObjectThatCanBeAggregated {\n\n    @JsonCreator\n    public SomeObjectThatCanBeAggregated(Object obj) {\n        System.out.println(obj + \" //\" + obj.getClass());\n    }\n}\n```\n\nOutput: \n\n```\n[] //class java.util.ArrayList\n[{}] //class java.util.ArrayList\n{key=null} //class java.util.LinkedHashMap\nException in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of java.lang.Object out of END_OBJECT token\n at [Source: {}; line: 1, column: 2]\n...\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_33": {
    "description": "@JsonUnwrapped is not treated as assuming @JsonProperty(\"\")\nSee discussion [here](https://groups.google.com/forum/#!topic/jackson-user/QLpWb8YzIoE) but basically `@JsonUnwrapped` on a private field by itself does not cause that field to be serialized, currently,  You need to add an explicit `@JsonProperty`.  You shouldn't have to do that.  (Following test fails currently, should pass, though you can make it pass by commenting out the line with `@JsonProperty`.  Uses TestNG and AssertJ.)\n\n``` java\npackage com.bakins_bits;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.testng.annotations.Test;\n\nimport com.fasterxml.jackson.annotation.JsonUnwrapped;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class TestJsonUnwrappedShouldMakePrivateFieldsSerializable\n{\n    public static class Inner\n    {\n        public String animal;\n    }\n\n    public static class Outer\n    {\n        // @JsonProperty\n        @JsonUnwrapped\n        private Inner inner;\n    }\n\n    @Test\n    public void jsonUnwrapped_should_make_private_fields_serializable() throws JsonProcessingException {\n        // ARRANGE\n        Inner inner = new Inner();\n        inner.animal = \"Zebra\";\n\n        Outer outer = new Outer();\n        outer.inner = inner;\n\n        ObjectMapper sut = new ObjectMapper();\n\n        // ACT\n        String actual = sut.writeValueAsString(outer);\n\n        // ASSERT\n        assertThat(actual).contains(\"animal\");\n        assertThat(actual).contains(\"Zebra\");\n        assertThat(actual).doesNotContain(\"inner\");\n    }\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_34": {
    "description": "Regression in 2.7.0-rc2, for schema/introspection for `BigDecimal`\n(found via Avro module, but surprisingly json schema module has not test to catch it)\n\nLooks like schema type for `BigDecimal` is not correctly produced, due to an error in refactoring (made to simplify introspection for simple serializers): it is seen as `BigInteger` (and for Avro, for example, results in `long` getting written).\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_35": {
    "description": "Problem with Object Id and Type Id as Wrapper Object (regression in 2.5.1)\n(note: originally from https://github.com/FasterXML/jackson-module-jaxb-annotations/issues/51)\n\nLooks like fix for #669 caused a regression for the special use case of combining type and object ids, with wrapper-object type id inclusion. The problem started with 2.5.1.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_36": {
    "description": "Allow use\tof `StdDateFormat.setLenient()`\nObjectMapper uses the StdDateFormat for date serialization. Jackson date parsing is lenient by default, so 2015-01-32 gets parsed as 2015-02-01.  Jackson\u2019s StdDateParser is matching default behavior of DateParser.  \n\nStdDateParser wasn\u2019t really designed for extension to just enable strict date parsing.  If it were, we could just call objectMapper.setDateFormat(new StdDateFormat().setLenient(false)). But StdDateFomrat doesn't support setting lenient to false. And i.e. the reason date like 2015-01-32 gets parsed as 2015-02-01 ad Jackson date parsing is lenient by defualt.\n\nCan StdDateFormat can be enhanced to support to non lenient date parsing?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_37": {
    "description": "Field in base class is not recognized, when using `@JsonType.defaultImpl`\nWhen deserializing JSON to Java POJOS, a field inherited from a base class is not recognized. Here is the stack:\n\n```\ncom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"name\" (class org.apache.calcite.model.JsonMapSchema), not marked as ignorable (2 known properties: \"functions\", \"tables\"])\n at [Source: {\n  version: '1.0',\n   schemas: [\n     {\n       name: 'FoodMart',\n       tables: [\n         {\n           name: 'time_by_day',\n           columns: [\n             {\n               name: 'time_id'\n             }\n           ]\n         },\n         {\n           name: 'sales_fact_1997',\n           columns: [\n             {\n               name: 'time_id'\n             }\n           ]\n         }\n       ]\n     }\n   ]\n}; line: 24, column: 7] (through reference chain: org.apache.calcite.model.JsonRoot[\"schemas\"]->java.util.ArrayList[0]->org.apache.calcite.model.JsonMapSchema[\"name\"])\n\n    at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:62)\n    at com.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:855)\n    at com.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:1083)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1389)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1367)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:266)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:163)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:136)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:99)\n    at com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserializeWithType(AbstractDeserializer.java:142)\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:279)\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:249)\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n    at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:490)\n    at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:260)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:125)\n    at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3788)\n    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)\n    at org.apache.calcite.test.ModelTest.testRead(ModelTest.java:58)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n```\n\nMy `JsonMapSchema` class has a base class `JsonSchema` and it has a public field `name`. See https://github.com/apache/calcite/blob/master/core/src/test/java/org/apache/calcite/test/ModelTest.java.\n\nI have an application that worked in 2.6.3, fails in 2.7.0, so I suspect this is a regression. \n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_38": {
    "description": "(2.7-regress) Handling of deprecated `SimpleType.construct()` too minimalistic\n(note: spun from https://github.com/FasterXML/jackson/issues/48)\n\nDue to changes in type resolution, most direct construction methods in `JavaType` sub-classes can not be fully supported. Failure modes are typically with complex cases (and expected to be rare), with one exception: use of `SimpleType.construct(Class)`, because:\n1. This is mostly used for complex types, and not just \"well-known\" interfaces like `List`, `Map`; so actual access to at least immediate fields is necessary (and similarly lack of super-type info is problematic), and\n2. Its usage is likely to be wide-spread, despite existence of preferable methods (`TypeFactory`)\n3. Since refactoring of type resolution was not anticipated early enough in advance, deprecation of methods we want to move users away from could not be done in 2.6, as it should have been (in perfect case)\n\nExact reasoning behind problems is quite complicated: but the fundamental reason is that `TypeFactory` has all the logic to do the generic resolution; `JavaType` has (and should have) very little if any. Since no reference to the factory is passed via constructors/factory methods, they can not properly delegate resolution tasks. This is why direct calls should only be made with all necessary, pre-resolved information; passing `JavaType`s for elements, not `Class`.\nInability to resolve things means that super-types can not be properly resolved, for example. Handling of fields, methods will also be inexact wrt generic types.\n\nThe first immediate problem is something that should be addressable: introspection by POJO deserializer builder does not find any fields or methods. It should be possible to at least find them, even if type resolution for generic types will not work well. This should be acceptable for the common (and reported) case of constructing element types for `Collection`s and `Map`s: generic parameterization will not be accessible anyway.\n\nThere are other potential issues to address as best we can, but first things first.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_39": {
    "description": "Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error\nAfter FAIL_ON_INVALID_SUBTYPE error, jackson should continue to parse, but seems jackson doesn't.\n\nThe output:\n\n```\nCallRecord [version=0.0, application=123, ] // doesn't read item2 which is valid\nCallRecord [version=0.0, application=123, ]\nCallRecord [version=0.0, ] // doesn't read application after invalid item.\n```\n\n``` jaca\n@JsonInclude(Include.NON_NULL)\npublic class CallRecord {\n    public float version;\n    public String application;\n    public Item item;\n    public Item item2;\n    public CallRecord() {}\n\n    public static void main(final String[] args) throws IOException {\n        final ObjectMapper objectMapper = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES);\n        final CallRecord call = new CallRecord();\n\n        final Event event = new Event();\n        event.location = \"location1\";\n        call.item = event;\n        call.item2 = event;\n        call.application = \"123\";\n        // System.out.println(objectMapper.writeValueAsString(call));\n        String json =\n                \"{\\\"version\\\":0.0,\\\"application\\\":\\\"123\\\",\\\"item\\\":{\\\"type\\\":\\\"xevent\\\",\\\"location\\\":\\\"location1\\\"},\\\"item2\\\":{\\\"type\\\":\\\"event\\\",\\\"location\\\":\\\"location1\\\"}}\";\n        // can't read item2 - which is valid\n        System.out.println(objectMapper.readValue(json, CallRecord.class));\n\n        json = \"{\\\"version\\\":0.0,\\\"application\\\":\\\"123\\\"},{\\\"item\\\":{\\\"type\\\":\\\"xevent\\\",\\\"location\\\":\\\"location1\\\"}\";\n        System.out.println(objectMapper.readValue(json, CallRecord.class));\n\n        json = \"{\\\"item\\\":{\\\"type\\\":\\\"xevent\\\",\\\"location\\\":\\\"location1\\\"}, \\\"version\\\":0.0,\\\"application\\\":\\\"123\\\"}\";\n        // order matters: move item to the fornt, now it can't read application property\n        System.out.println(objectMapper.readValue(json, CallRecord.class));\n    }\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append(\"CallRecord [version=\").append(version).append(\", \");\n        if (application != null) {\n            builder.append(\"application=\").append(application).append(\", \");\n        }\n        if (item != null) {\n            builder.append(\"item=\").append(item);\n        }\n        builder.append(\"]\");\n        return builder.toString();\n    }\n}\n\n@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = \"type\", visible = true)\n@JsonSubTypes({@Type(value = Event.class, name = Event.TYPE)})\npublic interface Item {\n}\n\npublic final class Event implements Item {\n    public String location;\n    public static final String TYPE = \"event\";\n    public Event() {}\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_40": {
    "description": "Prevent coercion of `int` from empty String to `null` if `DeserializationFeature .FAIL_ON_NULL_FOR_PRIMITIVES` is `true`\nI got 0 from the code below.\n\n``` java\nint i = mapper.readValue(\"\\\"\\\"\", int.class);\nSystem.out.println(i);\n```\n\nIt seems that Json Number type cannot start with \".\nCould I make the code throw some Exceptions?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_41": {
    "description": "Problems with deprecated `TypeFactory.constructType(type, ctxt)` methods if `ctxt` is `null`\n(note: continuation of #1079)\n\nLooks like earlier fix was incomplete, and there is one more edge case to handle: if passed-in context is `null`, attempt to resolve that will fail. This should not occur since previously passing of `null` would simply have used \"empty\" bindings. Code needs to take care to handle this as version 2.6 did.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_42": {
    "description": "Serializing and Deserializing Locale.ROOT\nSerializing and Deserializing Locale objects seems to work just fine, until you try on the Root Locale.\nIt writes it out as an empty string and when it reads it in, the value is null\n\n```\n@Test\n    public void testLocaleDeserialization() throws IOException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        Locale root = Locale.ROOT;\n        String json = objectMapper.writeValueAsString(root);\n        System.out.printf(\"Root Locale: '%s'\", json);\n        Locale actual = objectMapper.readValue(json, Locale.class);\n        Assert.assertEquals(root, actual);\n    }\n```\n\nHere is the output:\nRoot Locale: '\"\"'\njava.lang.AssertionError: \nExpected :\nActual   :null\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_43": {
    "description": "Problem with Object id handling, explicit `null` token\nAccording to #742, it shouldn't throw an exception if the value of the property is null\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_44": {
    "description": "Problem with polymorphic types, losing properties from base type(s)\n(background, see: https://github.com/dropwizard/dropwizard/pull/1449)\n\nLooks like sub-type resolution may be broken for one particular case: that of using `defaultImpl`. If so, appears like properties from super-types are not properly resolved; guessing this could be follow-up item for #1083 (even sooner than I thought...).\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_45": {
    "description": "Fix for #1154\nFix for #1154. Partially rolls back to pre-#1111 behavior.\nWe just make sure that the STRING shape is chosen when Shape.ANY (the default) is set on the annotation, but some other annotation attribute was also set (pattern, locale or timezone).\nThis way of fixing the issue has the added benefit of respecting the user config regarding the default serialization of ~~strings~~ dates when @JsonFormat(shape = Shape.ANY) is set on a property.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_46": {
    "description": "Incorrect signature for generic type via `JavaType.getGenericSignature\n(see https://github.com/FasterXML/jackson-modules-base/issues/8 for background)\n\nIt looks like generic signature generation is missing one closing `>` character to produce:\n\n```\n()Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;;\n```\n\ninstead of expected\n\n```\n()Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\n```\n\nthat is, closing '>' is missing.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_47": {
    "description": "`@JsonSerialize(as=superType)` behavior disallowed in 2.7.4\n#1178 fixed the problem with collections, but I'm seeing a problem with individual objects.\n\nI'm getting:\n\n```\ncom.fasterxml.jackson.databind.JsonMappingException: Failed to widen type [simple type, class org.pharmgkb.model.AccessionIdentifier] with annotation (value org.pharmgkb.model.BaseAccessionIdentifier), from 'getReference': Class org.pharmgkb.model.BaseAccessionIdentifier not a super-type of [simple type, class org.pharmgkb.model.AccessionIdentifier]\n\n    at com.fasterxml.jackson.databind.AnnotationIntrospector.refineSerializationType(AnnotationIntrospector.java:821)\n    at com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair.refineSerializationType(AnnotationIntrospectorPair.java:488)\n    at com.fasterxml.jackson.databind.ser.PropertyBuilder.findSerializationType(PropertyBuilder.java:194)\n    at com.fasterxml.jackson.databind.ser.PropertyBuilder.buildWriter(PropertyBuilder.java:73)\n    at com.fasterxml.jackson.databind.ser.BeanSerializerFactory._constructWriter(BeanSerializerFactory.java:805)\n    at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.findBeanProperties(BeanSerializerFactory.java:608)\n    at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.constructBeanSerializer(BeanSerializerFactory.java:388)\n    at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.findBeanSerializer(BeanSerializerFactory.java:271)\n    at com.fasterxml.jackson.databind.ser.BeanSerializerFactory._createSerializer2(BeanSerializerFactory.java:223)\n    at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.createSerializer(BeanSerializerFactory.java:157)\n    at com.fasterxml.jackson.databind.SerializerProvider._createUntypedSerializer(SerializerProvider.java:1215)\n    at com.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer(SerializerProvider.java:1167)\n    at com.fasterxml.jackson.databind.SerializerProvider.findValueSerializer(SerializerProvider.java:490)\n    at com.fasterxml.jackson.databind.SerializerProvider.findTypedValueSerializer(SerializerProvider.java:688)\n    at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:107)\n    at com.fasterxml.jackson.databind.ObjectWriter$Prefetch.serialize(ObjectWriter.java:1428)\n    at com.fasterxml.jackson.databind.ObjectWriter._configAndWriteValue(ObjectWriter.java:1129)\n    at com.fasterxml.jackson.databind.ObjectWriter.writeValueAsString(ObjectWriter.java:1001)\n    at org.pharmgkb.jackson.JacksonTest.testModelObjects(JacksonTest.java:48)\n```\n\nOn something like:\n\n```\npublic class Foo {\n  @JsonSerialize(as = BaseAccessionIdentifier.class)\n  @JsonDeserialize(as = BaseAccessionIdentifier.class)\n  public AccessionIdentifier getReference() {\n  }\n}\n```\n\n```\npublic interface AccessionIdentifier {\n}\n```\n\n```\npublic class BaseAccessionIdentifier implements AccessionIdentifier {\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_48": {
    "description": "`BasicClassIntrospector.forSerialization(...).findProperties` should respect MapperFeature.AUTO_DETECT_GETTERS/SETTERS\nWhen I set the ObjectMapper MapperConfig to not AutoDetect and use the BasicClassIntrospector to get the properties, I seem to still be getting the Methods.  I am currently using version 2.7.3.\n\nThe following code produces this output:\n        Found property count 2, there should only be one??\n        Found property: name=name, internalName=name\n        Found property: name=groupname, internalName=groupname\n\nI think it should produce only this output:\n        Found property: name=groupname, internalName=groupname\n\n```\npublic static void main(String [] args) {\n    class TCls {\n        @JsonProperty(\"groupname\")\n        private String groupname;\n\n        public void setName(String str) {\n            this.groupname = str;\n        }\n        public String getName() {\n            return groupname;\n        }\n    }\n\n    ObjectMapper om = new ObjectMapper();\n    // Only use explicitly specified values to be serialized/deserialized (i.e., JSONProperty).\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_FIELDS, false);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_GETTERS, false);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_SETTERS, false);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.USE_GETTERS_AS_SETTERS, false);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, true);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.INFER_PROPERTY_MUTATORS, false);\n    om.configure(com.fasterxml.jackson.databind.MapperFeature.USE_ANNOTATIONS, true);\n\n    JavaType javaType = om.getTypeFactory().constructType(TCls.class);\n\n    BasicClassIntrospector introspector = new BasicClassIntrospector();\n    BasicBeanDescription bdesc = introspector.forSerialization(om.getSerializationConfig(), javaType, null);\n    List<BeanPropertyDefinition> bprops = bdesc.findProperties();\n\n    if (1 != bprops.size()) {\n        System.out.println(\"Found property count \" + bprops.size() + \", there should only be one??\");\n    }\n    bprops.forEach(prop -> {\n        System.out.println(\"Found property: name=\" + prop.getName() + \", internalName=\" + prop.getInternalName());\n    });\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_49": {
    "description": "JsonIdentityInfo incorrectly serializing forward references\nI wrote this small test program to demonstrate the issue:\n\n``` java\nimport com.fasterxml.jackson.annotation.JsonIdentityInfo;\nimport com.fasterxml.jackson.annotation.JsonIdentityReference;\nimport com.fasterxml.jackson.annotation.ObjectIdGenerators;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class ObjectIdTest {\n\n    public static class Foo {\n\n        @JsonIdentityReference(alwaysAsId = true)\n        public Bar bar1;\n\n        @JsonIdentityReference()\n        public Bar bar2;\n    }\n\n    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n    public static class Bar {\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n\n        // create structure to serialize\n        Foo mo = new Foo();\n        mo.bar1 = new Bar();\n        mo.bar2 = mo.bar1;\n\n        // serialize it\n        System.out.println(mapper.writeValueAsString(mo));\n    }\n\n}\n```\n\nWhen executing this test program in the latest version (2.7.4), the output will be `{\"bar1\":1,\"bar2\":{\"@id\":2}}` - the second field will be written with a new id even though both fields reference the same object. Because of this, writing forward references is essentially impossible.\n\nThe issue seems to be the fact that BeanSerializerBase will always call WritableObjectId.generateId if the referenced object has not been written in plain format yet (https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java#L600). This will also happen if an id has been generated before.\nIt might also be smarter to only generate a new id in WritableObjectId.generateId if that hasn't happened before; as that method doesn't have a javadoc I can't tell how it is supposed to work.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_50": {
    "description": "`@JsonIdentityInfo` deserialization fails with combination of forward references, `@JsonCreator`\nAs a follow-up to bug #1255, the patch I provided exposes related deserialization problems.\nI have attached a small project ('jackson-test.zip') to demonstrate these issues. When run with both patches from #1255, the output is provided in the attached 'both.txt'. When run with just the first patch from #1255, the output is provided in the attached 'first.txt'.\nImportant points:\n1. When the object expressed as an id is contained within a collection or map (List in this example), deserialization works correctly. When it is a field of an object, deserialization is broken.\n2. This particular example doesn't have forward references, but it does have cycles. Nevertheless, I have seen situations where non-cyclical forward-references also do not deserialize properly, with the same caveat as in 1.\n[jackson-test.zip](https://github.com/FasterXML/jackson-databind/files/301884/jackson-test.zip)\n[both.txt](https://github.com/FasterXML/jackson-databind/files/301885/both.txt)\n[first.txt](https://github.com/FasterXML/jackson-databind/files/301886/first.txt)\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_51": {
    "description": "Generic type returned from type id resolver seems to be ignored\nhttps://github.com/benson-basis/jackson-custom-mess-tc\n\nHere's the situation, with Jackson 2.7.4.\n\nI have a TypeIdResolver that returns a JavaType for a generic type. However, something seems to be forgetting/erasing the generic, as it is failing to use the generic type param to understand the type of a field in the class.\n\nAll the information is in the test case, so I'm not putting any code to read here in the issue.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_52": {
    "description": "External property is not deserialized\nI think it's easier to show the code than explain the issue, so i prepared a test project:\nhttps://github.com/crew4ok/jackson-databind-test\n\nSo basically the issue is that the external property, by which another's property type is deduced, after deserialization is null.\nSee the failing test:\nhttps://github.com/crew4ok/jackson-databind-test/blob/master/src/test/java/jackson/ExternalIdDeserTest.java\n\nAm i missing something?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_53": {
    "description": "Problem with type specialization for Maps with `@JsonDeserialize(as=subtype)`\nIf I have json that looks like\n\n```\n{\n  \"something\": [\n        {\n           \"id\": \"a uuid\",\n           \"property\": \"value\"\n         }\n  ]\n}\n```\n\nAnd I have a java pojo with an annotation like this:\n\n```\n    @JsonDeserialize(as = MyHashMap.class)\n    private void setSomething(Map<UUID, Foo> incomingValue) {\n```\n\nWhere MyHashMap.java has some custom logic using generics that allow us to map the array json above into a Map where \"id\" is the key and everything else serializes into the value.  We use generics on MyHashMap to enforce that every value implements a certain interface that respects the contract of returning an \"id\" property.  In this example Foo.java implements this interface MyCustomIdInterface.java.\n\nWhen using 2.6.6 this worked fine, but if I switch to 2.7.x then it breaks with the error:\n\n`Can not construct instance of MyCustomIdInterface, problem: abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information`\n\nin 2.7.x, it looks like jackson resolves to using AbstractDeserializer based on MyCustomIdInterface but in 2.6.6 it resolves to using BeanDeserializer based on Foo.java.\n\nIs this a bug or is there some default/feature flag that changed here?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_54": {
    "description": "`Optional.empty()` not excluded if property declared with type `Object`\nJackson version is 2.6.6\n**Here is the code:**\n\n```\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n        mapper.registerModule(new Jdk8Module());\n\n        JsonResult result = new JsonResult();\n        result.setA(Optional.empty());\n        result.setB(Optional.empty());\n        System.out.println(mapper.writeValueAsString(result));\n```\n\n```\n@Data\npublic class JsonResult {\n    private Object a;\n    private Optional<Object> b;\n}\n```\n\n**Then I got the output: {\"a\":null}**\n\n**The real value of both is the same, why the results are different?**\n\n**How can I avoid null in such case?**\n\nBy the way, I tried 'NON_EMPTY'. It can work, but it also ignores zero and empty array. I want to keep them.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_55": {
    "description": "EnumMap keys not using enum's `@JsonProperty` values unlike Enum values\nBased on these issues:\nhttps://github.com/FasterXML/jackson-databind/issues/677\nhttps://github.com/FasterXML/jackson-databind/issues/1148\nhttps://github.com/FasterXML/jackson-annotations/issues/96\n\nI implemented @JsonProperty for my enum constants and they show up nicely when they are property values. But I also have an EnumMap which uses the enum, and it's generated JSON uses the original enum names for the keys and not the JsonProperty values.\n\nUsing 2.8.1 (in spring boot 4.3.2)\n\nThanks!\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_56": {
    "description": "Deserializing locale assumes JDK separator (underscore), does not accept RFC specified (hyphen)\nWhen deserializing a locale Jackson currently uses the underscore character as the separator rather than the dash.  Specifically, in FromStringDeserializer.java line 234:\n\n```\nint ix = value.indexOf('_');\n```\n\nMany locale implementations use dash as the separator as per https://tools.ietf.org/html/rfc5646\n\nGiven the RFC states that only the characters a-z A-Z and - are valid it should be possible to leave the current code in for backward-compatibility but it should also check for  '-' as a separator.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_57": {
    "description": "`ObjectReader.readValues()` ignores offset and length when reading an array\nObjectReader.readValues ignores offset and length when reading an array. If _dataFormatReaders it will always use the full array:\n\nhttps://github.com/FasterXML/jackson-databind/blob/2.7/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java#L1435\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_58": {
    "description": "`@JsonIgnoreProperties`: ignoring the \"cause\" property of `Throwable` on GAE\nDeserializing an exception class from json on Google App Engine causes this error:\n\n```\nCaused by: java.lang.IllegalArgumentException: Can not access private java.lang.Throwable java.lang.Throwable.cause (from class java.lang.Throwable; failed to set access: java.lang.IllegalAccessException: Reflection is not allowed on private java.lang.Throwable java.lang.Throwable.cause\n    at com.fasterxml.jackson.databind.util.ClassUtil.checkAndFixAccess(ClassUtil.java:505)\n    at com.fasterxml.jackson.databind.introspect.AnnotatedMember.fixAccess(AnnotatedMember.java:123)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.constructSettableProperty(BeanDeserializerFactory.java:704)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps(BeanDeserializerFactory.java:501)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildThrowableDeserializer(BeanDeserializerFactory.java:356)\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:114)\n```\n\nI tried preventing this by using `@JsonIgnoreProperties`:\n\n``` java\n@JsonIgnoreProperties(\"cause\")\npublic class MyException extends RuntimeException { ... }\n```\n\n... but the same error still occurs. What am I doing wrong? What else could I do?\n\nI've also considered setting `MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS` to false, but I don't like this solution because I need this setting to be `true` in some other cases (in particular, I provide no-arg constructors for Jackson, but they should't be public in my API).\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_59": {
    "description": "@JsonDeserialize(keyUsing = ...) does not work correctly together with DefaultTyping.NON_FINAL\nVersion 2.8.3 seems to ignore @JsonDeserialize(keyUsing = ...) when used together with DefaultTyping.NON_FINAL setting and Map<,> argument type in constructor with concrete type (e.g. HashMap<,>) specified in JSON.\n\nIn the code below testFails() fails and testSucceeds() passes fine. The only difference is testSucceeds() has a module with deserializer registered explicitly. Both tests pass on version 2.6.\n\n``` java\npackage com.test.testjackson.testjackson;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.KeyDeserializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\nimport com.fasterxml.jackson.databind.module.SimpleKeyDeserializers;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\nimport java.util.Map;\nimport org.junit.Test;\n\nimport static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.ANY;\nimport static junit.framework.Assert.assertEquals;\n\npublic class TestJackson \n{\n    private static String TEST_INSTANCE_SERIALIZED = \"{\\\"mapProperty\\\":[\\\"java.util.HashMap\\\",{\\\"Compound|Key\\\":\\\"Value\\\"}]}\";\n\n    @Test\n    public void testFails() throws JsonParseException, JsonMappingException, IOException\n    {\n        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(DefaultTyping.NON_FINAL);\n        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);\n        String testInstanceSerialized = mapper.writeValueAsString(testInstance);\n        assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);\n    }\n\n    @Test\n    public void testSucceeds() throws JsonParseException, JsonMappingException, IOException\n    {\n        ObjectMapper mapper = new ObjectMapper().enableDefaultTyping(DefaultTyping.NON_FINAL).registerModule(new SimpleModule() {\n            private static final long serialVersionUID = 1L;\n            @Override\n            public void setupModule(SetupContext context) {\n                context.addKeyDeserializers(new SimpleKeyDeserializers().addDeserializer(CompoundKey.class, new CompoundKeyDeserializer()));\n            }\n        });\n        TestClass testInstance = mapper.readValue(TEST_INSTANCE_SERIALIZED, TestClass.class);\n        String testInstanceSerialized = mapper.writeValueAsString(testInstance);\n        assertEquals(TEST_INSTANCE_SERIALIZED, testInstanceSerialized);\n    }\n\n    @JsonAutoDetect(fieldVisibility = ANY)\n    public static final class TestClass {\n        @JsonProperty(\"mapProperty\")\n        @JsonSerialize(keyUsing = CompoundKeySerializer.class)\n        private final Map<CompoundKey, String> mapProperty;\n\n        @JsonCreator\n        private TestClass(@JsonDeserialize(keyUsing = CompoundKeyDeserializer.class) @JsonProperty(\"mapProperty\") Map<CompoundKey, String> mapProperty) {\n            this.mapProperty = mapProperty;\n        }\n    }\n\n    public static final class CompoundKey {\n        private String part0;\n        private String part1;\n\n        public CompoundKey(String part0, String part1) {\n            this.part0 = part0;\n            this.part1 = part1;\n        }\n\n        public String getPart0() { return part0; }\n        public String getPart1() { return part1; }\n    }\n\n    public static class CompoundKeyDeserializer extends KeyDeserializer {\n        @Override\n        public Object deserializeKey(String s, DeserializationContext deserializationContext) {\n            String[] parts = s.split(\"\\\\|\");\n            return new CompoundKey(parts[0], parts[1]);\n        }\n    }\n\n    public static class CompoundKeySerializer extends JsonSerializer<CompoundKey> {\n        @Override\n        public void serialize(CompoundKey compoundKey, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n            jsonGenerator.writeFieldName(compoundKey.getPart0() + '|' + compoundKey.getPart1());\n        }\n    }\n}\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_60": {
    "description": "Polymorphic type lost when using `@JsonValue`\nWhen suppressing all getters but one with @JsonIgnore and choosing to use a byte array for serialization (marking its getter with @JsonValue), the typing of the object is changed to \"[B\", which is deserialized to a byte array. I would have expected verbose typing and usage of the constructor  marked with @JsonCreator that accepts the byte array to construct the object on deserialization. The behavior is as expected when choosing more fields for serialization, which is redundant data in this case.\n\nRunning  jackson-databind 2.7.4 on Java 1.8.0_91.\n\nConfiguration of the ObjectMapper:\n\n```\nprivate final ObjectMapper mapper;\npublic JsonFilter() {\n    this.mapper = new ObjectMapper();\n    mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n    mapper.enableDefaultTyping();\n}\n```\n\nSerialization: `mapper.writeValueAsString(message)`\nDeserialization: `mapper.readValue(json, RemoteCall.class)`\n\nGetter and field:\n\n```\n/** @serial */\nprivate byte[] apdu;\n\n@JsonValue\npublic byte[] getBytes() {\n    return apdu.clone();\n}\n```\n\nConstructor:\n\n```\n@JsonCreator\npublic CommandAPDU(@JsonProperty(value = \"bytes\") byte[] apdu) {\n    this.apdu = apdu.clone();\n    parse();\n    LOG.v(\"com.ubitricity.devices.common.pal.CommandAPDU creator (1)\");\n}\n```\n\nSerializes to `\"args\":[[\"[B\",\"AKQEAAnw8fLz9AAAAgA=\"],[\"net.sf.lipermi.call.RemoteInstance\",{\"instanceId\":\"b0e15098-f49e-4328-b072-fc5df42799bd\",\"className\":\"com.ubitricity.devices.common.tasks.ResponseReceiver\"}]]` where \"args\" is an Object array field of the enclosing object.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_61": {
    "description": "Problems deserializing primitive `long` field while using `TypeResolverBuilder`\nWhen running the following test app\n\n``` java\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        // Create test data\n        Data data = new Data();\n        data.key = 1;\n        Map<String, Object> mapData = new HashMap<>();\n        mapData.put(\"longInMap\", 2L);\n        mapData.put(\"longAsField\", data);\n\n        // Configure Jackson to preserve types\n        JsonFactory factory = new JsonFactory();\n        ObjectMapper mapper = new ObjectMapper(factory);\n        StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();\n        resolver.init(JsonTypeInfo.Id.CLASS, null);\n        resolver.inclusion(JsonTypeInfo.As.PROPERTY);\n        resolver.typeProperty(\"__t\");\n        mapper.setDefaultTyping(resolver);\n        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n        // Serialize\n        String json = mapper.writeValueAsString(mapData);\n        System.out.println(\"json = \" + json);\n\n        // Deserialize\n        Map deserializedData = mapper.readValue(json, Map.class);\n    }\n\n    static class Data {\n\n        public long key;\n    }\n}\n```\n\nI get this output and exception\n\n``` java\njson = {\n  \"__t\" : \"java.util.HashMap\",\n  \"longInMap\" : [ \"java.lang.Long\", 2 ],\n  \"longAsField\" : {\n    \"__t\" : \"com.pinkmatter.bean.serialization.Main$Data\",\n    \"key\" : [ \"java.lang.Long\", 1 ]\n  }\n}\nException in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Class java.lang.Long not subtype of [simple type, class long] (through reference chain: java.util.HashMap[\"longAsField\"]->com.pinkmatter.bean.serialization.Data[\"key\"])\n  at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:379)\n  at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:339)\n  at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.wrapAndThrow(BeanDeserializerBase.java:1591)\n  at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:278)\n  ...\nCaused by: java.lang.IllegalArgumentException: Class java.lang.Long not subtype of [simple type, class long]\n  at com.fasterxml.jackson.databind.type.TypeFactory.constructSpecializedType(TypeFactory.java:359)\n  at com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver._typeFromId(ClassNameIdResolver.java:72)\n  at com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver.typeFromId(ClassNameIdResolver.java:42)\n  ...\n```\n\nI am trying to serialize a bunch of basic plain old java objects from libraries we are using (so we cannot modify the classes or add annotations), while also trying to preserve the types of values in collections (\"longInMap\" in the above example must stay a Long object).\n\nThe problem is that Jackson throws the above exception when trying to deserialize the primitive `public long key` in the `Data` class. If I change the type to `public int key` then no exception is thrown and deserialization works.\n\nAlso, since there are many different types of objects and I don't know at compile time exactly what will be serialized I don't think using mix-ins will work.\n\nI am using Jackson 2.8.3.\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_62": {
    "description": "Custom UnmodifiableSetMixin Fails in Jackson 2.7+ but works in Jackson 2.6\nI'd like to be able to deserialize an `UnmodifiableSet` with default typing enabled. To do this I have created an `UnmodifiableSetMixin` as shown below:\n\n**NOTE**: You can find a minimal project with all the source code to reproduce this issue at https://github.com/rwinch/jackson-unmodifiableset-mixin\n\n``` java\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\nimport java.util.Set;\n\n@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY)\npublic abstract class UnmodifiableSetMixin {\n\n    @JsonCreator\n    public UnmodifiableSetMixin(Set<?> s) {}\n}\n```\n\nI then try to use this to deserialize an empty set.\n\n``` java\npublic class UnmodifiableSetMixinTest {\n    static final String EXPECTED_JSON = \"[\\\"java.util.Collections$UnmodifiableSet\\\",[]]\";\n\n    ObjectMapper mapper;\n\n    @Before\n    public void setup() {\n        mapper = new ObjectMapper();\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n        mapper.addMixIn(Collections.unmodifiableSet(Collections.<String>emptySet()).getClass(), UnmodifiableSetMixin.class);\n    }    \n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void read() throws Exception {\n        Set<String> foo = mapper.readValue(EXPECTED_JSON, Set.class);\n        assertThat(foo).isEmpty();\n    }\n}\n```\n\nThe test passes with Jackson 2.6, but fails using Jackson 2.7+ (including Jackson 2.8.3) with the following stack trace:\n\n```\njava.lang.IllegalStateException: No default constructor for [collection type; class java.util.Collections$UnmodifiableSet, contains [simple type, class java.lang.Object]]\n    at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:240)\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:249)\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:110)\n    at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:50)\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserializeWithType(CollectionDeserializer.java:310)\n    at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:42)\n    at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3788)\n    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)\n    at sample.UnmodifiableSetMixinTest.read(UnmodifiableSetMixinTest.java:36)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n```\n\nThis seems like a passivity issue. Is there a workaround for this problem?\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_63": {
    "description": "Reference-chain hints use incorrect class-name for inner classes\n``` java\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.jupiter.api.Assertions.expectThrows;\n\npublic class ReferenceChainTest {\n    // illustrates that jackson's \"reference chain\" help-text uses incorrect class-names for inner classes\n    @Test public void incorrectReferenceChain() throws IOException {\n        JsonMappingException jsonMappingException = expectThrows(JsonMappingException.class, () -> {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.readValue(objectMapper.writeValueAsBytes(new Outer()), Outer.class);\n        });\n        JsonMappingException.Reference reference = jsonMappingException.getPath().get(0);\n        assertThat(reference.toString()).isEqualTo(\"ReferenceChainTest$Outer[\\\"inner\\\"]\");\n    }\n\n    static class Outer {\n        public Inner inner = new Inner();\n    }\n\n    static class Inner {\n        public int x;\n\n        @JsonCreator public static Inner create(@JsonProperty(\"x\") int x) {\n            throw new RuntimeException(\"test-exception\");\n        }\n    }\n}\n\n```\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_64": {
    "description": "Further issues with `@JsonInclude` with `NON_DEFAULT`\n(follow-up to #1351)\n\nLooks like there are still cases where class annotation like:\n\n```\n@JsonInclude(JsonInclude.Include.NON_DEFAULT)\n```\n\ndoes not work for default `null` value suppression for `String` type  (at least).\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_66": {
    "description": "Failure with custom Enum key deserializer, polymorphic types\nNormally the `JsonParser` and the `DeserializationContext` is passed to a `Module`'s `JsonDeserializer`. \r\n\r\nHowever, in the `MapDeserializer`, when deserializing a `Map` with an `Enum` key, the `KeyDeserializer` doesn't accept the `JsonParser` as an argument:\r\n\r\nhttps://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java#L453\r\n    Object key = keyDes.deserializeKey(keyStr, ctxt);\r\n\r\nand the `StdKeyDeserializer.DelegatingKD` uses the context's parser\r\n\r\nhttps://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java#L315\r\n   Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\r\n\r\nWhen the type info field is missing from the json, the `DeserializationContext`'s `JsonParser`'s token is `END_OBJECT` (presumably because it `nextToken`'d through the object to find type and whiffed). \r\n\r\nThis makes the module fail since the `JsonParser` in the `Module` is wrong, i.e. not the same as the `JsonParser` in the `MapDeserializer`.\r\n\r\nClass:\r\n\r\n    import com.fasterxml.jackson.annotation.JsonTypeInfo;\r\n    \r\n    import java.util.Map;\r\n    \r\n    import static com.fasterxml.jackson.annotation.JsonTypeInfo.Id.NAME;\r\n    \r\n    @JsonTypeInfo(use = NAME, property = \"@type\", defaultImpl = SuperType.class)\r\n    public class SuperType {\r\n        private Map<SuperTypeEnum, String> someMap;\r\n    \r\n        public Map<SuperTypeEnum, String> getSomeMap() {\r\n            return someMap;\r\n        }\r\n    \r\n        public void setSomeMap(Map<SuperTypeEnum, String> someMap) {\r\n            this.someMap = someMap;\r\n        }\r\n    }\r\n\r\nEnum:\r\n\r\n    public enum SuperTypeEnum {\r\n        FOO\r\n    }\r\n\r\n\r\nTest:\r\n\r\n    import com.fasterxml.jackson.core.JsonParser;\r\n    import com.fasterxml.jackson.databind.DeserializationContext;\r\n    import com.fasterxml.jackson.databind.JsonDeserializer;\r\n    import com.fasterxml.jackson.databind.ObjectMapper;\r\n    import com.fasterxml.jackson.databind.module.SimpleModule;\r\n    import org.junit.*;\r\n\r\n    import java.io.IOException;\r\n\r\n    import static org.junit.Assert.assertEquals;\r\n\r\n    public class TestDeserializeType {\r\n\r\n        @Test\r\n        public void testNoTypeShouldDeserialize() throws IOException {\r\n            String json = \"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\";\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            SuperType superType = mapper.readValue(json, SuperType.class);\r\n            assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\", superType.getSomeMap().get(SuperTypeEnum.FOO));\r\n        }\r\n\r\n        @Test\r\n        public void testNoTypeWithModuleShouldDeserialize() throws IOException {\r\n            String json = \"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\";\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            SimpleModule simpleModule = new SimpleModule();\r\n            simpleModule.addDeserializer(SuperTypeEnum.class, new JsonDeserializer<SuperTypeEnum>() {\r\n                @Override\r\n                public SuperTypeEnum deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)\r\n                        throws IOException {\r\n\r\n                    return SuperTypeEnum.valueOf(jsonParser.getText());\r\n                }\r\n            });\r\n            mapper.registerModule(simpleModule);\r\n\r\n            SuperType superType = mapper.readValue(json, SuperType.class);\r\n            assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\", superType.getSomeMap().get(SuperTypeEnum.FOO));\r\n        }\r\n    }\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_67": {
    "description": "Map key deserializerModifiers ignored\nWe have a module that extends simple model to allow us to accept enum names in lower case in a fairly generic manner\r\nInside that we add the `modifyKeyDeserializer`\r\n\r\nThe incoming class (using immutables) is mapped to a guava immutable map.\r\nWalking through the code:\r\n\r\n> com.fasterxml.jackson.datatype.guava.deser.ImmutableMapDeserializer.createContextual\r\n>  calls DeserializationContext.findKeyDeserializer\r\n>  calls DeserializerCache.findKeyDeserializer\r\n>  calls BasicDeserializerFactory.createKeyDeserializer\r\n\r\nwhich has the code:\r\n```java\r\n        // the only non-standard thing is this:\r\n        if (deser == null) {\r\n            if (type.isEnumType()) {\r\n                return _createEnumKeyDeserializer(ctxt, type);\r\n            }\r\n            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\r\n        }\r\n```\r\n\r\nSince we are an enum type, it returns the value in the `_createEnumKeyDeserializer`, which is the standard enum deserializer.\r\nBelow that block is the check for the hasDeserializerModifiers, but since we have returned already, it is never called, so we can't override the behaviour.\r\n\r\nModule fragment:\r\n```java\r\n    setDeserializerModifier(new BeanDeserializerModifier() {\r\n                @Override\r\n                @SuppressWarnings(\"unchecked\")\r\n                public JsonDeserializer<Enum> modifyEnumDeserializer(\r\n                        DeserializationConfig config,\r\n                        final JavaType type,\r\n                        BeanDescription beanDesc,\r\n                        final JsonDeserializer<?> deserializer) {\r\n                    return new JsonDeserializer<Enum>() {\r\n                        @Override\r\n                        public Enum deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\r\n                            Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\r\n                            return Enum.valueOf(rawClass, jp.getValueAsString().toUpperCase());\r\n                        }\r\n                    };\r\n                }\r\n\r\n                @Override\r\n                public KeyDeserializer modifyKeyDeserializer(\r\n                        DeserializationConfig config,\r\n                        JavaType type,\r\n                        KeyDeserializer deserializer) {\r\n                    if (!type.isEnumType()) {\r\n                        return super.modifyKeyDeserializer(config, type, deserializer);\r\n                    }\r\n                    return new KeyDeserializer() {\r\n                        @Override\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        public Object deserializeKey(String key, DeserializationContext ctxt)\r\n                                throws IOException, JsonProcessingException {\r\n                            Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\r\n                            return Enum.valueOf(rawClass, key.toUpperCase());\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n```\r\n\r\nI appreciate the code around here is fairly complex.\r\n\r\n\r\nRelated issues (possibly):\r\nhttps://github.com/FasterXML/jackson-databind/issues/749\r\nhttps://github.com/FasterXML/jackson-databind/issues/1313\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_68": {
    "description": "ACCEPT_SINGLE_VALUE_AS_ARRAY partially broken in 2.7.x, 2.8.x\nIn 2.7.x, 2.8.x versions following test fails with an exception:\r\n\r\n```\r\npublic class Test {\r\n    private static final String JSON = \"[{\\\"message\\\":\\\"messageHere\\\"}]\";\r\n\r\n    static class A {\r\n        List<B> bs = Collections.emptyList();\r\n\r\n        @JsonCreator\r\n        A(final List<B> bs) {\r\n            this.bs = bs;\r\n        }\r\n    }\r\n\r\n    static class B {\r\n        List<C> cs = Collections.emptyList();\r\n\r\n        @JsonCreator\r\n        B(final List<C> cs) {\r\n            this.cs = cs;\r\n        }\r\n    }\r\n\r\n    public static class C {\r\n        String message;\r\n\r\n        @JsonCreator\r\n        C(@JsonProperty(\"message\") String message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void test() throws IOException {\r\n        ObjectMapper om = new ObjectMapper();\r\n        om.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\r\n        om.readValue(JSON, A.class);\r\n    }\r\n}\r\n\r\n\r\ncom.fasterxml.jackson.databind.exc.InputMismatchException: Can not construct instance of com.fasterxml.jackson.databind.creators.JsonCreatorWithCollectionTest$B, problem: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\r\n at [Source: [{\"message\":\"site is missing from bid request (breq) object\"}]; line: 1, column: 3] (through reference chain: java.util.ArrayList[0])\r\n\r\n    at com.fasterxml.jackson.databind.exc.InputMismatchException.from(InputMismatchException.java:58)\r\n    at com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1354)\r\n    at com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1019)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1207)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:314)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:148)\r\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:289)\r\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:261)\r\n    at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromArray(BeanDeserializerBase.java:1336)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:174)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:150)\r\n    at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3806)\r\n    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2849)\r\n    at com.fasterxml.jackson.databind.creators.JsonCreatorWithCollectionTest.test(JsonCreatorWithCollectionTest.java:51)\r\n```\r\n\r\nWhile on 2.5 and 2.6 it works fine.\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_69": {
    "description": "Wrong constructor picked up when deserializing object\nI discovered an issue with Jackson 2.7.8 (and Jackson 2.8.4) when several constructors have parameters annotated with `@JsonProperty` but only one is annotated with `@JsonCreator`.\r\n\r\nHere's a test case to reproduce it:\r\n```\r\nimport static org.junit.Assert.assertEquals;\r\n\r\nimport java.io.IOException;\r\n\r\nimport org.junit.Test;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonParseException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\n\r\npublic class TestJackson {\r\n  public static final class SimplePojo {\r\n    private final int intField;\r\n    private final String stringField;\r\n\r\n    public SimplePojo(@JsonProperty(\"intField\") int intField) {\r\n      this(intField, \"empty\");\r\n    }\r\n\r\n    public SimplePojo(@JsonProperty(\"stringField\") String stringField) {\r\n      this(-1, stringField);\r\n    }\r\n\r\n    @JsonCreator\r\n    public SimplePojo(@JsonProperty(\"intField\") int intField, @JsonProperty(\"stringField\") String stringField) {\r\n      this.intField = intField;\r\n      this.stringField = stringField;\r\n    }\r\n\r\n    public int getIntField() {\r\n      return intField;\r\n    }\r\n\r\n    public String getStringField() {\r\n      return stringField;\r\n    }\r\n  }\r\n\r\n  @Test\r\n  public void testJackson() throws JsonParseException, IOException {\r\n    ObjectMapper mapper = new ObjectMapper();\r\n    SimplePojo pojo = mapper.readValue(\"{ \\\"intField\\\": 1, \\\"stringField\\\": \\\"foo\\\" }\", SimplePojo.class);\r\n\r\n    assertEquals(1, pojo.getIntField());\r\n    assertEquals(\"foo\", pojo.getStringField());\r\n  }\r\n}\r\n```\r\n\r\nThis test throws an the following exception:\r\n```\r\ncom.fasterxml.jackson.databind.JsonMappingException: Could not find creator property with name 'stringField' (in class org.apache.drill.TestJackson$SimplePojo)\r\n at [Source: { \"intField\": 1, \"stringField\": \"foo\" }; line: 1, column: 1]\r\n\tat com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:270)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportMappingException(DeserializationContext.java:1234)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps(BeanDeserializerFactory.java:551)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer(BeanDeserializerFactory.java:226)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:141)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:476)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3899)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3794)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\r\n\tat TestJackson.testJackson(TestJackson.java:45)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\r\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n\tat java.lang.reflect.Method.invoke(Method.java:606)\r\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\r\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\r\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\r\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\r\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\r\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\r\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\r\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\r\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\r\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\r\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\r\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\r\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\r\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\r\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\r\n```\r\n\r\nAfter some debugging, it looks like that `BasicDeserializerFactory#_addDeserializerConstructors(...)` is looping over all the constructors, and is not favoring an explicit constructor over a non-explicit one. \r\n\r\nI actually don't know what should be the expected behavior: should jackson fail when two constructors are annotated, or should jackson favor the one annotated with `@JsonCreator`. Both options look reasonable to me (and I'm actually removing one of the constructors).\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_70": {
    "description": "`ACCEPT_CASE_INSENSITIVE_PROPERTIES` fails with `@JsonUnwrapped`\n(note: moved from https://github.com/FasterXML/jackson-dataformat-csv/issues/133)\r\n\r\nWhen trying to deserialize type like:\r\n\r\n```java\r\npublic class Person {\r\n  @JsonUnwrapped(prefix = \"businessAddress.\")\r\n  public Address businessAddress;\r\n}\r\n\r\npublic class Address {\r\n  public String street;\r\n  public String addon;\r\n  public String zip = \"\";\r\n  public String town;    \r\n  public String country;\r\n}\r\n```\r\n\r\nwith case-insensitive mapper (`mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);`) I get exception:\r\n\r\n```\r\njava.util.NoSuchElementException: No entry 'businessAddress' found, can't remove\r\n\tat com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.remove(BeanPropertyMap.java:447)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:534)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)\r\n   ...\r\n```\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_71": {
    "description": "Missing `KeyDeserializer` for `CharSequence`\nLooks like use of nominal Map key type of `CharSequence` does not work yet (as of 2.7.8 / 2.8.6).\r\nThis is something that is needed to work with certain frameworks, such as Avro's generated POJOs.\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_72": {
    "description": "ArrayIndexOutOfBoundsException on impossible non-static inner class constructor\nMinimal repro:\r\n\r\n```java\r\npublic class Something {\r\n    public InnerSomething a;\r\n\r\n    @JsonCreator\r\n    public Something(@JsonProperty(\"a\") InnerSomething a) {}\r\n\r\n    class InnerSomething {\r\n        @JsonCreator\r\n        public InnerSomething() {}\r\n    }\r\n\r\n}\r\n```\r\n\r\n```java\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        String ser = mapper.writeValueAsString(new Something(null));\r\n        mapper.readValue(ser, Something.class);\r\n```\r\n\r\nFails like this:\r\n\r\n```\r\njava.lang.ArrayIndexOutOfBoundsException: -1\r\n\r\n\tat com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer.assignParameter(PropertyValueBuffer.java:210)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeUsingPropertyBased(BeanDeserializer.java:380)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1123)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:298)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:133)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3807)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2797)\r\n```\r\n\r\nValidation is missing for this impossible constructor. Works as expected when `InnerSomething` is static.\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_73": {
    "description": "@JsonProperty(access = Access.READ_ONLY) - unexpected behaviour\nHey,\n\nI was hoping to make use of @JsonProperty(access = Access.READ_ONLY), but failed.\n\nAssume this class:\n\n```\npublic class TestPojo\n{\n    private String firstName;\n\n    private String lastName;\n\n    @JsonProperty(access = Access.READ_ONLY)\n    public String getFullName()\n    {\n        return firstName + \" \" + lastName;\n    }\n\n    public String getFirstName()\n    {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName)\n    {\n        this.firstName = firstName;\n    }\n\n    public String getLastName()\n    {\n        return lastName;\n    }\n\n    public void setLastName(String lastName)\n    {\n        this.lastName = lastName;\n    }\n}\n```\n\nI couldn't find a way to stop the deserializer from attempting to deserialize the field \"fullName\".\nThe only thing that helps is to create a setter and annotate it with `@JsonIgnore`. However, that setter does not make sense and I don't want to have it. Is this a bug in behaviour or am I missing something? Thanks\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_74": {
    "description": "AsPropertyTypeDeserializer ignores DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT\nThe `AsPropertyTypeDeserializer ` implementation does not respect the `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` feature. When deserializing an empty String it throws `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` instead of creating a null Object.\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_75": {
    "description": "JsonFormat.Shape.NUMBER_INT does not work when defined on enum type in 2.8\nBefore 2.8 the following worked for years. Now this annotation is not applied and enum is serialized as string. It would work if annotating the field. I am not sure if this is an expected change or not, could you please check?\r\n\r\n```java\r\npublic class Test {\r\n    @JsonFormat(shape = JsonFormat.Shape.NUMBER_INT)\r\n    enum Color {\r\n        RED,\r\n        YELLOW,\r\n        GREEN\r\n    }\r\n\r\n    static class Foo {\r\n        public final Color color;\r\n\r\n        Foo(Color color) {\r\n            this.color = color;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws JsonProcessingException {\r\n        final ObjectMapper mapper = new ObjectMapper();\r\n        System.out.println(mapper.writeValueAsString(new Foo(Color.GREEN)));\r\n    }\r\n}\r\n```\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_76": {
    "description": "Missing properties when deserializing using a builder class with a non-default constructor and a mutator annotated with `@JsonUnwrapped`\nWhen deserializing using a builder class with a non-default constructor and any number of mutator methods annotated with @JsonUnwrapped, the `BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped` method cuts short the process of adding SettableBeanProperties.\r\n\r\nThe logic dictates that once all properties necessary to construct the builder have been found, the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process.\r\n\r\nTherefore, in the case that the builder has a single property required for construction, and that property is found anywhere other than at the end of the JSON content, any properties subsequent to the constructor property are not evaluated and are left with their default values.\r\n\r\nGiven the following classes:\r\n```java\r\n@JsonDeserialize(builder = Employee.Builder.class)\r\npublic class Employee {\r\n    private final long id;\r\n    private final Name name;\r\n    private final int age;\r\n\r\n    private Employee(Builder builder) {\r\n        id = builder.id;\r\n        name = builder.name;\r\n        age = builder.age;\r\n    }\r\n\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    public Name getName() {\r\n        return name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    @JsonPOJOBuilder(withPrefix = \"set\")\r\n    public static class Builder {\r\n        private final long id;\r\n        private Name name;\r\n        private int age;\r\n\r\n        @JsonCreator\r\n        public Builder(@JsonProperty(\"emp_id\") long id) {\r\n            this.id = id;\r\n        }\r\n\r\n        @JsonUnwrapped\r\n        public void setName(Name name) {\r\n            this.name = name;\r\n        }\r\n\r\n        @JsonProperty(\"emp_age\")\r\n        public void setAge(int age) {\r\n            this.age = age;\r\n        }\r\n\r\n        public Employee build() {\r\n            return new Employee(this);\r\n        }\r\n    }\r\n}\r\n\r\npublic class Name {\r\n    private final String first;\r\n    private final String last;\r\n\r\n    @JsonCreator\r\n    public Name(\r\n        @JsonProperty(\"emp_first_name\") String first,\r\n        @JsonProperty(\"emp_last_name\") String last\r\n    ) {\r\n        this.first = first;\r\n        this.last = last;\r\n    }\r\n\r\n    public String getFirst() {\r\n        return first;\r\n    }\r\n\r\n    public String getLast() {\r\n        return last;\r\n    }\r\n}\r\n```\r\nAnd given the following JSON string:\r\n```json\r\n{\r\n    \"emp_age\": 30,\r\n    \"emp_id\": 1234,\r\n    \"emp_first_name\": \"John\",\r\n    \"emp_last_name\": \"Doe\"\r\n}\r\n```\r\nWe will see the following output:\r\n```java\r\nEmployee emp = new ObjectMapper().readValue(json, Employee.class);\r\n\r\nSystem.out.println(emp.getAge()); // 30\r\nSystem.out.println(emp.getId()); // 1234\r\nSystem.out.println(emp.getName()); // null\r\n```\r\nHowever, if we place the `emp_id` property at the end of the JSON string, we would get the following output:\r\n```java\r\nEmployee emp = new ObjectMapper().readValue(json, Employee.class);\r\n\r\nSystem.out.println(emp.getAge()); // 30\r\nSystem.out.println(emp.getId()); // 1234\r\nSystem.out.println(emp.getName()); // Name Object\r\n```\r\nIf we were to place `emp_age` and `emp_first_name` and `emp_last_name` all after the `emp_id` property in the JSON string, we would get the following output:\r\n```java\r\nEmployee emp = new ObjectMapper().readValue(json, Employee.class);\r\n\r\nSystem.out.println(emp.getAge()); // 0\r\nSystem.out.println(emp.getId()); // 1234\r\nSystem.out.println(emp.getName()); // null\r\n```\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_77": {
    "description": "Jackson Deserializer security vulnerability via default typing (CVE-2017-7525)\nI have send email to info@fasterxml.com\r\n\r\n**EDIT**: (23-Apr-2024)\r\n\r\nFix in:\r\n\r\n* 2.7.9.1\r\n* 2.8.9\r\n* 2.9.0 and all later 2.x releases\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_78": {
    "description": "Jackson Deserializer security vulnerability via default typing (CVE-2017-7525)\nI have send email to info@fasterxml.com\r\n\r\n**EDIT**: (23-Apr-2024)\r\n\r\nFix in:\r\n\r\n* 2.7.9.1\r\n* 2.8.9\r\n* 2.9.0 and all later 2.x releases\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_79": {
    "description": "@JsonIdentityReference not used when setup on class only\nI am trying to setup @JsonIdentityInfo/@JsonIdentityReference in order to serialize all references to a given class as Object Id (and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance)\r\n\r\nI use @JsonIdentityReference(alwaysAsId=true) in order to enforce exporting the object id in all cases.\r\nIt does not work as expected when I define the annotation only on the class (but it works fine when I set it directly on the property). I would rather not have to define it on every property as I will probably miss some...\r\n\r\nFrom what I see in [BeanSerializerBase](https://github.com/FasterXML/jackson-databind/blob/fea0d29eabcb8e4825a318501b35f8a759c91426/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java#L473), the alwaysAsId is reset when not ObjectIdInfo is found on the accessor:\r\n\r\n```java\r\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\r\n            if (objectIdInfo == null) {\r\n                // no ObjectId override, but maybe ObjectIdRef?\r\n                if (oiw != null) {\r\n                    objectIdInfo = intr.findObjectReferenceInfo(accessor,\r\n                            new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\r\noiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\r\n```\r\n\r\nShouldn't it be kept to the current value when no override is found ?\r\nI tried to set it back in the default ObjectIdInfo created with NAME_FOR_OBJECT_REF but I am not sure if this is the right way to fix this.\r\n\r\nHere is test I added in [TestObjectIdSerialization](https://github.com/vboulaye/jackson-databind/blob/master/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java#L324) for this case:\r\n```java\r\n\r\n    @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\r\n    @JsonIdentityReference(alwaysAsId=true)\r\n    static class ReallyAlwaysAsId\r\n    {\r\n        public int value;\r\n\r\n        public ReallyAlwaysAsId() { this(0); }\r\n        public ReallyAlwaysAsId(int v) {\r\n            value = v;\r\n        }\r\n    }\r\n\r\n    @JsonPropertyOrder(alphabetic=true)\r\n    static class ReallyAlwaysContainer\r\n    {\r\n\r\n        @JsonIdentityReference(alwaysAsId=true)\r\n        public AlwaysAsId a = new AlwaysAsId(13);\r\n\r\n        public ReallyAlwaysAsId b = new ReallyAlwaysAsId(13);\r\n\r\n    }\r\n\r\n    public void testReallyAlwaysAsId() throws Exception\r\n    {\r\n        String json = MAPPER.writeValueAsString(new ReallyAlwaysContainer());\r\n        assertEquals(\"{\\\"a\\\":1,\\\"b\\\":2}\", json);\r\n    }\r\n\r\n```\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_80": {
    "description": "Extraneous type id mapping added for base type itself\nLooks like type id (name) matching base type is included in type resolution list, automatically. While this might be useful sometimes it seems quite odd, and probably should only be included if:\r\n\r\n1. Base type is concrete and\r\n2. Base type has explicit name (not add if default name used)\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_81": {
    "description": "Add support for handling primitive/discrepancy problem with type refinements\n(note: derived from https://github.com/FasterXML/jackson-module-jaxb-annotations/issues/64)\r\n\r\nThe problem is that although `int` and `java.lang.Integer` are related, logically, they are not related by inheritance (or implementation). Since some legacy code may try refinements in this axis it'd be nice to handle this somehow. Two basic approaches would be:\r\n\r\n1. Just ignore primitive/wrapper override, return original type as is\r\n2. Allow wrapper to \"refine\" primitive, return wrapper.\r\n\r\nThere is also related question of whether to allow \"int to long\" and similar refinements, but start with basics.\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_82": {
    "description": "`JsonIgnoreProperties.allowSetters` is not working in Jackson 2.8\n```\r\n@JsonIgnoreProperties(value = { \"password\" }, ignoreUnknown = true, allowSetters = true)\r\npublic class JsonTest {\r\n\tprivate String username;\r\n\tprivate String password;\r\n\r\n\tpublic JsonTest() {\r\n\t\tsuper();\r\n\t\t// TODO Auto-generated constructor stub\r\n\t}\r\n\r\n\tpublic JsonTest(String username, String password) {\r\n\t\tsuper();\r\n\t\tthis.username = username;\r\n\t\tthis.password = password;\r\n\t}\r\n\r\n\tpublic String getUsername() {\r\n\t\treturn username;\r\n\t}\r\n\r\n\tpublic void setUsername(String username) {\r\n\t\tthis.username = username;\r\n\t}\r\n\r\n\tpublic String getPassword() {\r\n\t\treturn password;\r\n\t}\r\n\r\n\tpublic void setPassword(String password) {\r\n\t\tthis.password = password;\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tObjectMapper mapper = new ObjectMapper();\r\n\r\n\t\tJsonTest json = new JsonTest(\"user\", \"password\");\r\n\r\n\t\ttry {\r\n\t\t\tSystem.out.println(mapper.writeValueAsString(json));\r\n\t\t} catch (JsonProcessingException e) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\r\n\t\tString jsonString = \"{ \\\"username\\\":\\\"username\\\",\\\"password\\\":\\\"password\\\" }\";\r\n\t\ttry {\r\n\t\t\tjson = mapper.readValue(jsonString, JsonTest.class);\r\n\r\n\t\t\tSystem.out.println(json.getPassword());\r\n\t\t} catch (IOException e) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\r\n\t}\r\n}\r\n```\r\n\r\nthe version is 2.8.7.\r\nthe password cannot deserialize.\r\nthe output is:\r\n{\"username\":\"user\"}\r\nnull\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_83": {
    "description": "`FromStringDeserializer` ignores registered `DeserializationProblemHandler` for `java.util.UUID`\nCulprit appears to be [lines 155-161 of FromStringDeserializer](https://github.com/FasterXML/jackson-databind/blob/60ae6000d361f910ab0d7d269a5bac1fc66f4cd9/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java#L155-L161):\r\n\r\n```\r\n            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\r\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\r\n            if (cause != null) {\r\n                e.initCause(cause);\r\n            }\r\n            throw e;\r\n            // nothing to do here, yet? We'll fail anyway\r\n```\r\nThe above lines appear to show that the exception will be thrown regardless of any problem handling logic.\r\n\r\nTest Case:\r\n\r\n```\r\nimport com.fasterxml.jackson.databind.DeserializationContext;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\r\nimport org.junit.Test;\r\n\r\nimport java.io.IOException;\r\nimport java.util.UUID;\r\n\r\npublic class UUIDDeserializerTest {\r\n\r\n\r\n  @Test\r\n  public void itUsesDeserializationProblemHandlerProperly() throws IOException {\r\n    ObjectMapper mapper = new ObjectMapper().addHandler(new DeserializationProblemHandler() {\r\n      @Override\r\n      public Object handleWeirdStringValue(final DeserializationContext ctxt, final Class<?> targetType, final String valueToConvert, final String failureMsg) throws IOException {\r\n        return null;\r\n      }\r\n    });\r\n\r\n    mapper.readValue(\"{\\\"id\\\" : \\\"I am not a UUID\\\"}\", IdBean.class);\r\n\r\n\r\n\r\n  }\r\n\r\n  public static class IdBean {\r\n    private UUID id;\r\n\r\n    public UUID getId() {\r\n      return id;\r\n    }\r\n\r\n    public void setId(final UUID id) {\r\n      this.id = id;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe handler handles the issue properly; but an exception is thrown anyway:\r\n\r\n```\r\nan not deserialize value of type java.util.UUID from String \"I am not a UUID\": not a valid textual representation\r\n at [Source: (String)\"{\"id\" : \"I am not a UUID\"}\"; line: 1, column: 9] (through reference chain: com.company.test.UUIDDeserializerTest$IdBean[\"id\"])\r\ncom.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize value of type java.util.UUID from String \"I am not a UUID\": not a valid textual representation\r\n at [Source: (String)\"{\"id\" : \"I am not a UUID\"}\"; line: 1, column: 9] (through reference chain: com.company.test.UUIDDeserializerTest$IdBean[\"id\"])\r\n\tat com.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.weirdStringException(DeserializationContext.java:1504)\r\n\tat com.fasterxml.jackson.databind.deser.std.FromStringDeserializer.deserialize(FromStringDeserializer.java:156)\r\n\tat com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:127)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:287)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:151)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3999)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2980)\r\n```\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_84": {
    "description": "Missing properties from base class when recursive types are involved.\nWhen a type hierarchy as follows is constructed and the base class' type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class.\r\n\r\n```\r\nclass Base implements IFace<Sub> { @JsonProperty int base = 1 }\r\nclass Sub { @JsonProperty int sub = 2 }\r\ninterface IFace<T> {}\r\n```\r\n\r\nSerializes sub as `{\"sub\":2}` where `{\"base\":1,\"sub\":2}` is expected.\r\n\r\nI've created a minimal scenario of this bug here: https://github.com/slobo-showbie/jackson-recursive-type-bug\r\nI've experienced this bug in 2.7.8, 2.8.8, and 2.8.8.1\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_85": {
    "description": "`DateTimeSerializerBase` ignores configured date format when creating contextual \n`DateTimeSerializerBase#createContextual` creates a new serializer with `StdDateFormat.DATE_FORMAT_STR_ISO8601` format instead of re-using the actual format that may have been specified on the configuration. See the following code:\r\n\r\n```\r\nfinal String pattern = format.hasPattern()\r\n                                    ? format.getPattern()\r\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\r\n```\r\n\r\nUsing the `@JsonFormat` annotation on a field will therefore reset the format to Jackson's default even if the annotation doesn't specify any custom format.\r\n\r\n\r\n`DateBasedDeserializer#createContextual` behaves differently and tries to re-use the configured format:\r\n\r\n```\r\nDateFormat df = ctxt.getConfig().getDateFormat();\r\n// one shortcut: with our custom format, can simplify handling a bit\r\nif (df.getClass() == StdDateFormat.class) {\r\n   ...\r\n   StdDateFormat std = (StdDateFormat) df;\r\n   std = std.withTimeZone(tz);\r\n   ...\r\n} else {\r\n  // otherwise need to clone, re-set timezone:\r\n  df = (DateFormat) df.clone();\r\n  df.setTimeZone(tz);\r\n}\r\n```\r\n\r\nShouldn't the serializer follow the same approach ?\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_86": {
    "description": "Missing properties from base class when recursive types are involved.\nWhen a type hierarchy as follows is constructed and the base class' type is constructed first by the TypeFactory then serializing the sub class fails due to missing properties from the base class.\r\n\r\n```\r\nclass Base implements IFace<Sub> { @JsonProperty int base = 1 }\r\nclass Sub { @JsonProperty int sub = 2 }\r\ninterface IFace<T> {}\r\n```\r\n\r\nSerializes sub as `{\"sub\":2}` where `{\"base\":1,\"sub\":2}` is expected.\r\n\r\nI've created a minimal scenario of this bug here: https://github.com/slobo-showbie/jackson-recursive-type-bug\r\nI've experienced this bug in 2.7.8, 2.8.8, and 2.8.8.1\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_87": {
    "description": "`StdDateFormat` deserializes dates with no tz/offset as UTC instead of configured timezone\nPrior to version `2.8.9`, dates without time zone or time offset (eg `1970-01-01T00:00:00.000`) were deserialised in the TimeZone set on the ObjectMapper. \r\nStarting from `2.8.9`, these dates are deserialised in `UTC` - which is a major (breaking) change in behaviour...\r\n\r\nExample:\r\n```\r\nObjectMapper mapper = new ObjectMapper();\r\nmapper.setTimeZone(TimeZone.getTimeZone(\"GMT+2\");\r\nDate date = mapper.readValue(\"\\\"1970-01-01T00:00:00.000\\\"\", java.util.Date.class);\r\n\r\n// date == \"1970-01-01T00:00:00.000+02.00\" with Jackson < 2.8.9\r\n// date == \"1970-01-01T00:00:00.000+00.00\" with Jackson  2.8.9\r\n\r\n``` \n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_88": {
    "description": "Missing type checks when using polymorphic type ids\n(report by Lukes Euler)\r\n\r\n`JavaType` supports limited amount of generic typing for textual representation, originally just to support typing needed for `EnumMap` (I think). Based on some reports, it appears that some of type compatibility checks are not performed in those cases; if so, they should be made since there is potential for abuse.\r\nThe problem here although actual type assignment will fail later on, ability to trigger some of processing (instantiation of incompatible classes, perhaps assingnment of properties) may itself be vulnerability.\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_90": {
    "description": "`ValueInstantiator.canInstantiate()` ignores `canCreateUsingArrayDelegate()`\n### Problem\r\n\r\nMethod Javadoc doesn't match behavior. As a result, delegate collection constructors (for abstract types) don't work properly.\r\n\r\n### Tested versions\r\n\r\njackson-databind v2.8.7 and v2.9.2.\r\n\r\n### Location in code\r\n\r\nhttps://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java#L70\r\n\r\n### Expected Behavior\r\nOutputs `[]`.\r\n\r\n### Observed Behavior\r\n```\r\nException in thread \"main\" com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `ArrayDelegateDeserializationTest$MyType` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\r\n at [Source: (String)\"[]\"; line: 1, column: 1]\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1451)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1027)\r\n\tat com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserialize(AbstractDeserializer.java:265)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4001)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2992)\r\n\tat ArrayDelegateDeserializationTest.main(ArrayDelegateDeserializationTest.java:35)\r\n```\r\n\r\n### Test code\r\n```java\r\nimport java.util.List;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonCreator;\r\nimport com.fasterxml.jackson.annotation.JsonValue;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\n\r\npublic class ArrayDelegateDeserializationTest {\r\n\r\n    public static class MyTypeImpl implements MyType {\r\n        private final List<Integer> values;\r\n\r\n        MyTypeImpl(List<Integer> values) {\r\n            this.values = values;\r\n        }\r\n\r\n        @Override\r\n        public List<Integer> getValues() {\r\n            return values;\r\n        }\r\n    }\r\n\r\n    public interface MyType {\r\n        @JsonValue\r\n        List<Integer> getValues();\r\n\r\n        @JsonCreator\r\n        static MyType of(List<Integer> values) {\r\n            return new MyTypeImpl(values);\r\n        }\r\n    }\r\n\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        MyType thing = mapper.readValue(\"[]\", MyType.class);\r\n        System.out.println(thing.getValues());\r\n    }\r\n\r\n}\r\n```\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_91": {
    "description": "2.9.2 deserialization regression\nThere seems to be a regression in the latest 2.9.2 release.\r\n\r\nUsing `org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper` from `org.apache.logging.log4j:log4j-core:2.9.1` to deserialize the appended JSON object is throwing an exception with 2.9.2 but worked with 2.9.1.\r\n\r\n`org.apache.logging.log4j.core.jackson.Log4jYamlObjectMapper` and `org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper` fail in similar ways.\r\n\r\n### inputString\r\n```json\r\n{\r\n  \"timeMillis\" : 1493121664118,\r\n  \"thread\" : \"main\",\r\n  \"threadId\" : 1,\r\n  \"threadPriority\" : 5,\r\n  \"level\" : \"INFO\",\r\n  \"loggerName\" : \"HelloWorld\",\r\n  \"marker\" : {\r\n    \"name\" : \"child\",\r\n    \"parents\" : [ {\r\n      \"name\" : \"parent\",\r\n      \"parents\" : [ {\r\n        \"name\" : \"grandparent\"\r\n      } ]\r\n    } ]\r\n  },\r\n  \"message\" : \"Hello, world!\",\r\n  \"thrown\" : {\r\n    \"commonElementCount\" : 0,\r\n    \"message\" : \"error message\",\r\n    \"name\" : \"java.lang.RuntimeException\",\r\n    \"extendedStackTrace\" : [ {\r\n      \"class\" : \"logtest.Main\",\r\n      \"method\" : \"main\",\r\n      \"file\" : \"Main.java\",\r\n      \"line\" : 29,\r\n      \"exact\" : true,\r\n      \"location\" : \"classes/\",\r\n      \"version\" : \"?\"\r\n    } ]\r\n  },\r\n  \"contextStack\" : [ \"one\", \"two\" ],\r\n  \"loggerFqcn\" : \"org.apache.logging.log4j.spi.AbstractLogger\",\r\n  \"endOfBatch\" : false,\r\n  \"contextMap\" : {\r\n    \"bar\" : \"BAR\",\r\n    \"foo\" : \"FOO\"\r\n  },\r\n  \"source\" : {\r\n    \"class\" : \"logtest.Main\",\r\n    \"method\" : \"main\",\r\n    \"file\" : \"Main.java\",\r\n    \"line\" : 29\r\n  }\r\n}\r\n```\r\n\r\n### Exception\r\n```\r\norg.apache.logging.log4j.core.parser.ParseException: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `org.apache.logging.log4j.Level` (although at least one Creator exists): no String-argument constructor/factory method to deserialize from String value ('INFO')\r\n at [Source: (byte[])\"{\r\n  \"timeMillis\" : 1493121664118,\r\n  \"thread\" : \"main\",\r\n  \"threadId\" : 1,\r\n  \"threadPriority\" : 5,\r\n  \"level\" : \"INFO\",\r\n  \"loggerName\" : \"HelloWorld\",\r\n  \"marker\" : {\r\n    \"name\" : \"child\",\r\n    \"parents\" : [ {\r\n      \"name\" : \"parent\",\r\n      \"parents\" : [ {\r\n        \"name\" : \"grandparent\"\r\n      } ]\r\n    } ]\r\n  },\r\n  \"message\" : \"Hello, world!\",\r\n  \"thrown\" : {\r\n    \"commonElementCount\" : 0,\r\n    \"message\" : \"error message\",\r\n    \"name\" : \"java.lang.RuntimeException\",\r\n    \"extendedStackTrace\" : [ {\r\n      \"clas\"[truncated 482 bytes]; line: 6, column: 13] (through reference chain: org.apache.logging.log4j.core.impl.Log4jLogEvent[\"level\"])\r\n```\r\n\r\n### parsing pseudo code\r\n```java\r\nimport org.apache.logging.log4j.core.LogEvent;\r\nimport org.apache.logging.log4j.core.parser.LogEventParser;\r\nimport org.apache.logging.log4j.core.parser.JsonLogEventParser;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nLogEventParser parser = new JsonLogEventParser();\r\nLogEvent result = parser.parseFrom(inputString.getBytes(StandardCharsets.UTF_8));\r\nassert result != null;\r\n```\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_92": {
    "description": "Block more JDK types from polymorphic deserialization (CVE 2017-15095)\n(note: follow-up for #1599)\r\n\r\nAfter initial set of types blocked new reports have arrived for more black-listing.\r\nAlthough eventual approach is likely to rely separate module (for more timely updates and wider version coverage), at this point addition in databind is needed.\r\n\r\nI will update specific list of additions once complete and release is out. Target versions are `2.8.10` and `2.9.1` -- it is possible to backport in 2.7 and even 2.6, but there is diminishing return on effort with those versions so it will not happen unless specifically requested (I'm happy to merge PRs).\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_93": {
    "description": "`NullPointerException` in `SubTypeValidator.validateSubType` when validating Spring interface\nIn jackson-databind-2.8.11 jackson-databind-2.9.3 and  jackson-databind-2.9.4-SNAPSHOT `SubTypeValidator.validateSubType` fails with a `NullPointerException` if the `JavaType.getRawClass()` is an interface that starts with `org.springframework.` For example, the following will fail:\r\n\r\n```java\r\npackage org.springframework.security.core;\r\n\r\nimport java.util.*;\r\n\r\npublic class Authentication {\r\n\tprivate List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();\r\n\r\n\tpublic List<GrantedAuthority> getAuthorities() {\r\n\t\treturn this.authorities;\r\n\t}\r\n\r\n\tpublic void setAuthorities(List<GrantedAuthority> authorities) {\r\n\t\tthis.authorities = authorities;\r\n\t}\r\n}\r\n```\r\n\r\n```java\r\npackage org.springframework.security.core;\r\n\r\npublic interface GrantedAuthority {\r\n\tString getAuthority();\r\n}\r\n```\r\n\r\n```java\r\n@Test\r\npublic void validateSubTypeFailsWithNPE() throws Exception {\r\n\tObjectMapper mapper = new ObjectMapper();\r\n\tmapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\r\n\r\n\tString json = \"{\\\"@class\\\":\\\"org.springframework.security.core.Authentication\\\",\\\"authorities\\\":[\\\"java.util.ArrayList\\\",[]]}\";\r\n\r\n\tAuthentication authentication = mapper.readValue(json, Authentication.class);\r\n}\r\n```\r\n\r\nwith the following stacktrace:\r\n\r\n```\r\njava.lang.NullPointerException\r\n\tat com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator.validateSubType(SubTypeValidator.java:86)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory._validateSubType(BeanDeserializerFactory.java:916)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:135)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:411)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:444)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:183)\r\n\tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:27)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handlePrimaryContextualization(DeserializationContext.java:651)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:471)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\r\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:477)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:4178)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3997)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2992)\r\n```\r\nIn prior versions, the test works.   \n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_94": {
    "description": "Block two more gadgets to exploit default typing issue (c3p0, CVE-2018-7489)\nFrom an email report there are 2 other c3p0 classes (above and beyond ones listed in #1737) need to be blocked.\r\n\r\nEDIT 21-Jun-2021: Fix included in:\r\n\r\n* `2.9.5`\r\n* `2.8.11.1`\r\n* `2.7.9.3`\r\n* `2.6.7.5`\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_95": {
    "description": "`TypeFactory.constructFromCanonical()` throws NPE for Unparameterized generic canonical strings\nWhen `TypeFactory.constructFromCanonical(returnType)` is used in `2.6.1`, the `returnType` string for generic types is not expected to have parameterized type information. For example, the following code runs fine on 2.6.1:\r\n\r\n```java\r\nreturnType = \"java.util.List\";\r\nobjectMapper.getTypeFactory().constructFromCanonical(returnType);\r\n```\r\n\r\nBut in version `2.8.7`, the same code gives a `NullPointerException` with the stack trace:\r\n\r\n```\r\njava.rmi.RemoteException: java.lang.NullPointerException:null. \r\n    at com.fasterxml.jackson.databind.type.TypeFactory._fromVariable(TypeFactory.java:1421)\r\n    at com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1182)\r\n    at com.fasterxml.jackson.databind.type.TypeFactory._fromParamType(TypeFactory.java:1404)\r\n    at com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1172)\r\n    at com.fasterxml.jackson.databind.type.TypeFactory._resolveSuperInterfaces(TypeFactory.java:1318)\r\n    at com.fasterxml.jackson.databind.type.TypeFactory._fromClass(TypeFactory.java:1261)\r\n    at com.fasterxml.jackson.databind.type.TypeParser.parseType(TypeParser.java:60)\r\n    at com.fasterxml.jackson.databind.type.TypeParser.parse(TypeParser.java:33)\r\n    at com.fasterxml.jackson.databind.type.TypeFactory.constructFromCanonical(TypeFactory.java:544)\r\n    at foo.company.package.serialize.Serializer.deserialize(Serializer.java:355)\r\n```\r\n\r\nBut if the `returnType` string is passed with the generic type information, even if it is passed as `Object`, ie, `returnType = \"java.util.List<java.lang.Object>\";`, it works fine.\r\n\r\nI have 2 questions, is there a way to make this change backward compatible? If not, how can I work around this? PS: The workaround given by Tatu in the mailing list is not clear to *me*, if someone can give me an example, it'd be great help. Thanks!\r\n\r\n[Link to google groups thread.](https://groups.google.com/forum/#!topic/jackson-user/Ik1oEkUC1E8)\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_96": {
    "description": "Implicit constructor property names are not renamed properly with `PropertyNamingStrategy`\n(note: spin-off from https://github.com/FasterXML/jackson-modules-java8/issues/67)\r\n\r\nLooks like something with linking of creator properties (constructor arguments for annotated/discovered constructor) to \"regular\" properties does not work when using `PropertyNamingStrategy`. Apparently this was working better until 2.9.1, but broke with 2.9.2.\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_97": {
    "description": "Context attributes are not passed/available to custom serializer if object is in POJO\nBelow is a test case where I create a custom serializer and use it to serialize an object 1) in a HashMap and 2) in an ObjectNode. In both cases I pass attribute to the serializer like this:\r\n`mapper.writer().withAttribute(\"myAttr\", \"Hello!\")`\r\nSerializing HashMap works as expected, but during ObjectNode serialization the attribute is null . It seems that in both cases the custom serializer should get access to the passed attribute and so both lines in the output should contain \"Hello!\"\r\n\r\nProduced output from running testCase.test()\r\n```\r\n{\"data\":{\"aStr\":\"The value is: Hello!\"}}\r\n{\"data\":{\"aStr\":\"The value is: NULL\"}}\r\n\r\n```\r\nTest case:\r\n\r\n```\r\nimport com.fasterxml.jackson.core.JsonGenerator;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializerProvider;\r\nimport com.fasterxml.jackson.databind.annotation.JsonSerialize;\r\nimport com.fasterxml.jackson.databind.node.ObjectNode;\r\nimport com.fasterxml.jackson.databind.ser.std.StdSerializer;\r\n\r\nimport java.io.IOException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class TestCase {\r\n  public final static ObjectMapper mapper = new ObjectMapper();\r\n\r\n  @JsonSerialize(using = TestCase.CustomSer.class)\r\n  public static class Data {\r\n    public String aStr;\r\n  }\r\n\r\n  public static class CustomSer extends StdSerializer<Data> {\r\n    public CustomSer() {\r\n      super(Data.class);\r\n    }\r\n\r\n    @Override\r\n    public void serialize(Data value, JsonGenerator gen, SerializerProvider provider) throws IOException {\r\n      String attrStr = (String) provider.getAttribute(\"myAttr\");\r\n      gen.writeStartObject();\r\n      gen.writeObjectField(\"aStr\", \"The value is: \" + (attrStr == null ? \"NULL\" : attrStr));\r\n      gen.writeEndObject();\r\n    }\r\n  }\r\n\r\n  public static void test() throws IOException {\r\n    Data data = new Data();\r\n    data.aStr = \"Hello\";\r\n\r\n    Map<String, Object> mapTest = new HashMap<>();\r\n    mapTest.put(\"data\", data);\r\n\r\n    ObjectNode treeTest = mapper.createObjectNode();\r\n    treeTest.putPOJO(\"data\", data);\r\n\r\n    String mapOut = mapper.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(mapTest);\r\n    System.out.println(mapOut);\r\n\r\n    String treeOut = mapper.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);\r\n    System.out.println(treeOut);\r\n  }\r\n}\r\n\r\n```\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_98": {
    "description": "External property polymorphic deserialization does not work with enums\nversions: Jackson 2.8.1, Jackson-module-kotlin 2.8.1\r\n\r\nAttempting to deserialize a class using external_property. In my case, the property is an Enum type with values matching the type name. Now that issue #999 is fixed, I thought this would work, but now I'm getting a different error:\r\n\r\n```\r\nException in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of enum.Invite, problem: argument type mismatch\r\n at [Source: {\r\n  \"kind\": \"CONTACT\",\r\n  \"to\": {\r\n    \"name\": \"Foo\"\r\n  }\r\n}; line: 6, column: 1]\r\n    at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:268)\r\n    at com.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:1405)\r\n    at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.wrapAsJsonMappingException(StdValueInstantiator.java:468)\r\n    at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.rewrapCtorProblem(StdValueInstantiator.java:487)\r\n    at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromObjectWith(StdValueInstantiator.java:276)\r\n    at com.fasterxml.jackson.module.kotlin.KotlinValueInstantiator.createFromObjectWith(KotlinValueInstantiator.kt:30)\r\n    at com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator.build(PropertyBasedCreator.java:135)\r\n    at com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler.complete(ExternalTypeHandler.java:225)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId(BeanDeserializer.java:937)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeWithExternalTypeId(BeanDeserializer.java:792)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:312)\r\n    at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:148)\r\n    at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3789)\r\n    at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2852)\r\n    at enum.Reproduction_KindEnumKt.main(Reproduction-KindEnum.kt:49)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\r\n    at java.lang.reflect.Method.invoke(Method.java:498)\r\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\r\nCaused by: java.lang.IllegalArgumentException: argument type mismatch\r\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\r\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\r\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\r\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)\r\n    at com.fasterxml.jackson.databind.introspect.AnnotatedConstructor.call(AnnotatedConstructor.java:124)\r\n    at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromObjectWith(StdValueInstantiator.java:274)\r\n    ... 15 more\r\n\r\nProcess finished with exit code 1\r\n```\r\n\r\nHere is the reproduction recipe: https://github.com/rocketraman/jackson-issue-enum-polymorphism/blob/master/src/main/kotlin/enumtype/Reproduction-KindEnum.kt\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_99": {
    "description": "Canonical string for reference type is built incorrectly\nCanonical string for reference type is built incorrectly. \r\nE.g.:\r\n`new ReferenceType(new TypeFactory(new LRUMap<Object, JavaType>(0, 10000)).constructType(Object.class), new PlaceholderForType(0)).toCanonical()`\r\nyields:\r\n`java.lang.Object<$1`\r\nwhile the expected value is:\r\n`java.lang.Object<$1>`\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_100": {
    "description": "`TreeTraversingParser` does not take base64 variant into account\nThis affects at least 2.6.4 to current versions. In [TreeTraversingParser#getBinaryValue](https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java#L348), a `Base64Variant` is accepted but ignored. The call to `n.binaryValue()`, when `n` is a `TextNode`, then uses the default Base64 variant instead of what's specified. It seems the correct behavior would be to call `TextNode#getBinaryValue` instead.\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_101": {
    "description": "`@JsonUnwrapped` fields are skipped when using `PropertyBasedCreator` if they appear after the last creator property\nExample:\r\n\r\n```java\r\n    static class Bean {\r\n        int x;\r\n        int y;\r\n\r\n        @JsonUnwrapped\r\n        UnwrappedBean w;\r\n\r\n        public Bean(@JsonProperty(\"x\") int x, @JsonProperty(\"y\") int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        public void setW(UnwrappedBean w) {\r\n            this.w = w;\r\n        }\r\n    }\r\n\r\n    static class UnwrappedBean {\r\n        int a;\r\n        int b;\r\n\r\n        public UnwrappedBean(@JsonProperty(\"a\") int a, @JsonProperty(\"b\") int b) {\r\n            this.a = a;\r\n            this.b = b;\r\n        }\r\n    }\r\n```\r\n\r\n```json\r\n    {\"x\": 1, \"a\": 2, \"y\": 3, \"b\": 4}\r\n```\r\n\r\n`x`, `y`, and `a` are deserialized as expected. `b` is skipped entirely. I think I've found the root cause and the fix doesn't appear to break any tests; opening a PR for further review.\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_102": {
    "description": "Cannot set custom format for `SqlDateSerializer` globally\nVersion: 2.9.5\r\n\r\nAfter https://github.com/FasterXML/jackson-databind/issues/219 was fixed, the default format for `java.sql.Date` serialization switched from string to numeric, following the default value of `WRITE_DATES_AS_TIMESTAMPS`.\r\n\r\nIn order to prevent breaks, I want `java.sql.Date` to serialize as a string, without changing behavior for `java.util.Date` (which has always serialized as a number by default).\r\n\r\nAccording to https://github.com/FasterXML/jackson-databind/issues/219#issuecomment-370690333, I should be able to revert the behavior for `java.sql.Date` only with\r\n```\r\nfinal ObjectMapper mapper = new ObjectMapper();\r\nmapper.configOverride(java.sql.Date.class).setFormat(JsonFormat.Value.forPattern(\"yyyy-MM-dd\"));\r\n```\r\n\r\nThis doesn't seem to do anything, though. Looking at the code, it looks like it's because the custom format isn't actually added to `SqlDateSerializer` except in the `createContextual` method (https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java#L59).\r\n\r\nFor now, I've reverted this behavior with \r\n```\r\nmapper.registerModule(new SimpleModule() {\r\n            {\r\n                addSerializer(\r\n                        java.sql.Date.class,\r\n                        new SqlDateSerializer().withFormat(false, new SimpleDateFormat(\"yyyy-MM-dd\"))\r\n                );\r\n            }\r\n        });\r\n```\r\nbut it seems pretty hacky so I'd prefer the other method if possible. \r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_103": {
    "description": "Location information included twice for some `JsonMappingException`s\nLooks like due to some double-processing, certain kinds of `JsonMappingException` (observed with `InvalidFormatException`) seem to include \" at [source]\" twice. This is probably due to calls to `getMessage()` that add location being used to pass `message` property when wrapping or re-creating exceptions.\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_104": {
    "description": "Large ISO-8601 Dates are formatted/serialized incorrectly\n**The problem**\r\n\r\n```\r\njava.text.ParseException: Cannot parse date \"\u75dd055-12-02T16:47:04.192+0000\": not compatible with any of standard forms (\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ss.SSS\", \"EEE, dd MMM yyyy HH:mm:ss zzz\", \"yyyy-MM-dd\")\r\n\tat com.fasterxml.jackson.databind.util.StdDateFormat.parse(StdDateFormat.java:372)\r\n```\r\n\r\nYears > 9999 are not rendered as 5 numbers or more, but with a non numerical characters for the thousands digit..\r\n\r\n**The testcase**\r\n\r\n```\r\npublic class MyTestCase{\r\n  public static void main(String[] args) throws JsonProcessingException, ParseException {\r\n    StdDateFormat formatter = new StdDateFormat();\r\n    System.out.println(formatter.format(new Date(Long.MIN_VALUE)));\r\n    System.out.println(formatter.format(new Date(Long.MAX_VALUE)));\r\n    System.out.println(formatter.parse(formatter.format(new Date(Long.MIN_VALUE))));\r\n    System.out.println(formatter.parse(formatter.format(new Date(Long.MAX_VALUE))));\r\n\r\n    assert formatter.parse(formatter.format(new Date(Long.MAX_VALUE))).getTime() == Long.MAX_VALUE;\r\n    // Will fail due to lack of support for negative dates.\r\n    //assert formatter.parse(formatter.format(new Date(Long.MIN_VALUE))).getTime() == Long.MIN_VALUE;\r\n  }\r\n}\r\n```\r\n**Expected**\r\n\r\na) All dates are formatted correctly, meaning, years bigger than 9999.\r\nb) or some sort of exception telling the data is not supported.\r\n\r\n**The location** \r\n`'0' + something`\r\nhttps://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java#L442\r\n\r\n**Suggestion**\r\na) Adding '0' with an integer is not a safe operation. But if you are doing it, you need an upper bound check, e.g.:\r\n```\r\n private static void pad2(StringBuffer buffer, int value) {\r\n     int tens = value / 10;\r\n+    if (tens >= 10) {\r\n+        pad2(buffer, tens);\r\n+        buffer.append((char) ('0' + value % 10));\r\n+        return;\r\n+    }\r\n     if (tens == 0) {\r\n         buffer.append('0');\r\n     } else {\r\n         buffer.append((char) ('0' + tens));\r\n         value -= 10 * tens;\r\n     }\r\n     buffer.append((char) ('0' + value));\r\n }\r\n \r\n private static void pad3(StringBuffer buffer, int value) {\r\n     int h = value / 100;\r\n+    if (h >= 100) {\r\n+        pad3(buffer, h);\r\n+        pad2(buffer, value % 100);\r\n+        return;\r\n+    }\r\n     if (h == 0) {\r\n         buffer.append('0');\r\n     } else {\r\n         buffer.append((char) ('0' + h));\r\n         value -= (h * 100);\r\n     }\r\n     pad2(buffer, value);\r\n }\r\n```\r\nb) Or if you do not want to support such high years, then throw some sort of exception. E.g.:\r\n```\r\n     protected void _format(TimeZone tz, Locale loc, Date date,\r\n             StringBuffer buffer)\r\n     {\r\n         Calendar cal = _getCalendar(tz);\r\n         cal.setTime(date);\r\n\r\n+        int year = cal.get(Calendar.YEAR);\r\n+        if (cal.get(Calendar.ERA) == 0) {\r\n+            year = -year + 1;\r\n+        }\r\n+        if (year < 0 || 9999 < year) {\r\n+            throw new IndexOutOfBoundsException(\"Year not within the range [0,9999]: \" + Integer.toString(year))\r\n+        }\r\n \r\n-        pad4(buffer, cal.get(Calendar.YEAR));\r\n+        pad4(buffer, year);\r\n         buffer.append('-');\r\n         pad2(buffer, cal.get(Calendar.MONTH) + 1);\r\n         buffer.append('-');\r\n         pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\r\n```\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_105": {
    "description": "Illegal reflective access operation warning when using `java.lang.Void` as value type\nI'm using Jackson (**2.9.7**) through Spring's RestTemplate:\r\n\r\n```java\r\nResponseEntity<Void> response = getRestTemplate().exchange(\r\n\t\trequestUrl,\r\n\t\tHttpMethod.PATCH,\r\n\t\tnew HttpEntity<>(dto, authHeaders),\r\n\t\tVoid.class\r\n);\r\n```\r\n\r\nWhen [`Void`](https://docs.oracle.com/javase/7/docs/api/java/lang/Void.html) is used to indicate that the ResponseEntity has no body, the following warning appears in the console:\r\n\r\n```\r\nWARNING: An illegal reflective access operation has occurred\r\nWARNING: Illegal reflective access by com.fasterxml.jackson.databind.util.ClassUtil (file:/<snip>repository/com/fasterxml/jackson/core/jackson-databind/2.9.7/jackson-databind-2.9.7.jar) to constructor java.lang.Void()\r\nWARNING: Please consider reporting this to the maintainers of com.fasterxml.jackson.databind.util.ClassUtil\r\nWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\r\nWARNING: All illegal access operations will be denied in a future release\r\n```\r\n\r\nThe problem disappears if `String` is used as generic type. \n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_106": {
    "description": "`TreeTraversingParser` does not check int bounds\nSimilar to https://github.com/FasterXML/jackson-databind/issues/1729, [TreeTraversingParser](https://github.com/FasterXML/jackson-databind/blob/2.9/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java#L311) does not perform bounds checks on _some_ JSON values bound to ints.\r\n\r\nUsing Jackson version 2.9.7, here are several comparisons generated with the following code:\r\n```java\r\n  public static class IntClass {\r\n    public int x;\r\n\r\n    @Override\r\n    public String toString() {\r\n      return String.valueOf(x);\r\n    }\r\n  }\r\n\r\n  ObjectMapper mapper  = new ObjectMapper();\r\n  void readAndPrint(String _example) {\r\n    String fromTree;\r\n    try {\r\n      JsonNode tree = mapper.readTree(_example);\r\n      fromTree = mapper.readerFor(IntClass.class).readValue(tree).toString();\r\n    } catch (IOException _e) {\r\n      fromTree = _e.getClass().getSimpleName();\r\n    }\r\n\r\n    String fromString;\r\n    try {\r\n      fromString = mapper.readerFor(IntClass.class).readValue(_example).toString();\r\n    } catch (IOException _e) {\r\n      fromString = _e.getClass().getSimpleName();\r\n    }\r\n\r\n    System.out.printf(\"|%30s | %30s | %-30s|\\n\", _example, fromTree, fromString);\r\n  }\r\n\r\n  @Test\r\n  public void compareFromTree() {\r\n    System.out.printf(\"|%30s | %30s | %-30s|\\n\", \"json input\", \"read from tree\", \"read from string\");\r\n    System.out.println(\"|-------------------------------|--------------------------------|-------------------------------|\");\r\n    readAndPrint(\"{\\\"x\\\": 0}\");\r\n    // etc.\r\n  }\r\n```\r\n\r\n|                    json input |                 read from tree | read from string              |\r\n|-------------------------------|--------------------------------|-------------------------------|\r\n|                      {\"x\": 0} |                              0 | 0                             |\r\n|                     {\"x\": 10} |                             10 | 10                            |\r\n|                    {\"x\": 1e4} |                          10000 | 10000                         |\r\n|                   {\"x\": 1e10} |                     2147483647 | JsonMappingException          |\r\n|                   {\"x\": 1e-1} |                              0 | 0                             |\r\n|             {\"x\": 2147483648} |                    -2147483648 | JsonMappingException          |\r\n|             {\"x\": 2147483649} |                    -2147483647 | JsonMappingException          |\r\n|            {\"x\": -2147483649} |                     2147483647 | JsonMappingException          |\r\n|            {\"x\": -4294967295} |                              1 | JsonMappingException          |\r\n|                    {\"x\": 0.1} |                              0 | 0                             |\r\n|                    {\"x\": 1.9} |                              1 | 1                             |\r\n|     {\"x\": 1.9999999999999999} |                              2 | 2                             |\r\n|                   {\"x\": true} |       MismatchedInputException | MismatchedInputException      |\r\n|                     {\"x\": {}} |       MismatchedInputException | MismatchedInputException      |\r\n|                     {\"x\": []} |       MismatchedInputException | MismatchedInputException      |\r\n|                    {\"x\": [0]} |       MismatchedInputException | MismatchedInputException      |\r\n|                    {\"x\": \"0\"} |                              0 | 0                             |\r\n|                   {\"x\": \"10\"} |                             10 | 10                            |\r\n|                  {\"x\": \"1e4\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                 {\"x\": \"1e10\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                 {\"x\": \"1e-1\"} |         InvalidFormatException | InvalidFormatException        |\r\n|           {\"x\": \"2147483648\"} |         InvalidFormatException | InvalidFormatException        |\r\n|           {\"x\": \"2147483649\"} |         InvalidFormatException | InvalidFormatException        |\r\n|          {\"x\": \"-2147483649\"} |         InvalidFormatException | InvalidFormatException        |\r\n|          {\"x\": \"-4294967295\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                  {\"x\": \"0.1\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                  {\"x\": \"1.9\"} |         InvalidFormatException | InvalidFormatException        |\r\n|   {\"x\": \"1.9999999999999999\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                 {\"x\": \"true\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                   {\"x\": \"{}\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                   {\"x\": \"[]\"} |         InvalidFormatException | InvalidFormatException        |\r\n|                  {\"x\": \"[0]\"} |         InvalidFormatException | InvalidFormatException        |\r\n\r\nWithout digging further into the code, it appears if the JSON value is numeric, `TreeTraversingParser` silently overflows. Maybe this is expected behavior, but to me the inconsistency between reading from a non-tree (reader/string/file, etc) versus directly from a tree seems like a bug. At the very least, it makes it less convenient to do manipulations on a JSON document before binding.\r\n\r\nI would expect an exception thrown for the all but the first three examples above, but I do understand there are use-cases for coercing values. Even so, I would expect the coercion logic to be \r\n- consistent between the parsers (or clearly documented otherwise)\r\n- consistent between quoted and unquoted values\r\n\r\nI'm also curious about the expected behavior when converting non-integral values. Why is `true` `MismatchedInput`, but `0.1` is converted? Similarly, why are `0.1`, `1e4`, and `1e-1` acceptable, but not when in quotes, even though `\"10\"` and other quote integers are acceptable? \r\n\r\nThanks for all your hard work on this. I hope this issue doesn't come off as condescending. For our specific use case, we read the value as a tree, validating it against a schema, then using Jackson to bind the tree to an object. While it's true that we can specify type, minimum, and maximum values in the schema, it is prone to mistakes, and there's not necessarily a reason to tie the schema to the language implementation, provided things like overflow consistently result in an exception. Thus, I'm trying to better understand the expectations and limits Jackson has when using the tree parser.\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_107": {
    "description": "`DeserializationProblemHandler.handleUnknownTypeId()` returning `Void.class`, enableDefaultTyping causing NPE\nReturning Void.class from com.fasterxml.jackson.databind.deser.HandleUnknowTypeIdTest.testDeserializationWithDeserializationProblemHandler().new DeserializationProblemHandler() {...}.handleUnknownTypeId(DeserializationContext, JavaType, String, TypeIdResolver, String) is causing a NPE in jackson 2.9. I'll provide a pull request illustrating the issue in a test. \n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_108": {
    "description": "Change of behavior (2.8 -> 2.9) with `ObjectMapper.readTree(input)` with no content\nSo, it looks like `readTree()` methods in `ObjectMapper`, `ObjectReader` that take input OTHER than `JsonParser`, and are given \"empty input\" (only white-space available before end), will\r\n\r\n* Return `NullNode` (Jackson 2.x up to and including 2.8)\r\n* Return `null` (Jackson 2.9)\r\n\r\nLatter behavior is what `readTree(JsonParser)` has and will do; but this accidentally changed other methods due to refactoring that unified underlying call handling (and add checking for new `DeserializationFeature.FAIL_ON_TRAILING_TOKENS`). \r\nBehavior for this edge case was not being tested, apparently.\r\n\r\nNow: since behavior has been changed for all 2.9.x patch versions, I am not sure it should be changed for 2.9 branch. But it seems sub-optimal as behavior, and something to definitely change for 3.0... but probably also for 2.10.\r\n\r\nThere are multiple things we could do.\r\n\r\n1. Change it back to 2.8, to return `NullNode`\r\n2. Change to throw exception, as \"not valid\" use case\r\n3. Change it to return `MissingNode`\r\n4. Leave as-is, for rest of 2.x.\r\n\r\nAlthough it might seem best to revert it to (1), that seems somewhat wrong, problematic, as it would now not be possible to distinguish between JSON `null` value and missing content.\r\nAnd although (2) would probably make sense, if designing API from scratch, it is probably too intrusive.\r\n\r\nSo I think (3) is the best way: it avoids returning `null` or throwing Exception (both being likely to break 2.9 code), but still allows distinguishing between all possible input cases.\r\n\r\n\r\n\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_109": {
    "description": "`WRITE_BIGDECIMAL_AS_PLAIN` is ignored if `@JsonFormat` is used\nI am trying to serialize BigDecimal as json string while avoiding scientific notation (kotlin):\r\n```kotlin\r\ndata class Test(\r\n    @JsonFormat(shape= JsonFormat.Shape.STRING)\r\n    val value: BigDecimal\r\n)\r\n\r\nfun main() {\r\n    val mapper = jacksonObjectMapper()\r\n        .configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true)\r\n    val test = Test(0.0000000005.toBigDecimal())\r\n    println(mapper.writeValueAsString(test))\r\n}\r\n```\r\noutput `{\"value\":\"5.0E-10\"}`\r\nIf  `JsonFormat` is removed, then `WRITE_BIGDECIMAL_AS_PLAIN` works and output is `{\"value\":0.00000000050}` (json number, not string), but trying to make it json string with `JsonFormat` results in `WRITE_BIGDECIMAL_AS_PLAIN` being ignored.\r\n\r\nUsing latest version, jackson-bom:2.9.8\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_110": {
    "description": "Inconsistent handling of Collections$UnmodifiableList VS Collections$UnmodifiableRandomAccessList\nI'm sorry to bring that one up again, but I'm under the impression that the issue about unmodifiable collections (https://github.com/FasterXML/jackson-databind/issues/1880) is still not solved completely.\r\n\r\nIn fact, the way the `CLASS_UNMODIFIABLE_LIST` is retrieved [here](https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java#L52) yields `Collections$UnmodifiableRandomAccessList`, and therefore only this type is currently supported by Jackson 2.9.8.\r\n\r\nHowever, using `Collections.unmodifiableList()` on a `List` implementation that doesn't implement `RandomAccess` will yield a `Collections$UnmodifiableList` instead, which is not deserialized properly and fails with:\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `java.util.Collections$UnmodifiableList` (no Creators, like default constructor, exist): no default no-arguments constructor found\r\n```\r\n\r\nThis can be reproduced by adding the following test case in `TestDefaultForUtilCollections1868`:\r\n```java\r\npublic void testUnmodifiableNonRandomAccessList() throws Exception {\r\n   _verifyCollection(Collections.unmodifiableList(new LinkedList<>(Arrays.asList(\"first\", \"second\"))));\r\n}\r\n```\r\n\r\nOr more generally for outside the project:\r\n```java\r\npublic void testUnmodifiableNonRandomAccessList() throws Exception {\r\n    Collection<?> exp = Collections.unmodifiableList(new LinkedList<>(Arrays.asList(\"first\", \"second\")));\r\n    ObjectMapper mapper = new ObjectMapper();\r\n    mapper.enableDefaultTyping(DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\r\n    String json = mapper.writeValueAsString(exp);\r\n    Collection<?> act = mapper.readValue(json, Collection.class);\r\n\r\n    assertEquals(exp, act);\r\n    assertEquals(exp.getClass(), act.getClass());\r\n}\r\n```\r\n\r\nCurrently `java.util.Collections.unmodifiableList()` can only return these 2 types of unmodifiable lists, so I believe it is safe for now to just hardcode yet another special case for this class.\r\n\r\nThis can currently be solved on user side by adding a mixin, but since `Collections$UnmodifiableRandomAccessList` is supported, I would find it natural to also support the non-random access variant.\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_111": {
    "description": "Deserialize null, when java type is \"TypeRef of TypeRef of T\", does not provide \"Type(Type(null))\"\n**Dependency**\r\n\r\n    jackson = '2.9.7'\r\n    compile \"com.fasterxml.jackson.core:jackson-databind:$jackson\"\r\n\r\n**Short explanation**\r\n\r\nIn Kotlin, I got an issue when I deserialize the value in the context of a reference type that include another reference type. I provide here a reproduction scenario in Java based on AtomicReference (I don't think there is a real use-case that use an AR of AR of Integer, but with a kind of DSL, it may happen to have a similar inclusion...)\r\n\r\nSo, when we deserialize an 22, we get an AR of AR of 22 as expected. But when we deserialize the null value, we get an AR of null (instead of AR of AR of null).\r\n\r\nI think there is 2 issues:\r\n\r\n(1) the getNull method of AtomicReference always returns \"new AtomicReference()\". I think it should be smarter and use contextual information such fullType or simply call _valueDeserializer.getNull() -- but _valueDeserializer was null during my tests because of (2).\r\n\r\n(2) the bean propertyCreator has distinct deserializer and nullProvider. In the case of ReferenceTypeDeserializer, a new contextual deserializer is created, which is able to deserialize its content. Then the deserializer of the bean propertyCreator is updated, but not its nullProvider\r\n\r\n**To reproduce**\r\n\r\n    class MyBean {\r\n        private AtomicReference<AtomicReference<Integer>> refRef;\r\n        public AtomicReference<AtomicReference<Integer>> getRefRef() {\r\n            return refRef;\r\n        }\r\n        public void setRefRef(AtomicReference<AtomicReference<Integer>> refRef) {\r\n            this.refRef = refRef;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    void myTest() throws IOException {\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        ObjectReader objectReader = objectMapper.readerFor(MyBean.class);\r\n\r\n        MyBean intRef = objectReader.readValue(\" {\\\"refRef\\\": 2 } \");\r\n        Assertions.assertNotNull(intRef.refRef); // succeeds\r\n        Assertions.assertNotNull(intRef.refRef.get()); // succeeds\r\n        Assertions.assertEquals(intRef.refRef.get().get(), new Integer(2)); // succeeds\r\n\r\n        MyBean nullRef = objectReader.readValue(\" {\\\"refRef\\\": null } \");\r\n        Assertions.assertNotNull(intRef.refRef); // succeeds\r\n        Assertions.assertNotNull(intRef.refRef.get()); // fails\r\n        Assertions.assertNull(intRef.refRef.get().get()); // fails\r\n    }\r\n\r\n\n",
    "desc_source": "github_issue"
  },
  "JacksonDatabind_112": {
    "description": "`StringCollectionDeserializer` fails with custom collection\nSeeing this with Jackson 2.9.8.\r\n\r\nWe have a custom collection implementation, which is wired to use its \"immutable\" version for deserialization. The rationale is that we don't want accidental modifications to the data structures that come from the wire, so they all are forced to be immutable.\r\n\r\nAfter upgrade from 2.6.3 to 2.9.8, the deserialization started breaking with the message:\r\n\r\n>Cannot construct instance of `XXX` (although at least one Creator exists): no default no-arguments constructor found\r\n\r\n\r\nThis happens ONLY when you deserialize a custom collection of strings as a property of the other object. Deserializing the custom collection of strings directly works fine, and so does the deserialization of custom collection of non-strings. I believe either the `StringCollectionDeserializer` should not be invoked for custom collections, or perhaps it does not handle the delegation as expected.\r\n\r\nPlease see comments for repro and workaround.\r\n\r\nThanks!\n",
    "desc_source": "github_issue"
  }
}