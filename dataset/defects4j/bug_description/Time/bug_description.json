{
  "Time_1": {
    "description": "Partial.with fails with NPE\nWith the latest master:\n\n``` java\nnew Partial(yearOfCentury(),  1).with(weekyear(), 1);\n// NullPointerException\n// org.joda.time.Partial.with (Partial.java:447)\n```\n\nFails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.\n\n",
    "desc_source": "github_issue"
  },
  "Time_2": {
    "description": "Partial.with fails with NPE\nWith the latest master:\n\n``` java\nnew Partial(yearOfCentury(),  1).with(weekyear(), 1);\n// NullPointerException\n// org.joda.time.Partial.with (Partial.java:447)\n```\n\nFails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.\n\n",
    "desc_source": "github_issue"
  },
  "Time_3": {
    "description": "addDays(0) changes value of MutableDateTime\nUpon DST transition from summer to winter time zone, adding the amount of zero days to a mutable date time object changes the value of the object.\n\nThe code\n\n``` java\nfinal MutableDateTime mdt = new MutableDateTime(2011, 10, 30, 3, 0, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\nSystem.out.println(\"Start date:   \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt.addHours(-1);\nSystem.out.println(\"addHours(-1): \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt.addHours(0);\nSystem.out.println(\"addHours(0):  \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\nmdt.addDays(0);\nSystem.out.println(\"addDays(0):   \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\n```\n\nprints\n\n```\nStart date:   2011-10-30T03:00:00.000+01:00 (1319940000000)    //OK\naddHours(-1): 2011-10-30T02:00:00.000+01:00 (1319936400000)    //OK\naddHours(0):  2011-10-30T02:00:00.000+01:00 (1319936400000)    //OK, no change in time\naddDays(0):   2011-10-30T02:00:00.000+02:00 (1319932800000)    //error, time has changed by 1 hour\n```\n\nThe methods addMonths and addYears show the same problem; addSeconds, addMinutes and addHours are ok.\n\nI have tested with version 2.3. However, if I repeat the test with Joda 1.5.2, the invocation of addDays(0) does not change the date's value.\n\n",
    "desc_source": "github_issue"
  },
  "Time_4": {
    "description": "Constructing invalid Partials\nPartials can be constructed by invoking a constructor `Partial(DateTimeFieldType[], int[])` or by merging together a set of partials using `with`, each constructed by calling `Partial(DateTimeFieldType, int)`, e.g.:\n\n``` java\nPartial a = new Partial(new DateTimeFieldType[] { year(), hourOfDay() }, new int[] { 1, 1});\nPartial b = new Partial(year(), 1).with(hourOfDay(), 1);\nassert(a == b);\n```\n\nHowever, the above doesn't work in all cases:\n\n``` java\nnew Partial(new DateTimeFieldType[] { clockhourOfDay(), hourOfDay() }, new int[] { 1, 1}); // throws Types array must not contain duplicate\nnew Partial(clockhourOfDay(), 1).with(hourOfDay(), 1); // #<Partial [clockhourOfDay=1, hourOfDay=1]>\n```\n\nI suppose the Partials should not allow to be constructed in either case. Is that right?\n\nThere's also a related issue (probably stems from the fact that the Partial is invalid):\n\n``` java\nnew Partial(clockhourOfDay(), 1).with(hourOfDay(), 1).isEqual(new Partial(hourOfDay() ,1).with(clockhourOfDay(), 1)) // throws objects must have matching field types\n```\n\n",
    "desc_source": "github_issue"
  },
  "Time_5": {
    "description": "none standard PeriodType without year throws exception\nHi.\n\nI tried to get a Period only for months and weeks with following code:\n\n``` Java\nPeriod p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.forFields(new DurationFieldType[]{DurationFieldType.months(), DurationFieldType.weeks()})).normalizedStandard(PeriodType.forFields(new DurationFieldType[]{DurationFieldType.months(), DurationFieldType.weeks()}));\nreturn p.getMonths();\n```\n\nThis throws following exception:\n\n```\n 10-17 14:35:50.999: E/AndroidRuntime(1350): java.lang.UnsupportedOperationException: Field is not supported\n 10-17 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.PeriodType.setIndexedField(PeriodType.java:690)\n 10-17 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.Period.withYears(Period.java:896) 10-17\n 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.Period.normalizedStandard(Period.java:1630)\n```\n\nEven removing the year component with .withYearsRemoved() throws the same exception:\n\nthis works:\n\n``` Java\nPeriod p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.standard()).normalizedStandard(PeriodType.standard());\nreturn p.getMonths();\n```\n\nthis fails:\n\n``` Java\nPeriod p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.standard().withYearsRemoved()).normalizedStandard(PeriodType.standard().withYearsRemoved());\nreturn p.getMonths();\n```\n\n",
    "desc_source": "github_issue"
  },
  "Time_6": {
    "description": "Questionable behaviour of GJChronology when dates pass 1BC\nI expect the following test to pass:\n\n```\nChronology chronology = GJChronology.getInstance();\n\nLocalDate start = new LocalDate(2013, 5, 31, chronology);\nLocalDate expectedEnd = new LocalDate(-1, 5, 31, chronology); // 1 BC\nassertThat(start.minusYears(2013), is(equalTo(expectedEnd)));\nassertThat(start.plus(Period.years(-2013)), is(equalTo(expectedEnd)));\n```\n\nThe error it gives is:\n\n```\norg.joda.time.IllegalFieldValueException: Value 0 for year is not supported\n```\n\nHowever, I never provided \"0\" for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?\n\n",
    "desc_source": "github_issue"
  },
  "Time_7": {
    "description": "DateTimeFormat.parseInto sometimes miscalculates year (2.2)\nThere appears to be a bug in the fix to http://sourceforge.net/p/joda-time/bugs/148 (which I also reported).\n\nThe following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999:\n\n``` java\n    public void testParseInto_monthDay_feb29_startOfYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2000, 1, 1, 0, 0, 0, 0, NEWYORK);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0));\n        assertEquals(new MutableDateTime(2000, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n    }\n```\n\n",
    "desc_source": "github_issue"
  },
  "Time_8": {
    "description": "DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hour\n`DateTimeZone.forOffsetHoursMinutes(h,m)` cannot handle negative offset < 1 hour like `-0:30` due to argument range checking. I used `forOffsetMillis()` instead.\n\nThis should probably be mentioned in the documentation or negative minutes be accepted.\n\n",
    "desc_source": "github_issue"
  },
  "Time_9": {
    "description": "Ensure there is a max/min valid offset\n`DateTimeZone` does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.\n\n",
    "desc_source": "github_issue"
  },
  "Time_10": {
    "description": "Days#daysBetween throw exception for MonthDay with 29 February\nfinal LocalDate january12012 = new LocalDate(2012, 1,1);\nfinal LocalDate february292012 = new LocalDate(2012, 2, 29);\n// OK\nassertEquals(59, Days.daysBetween(january12012, february292012).getDays());\n\nfinal MonthDay january1 = new MonthDay(1,1);\nfinal MonthDay february29 = new MonthDay(2, 29);\n// FAIL\nassertEquals(59, Days.daysBetween(january1, february29).getDays());\n\norg.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:217)\n    at org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\n    at org.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)\n    at org.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:103)\n    at org.joda.time.Days.daysBetween(Days.java:141)\n\nIs there a way to avoid this happening? I understand fiddling around with the leap year, you're bound to get issues.\n\nThanks! \n\n",
    "desc_source": "github_issue"
  },
  "Time_11": {
    "description": "NPE in DateTimeZoneBuilder\nWhen a DateTimeZone is build with duplicate-named 'recurring saving time' in a first thread, all goes Ok: a warning message is generated and an identifier is automatically generated in PrecalculatedZone.create(). When a second thread does the same, an NPE is generated in ZoneInfoCompiler.verbose().\n\nThe cause is that the cVerbose ThreadLocal is incorrectly initialized in ZoneInfoCompiler:\n\n``` java\n   static {\n        cVerbose.set(Boolean.FALSE);\n    }\n```\n\n...will initialize cVerbose only for the first thread and not for the subsequent ones. The NPE is caused by the autoboxing in:\n\n``` java\n   public static boolean verbose() {\n        return cVerbose.get();\n    }\n```\n\nA better approach could be to remove the initialization and test for null:\n\n``` java\npublic static boolean verbose(){\n    Boolean verbose = cVerbose.get();\n    return (verbose != null) ? verbose : false;\n}\n```\n\n---\n\nHere follows a test case:\n\n``` java\n    @Test\n    public void testDateTimeZoneBuilder() throws Exception {\n        getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ1\", true);\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ2\", true);\n            }\n        });\n        t.start();\n        t.join();\n    }\n\n    private DateTimeZoneBuilder getTestDataTimeZoneBuilder() {\n         return new DateTimeZoneBuilder()\n         .addCutover(1601, 'w', 1, 1, 1, false, 7200000)\n         .setStandardOffset(3600000)\n         .addRecurringSavings(\"\", 3600000, 1601, Integer.MAX_VALUE, 'w', 3, -1, 1, false, 7200000)\n         .addRecurringSavings(\"\", 0, 1601, Integer.MAX_VALUE, 'w', 10, -1, 1, false, 10800000);\n    }\n```\n\n",
    "desc_source": "github_issue"
  },
  "Time_12": {
    "description": "Check Calendar.ERA in LocalDate.fromCalendarFields\n\n",
    "desc_source": "github_issue"
  },
  "Time_13": {
    "description": "#160 Negative millis display incorrectly in Period.toString\nThis code:\nimport org.joda.time.Duration;\nimport org.joda.time.Period;\npublic class A {\n  public static void main(String[] args) {\n    System.out.println(\"new Duration(-1000).getMillis() = \" + new Duration(-1000).getMillis());\n    System.out.println(\"new Duration(-1000).toString()  = \" + new Duration(-1000).toString());\n    System.out.println(\"new Period(-1000).getSeconds()  = \" + new Period(-1000).getSeconds());\n    System.out.println(\"new Period(-1000).toString()    = \" + new Period(-1000).toString());\n    System.out.println(\"new Duration(-100).getMillis()  = \" + new Duration(-100).getMillis());\n    System.out.println(\"new Duration(-100).toString()   = \" + new Duration(-100).toString());\n    System.out.println(\"new Period(-100).getMillis()    = \" + new Period(-100).getMillis());\n    System.out.println(\"new Period(-100).toString()     = \" + new Period(-100).toString());\n  }\n}\nProduces output:\nnew Duration(-1000).getMillis() = -1000\nnew Duration(-1000).toString()  = PT-1S\nnew Period(-1000).getSeconds()  = -1\nnew Period(-1000).toString()    = PT-1S\nnew Duration(-100).getMillis()  = -100\nnew Duration(-100).toString()   = PT-0.100S\nnew Period(-100).getMillis()    = -100\nnew Period(-100).toString()     = PT0.100S\nThe last line should produce \"PT-0.100S\" instead of \"PT0.100S\".",
    "desc_source": "sourceforge"
  },
  "Time_14": {
    "description": "#151 Unable to add days to a MonthDay set to the ISO leap date\nIt's not possible to add days to a MonthDay set to the ISO leap date (February 29th).  This is even more bizarre given the exact error message thrown.\nSample snippet:\nfinal MonthDay isoLeap = new MonthDay(DateTimeConstants.FEBRUARY, 29, ISOChronology.getInstanceUTC());\nSystem.out.println(isoLeap);\nSystem.out.println(isoLeap.plusDays(2));\n\nWhich generates the following combined console output and stack trace:  \n--02-29\nException in thread \"main\" org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\n    at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:215)\n    at org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\n    at org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(BasicMonthOfYearDateTimeField.java:212)\n    at org.joda.time.field.BaseDateTimeField.add(BaseDateTimeField.java:324)\n    at org.joda.time.MonthDay.withFieldAdded(MonthDay.java:519)\n    at org.joda.time.MonthDay.minusDays(MonthDay.java:672)\n    at ext.site.time.chrono.Main.m7(Main.java:191)\n    at ext.site.time.chrono.Main.main(Main.java:27)\nThe follwing method calls and parameters also generate the same or related error:  \nisoLeap.plusMonths(1);\nisoLeap.plusMonths(-1);\nisoLeap.minusMonths(1);\nisoLeap.minusMonths(-1);\nisoLeap.minusDays(-1);\n\nHowever, the following methods work:  \nisoLeap.minusDays(1);\nisoLeap.plusDays(-1);\n\nPerforming operations on dates around the ISO leap date react as if it exists, ie:\nSystem.out.println(isoLeap.minusDays(1).plusDays(2));\n\nPrints out '--03-01' as expected.",
    "desc_source": "sourceforge"
  },
  "Time_15": {
    "description": "#147 possibly a bug in org.joda.time.field.FieldUtils.safeMultipl\nIt seems to me that as currently written in joda-time-2.1.jar\norg.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar)\ndoesn't detect the overflow if the long val1 == Long.MIN_VALUE and the int scalar == -1.\nThe attached file demonstrates what I think is the bug and suggests a patch.\nI looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant: my apologies if I've missed something, or if I'm making a mistake with this bug report.\nColin Bartlett",
    "desc_source": "sourceforge"
  },
  "Time_16": {
    "description": "#148 DateTimeFormatter.parseInto broken when no year in format\nIn Joda Time 2.0, the default year was set to 2000 so that Feb 29 could be parsed correctly. However, parseInto now overwrites the given instant's year with 2000 (or whatever iDefaultYear is set to). The correct behavior would seem to be to use the given instant's year instead of iDefaultYear.\nThis does mean that Feb 29 might not be parseable if the instant's year is not a leap year, but in this case the caller asked for that in a sense.",
    "desc_source": "sourceforge"
  },
  "Time_17": {
    "description": "#141 Bug on withLaterOffsetAtOverlap method\nThe method withLaterOffsetAtOverlap created to workaround the issue 3192457 seems to not be working at all.\nI won\u00b4t write many info about the problem to solve because the issue 3192457  have this info indeed.\nBut If something is unclear I can answer on the comments.\nProblem demonstration:\n    TimeZone.setDefault(TimeZone.getTimeZone(\"America/Sao_Paulo\"));\n        DateTimeZone.setDefault( DateTimeZone.forID(\"America/Sao_Paulo\") );\n    DateTime dtch;\n    {\n        dtch = new DateTime(2012,2,25,5,5,5,5).millisOfDay().withMaximumValue();\n        System.out.println( dtch ); // prints: 2012-02-25T23:59:59.999-02:00 //Were are at the first 23:** of the day.\n        //At this point dtch have the -03:00 offset\n    }\n    {\n        dtch = dtch.plus(60001);\n        System.out.println( dtch ); // prints: 2012-02-25T23:01:00.000-03:00 //Were are at the first minute of the second 23:** of the day. Ok its correct\n        //At this point dtch have the -03:00 offset\n    }\n    {\n        dtch = dtch.withEarlierOffsetAtOverlap();\n        System.out.println( dtch ); // prints: 2012-02-25T23:01:00.000-02:00 //Were are at the first minute of the first 23:** of the day. Ok its correct\n        //At this point dtch have the -02:00 offset ( because we called withEarlierOffsetAtOverlap() ) // This method is working perfectly\n    }       \n    {\n        dtch = dtch.withLaterOffsetAtOverlap();\n        System.out.println( dtch ); // prints: 2012-02-25T23:01:00.000-02:00 //Were are at the first minute of the first 23:** of the day. \n        // Here is the problem we should have a -03:00 offset here since we called withLaterOffsetAtOverlap() expecting to change to the second 23:** of the day\n    }\n\nOn the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all )",
    "desc_source": "sourceforge"
  },
  "Time_18": {
    "description": "#130 GJChronology rejects valid Julian dates\nExample:\nDateTime jdt  = new DateTime(1500, 2, 29, 0, 0, 0, 0, JulianChronology.getInstanceUTC());   // Valid.\nDateTime gjdt = new DateTime(1500, 2, 29, 0, 0, 0, 0, GJChronology.getInstanceUTC());       // Invalid.\nThe 2nd statement fails with \"org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\".\nGiven that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?",
    "desc_source": "sourceforge"
  },
  "Time_19": {
    "description": "#124 Inconsistent interpretation of ambiguous time during DST\nThe inconsistency appears for timezone Europe/London.\nConsider the following code\n\u2026\n        DateTime britishDate    = new DateTime(2011, 10, 30, 1, 59, 0, 0, DateTimeZone.forID(\"Europe/London\"));\n        DateTime norwDate       = new DateTime(2011, 10, 30, 2, 59, 0, 0, DateTimeZone.forID(\"Europe/Oslo\"));\n        DateTime finnishDate    = new DateTime(2011, 10, 30, 3, 59, 0, 0, DateTimeZone.forID(\"Europe/Helsinki\"));\n    System.out.println(britishDate);\n    System.out.println(norwDate);\n    System.out.println(finnishDate);\n\n\u2026\nThese three DateTime objects should all represent the same moment in time even if they are ambiguous. And using jodatime 1.6.2 this is the case. The code produces the following output:\n2011-10-30T01:59:00.000Z\n2011-10-30T02:59:00.000+01:00\n2011-10-30T03:59:00.000+02:00\nUsing jodatime 2.0 however, the output is:\n2011-10-30T01:59:00.000Z\n2011-10-30T02:59:00.000+02:00\n2011-10-30T03:59:00.000+03:00\nwhich IMO is wrong for Europe/London. Correct output should have been \n2011-10-30T01:59:00.000+01:00\nThe release notes for 2.0 states that: \n\"Now, it always returns the earlier instant (summer time) during an overlap. \u2026\"",
    "desc_source": "sourceforge"
  },
  "Time_20": {
    "description": "#126 Errors creating/parsing dates with specific time zones.\nConsider the following test code using Joda 2.0\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport java.util.Set;\npublic class JodaDateTimeZoneTester {\nprivate static DateTimeFormatter formatter = DateTimeFormat.forPattern(\"MM/dd/yyyy HH:mm:ss.SSS ZZZ\");\nprivate static int numTimeZonesTested = 0;\nprivate static int numTimeZonesPassed = 0;\nprivate static int numTimeZonesFailed = 0;\nprivate static int numTimeZonesException = 0;\n\nprivate static String convertDateTimeToFormattedString(DateTime dateTime) {\n    return formatter.print(dateTime);\n}\n\nprivate static DateTime parseStringToDateTime(String formattedDateTime) {\n    return formatter.parseDateTime(formattedDateTime);\n}\n\nprivate static void testDateTimeFormatter(DateTime dateTime, String timeZone) {\n    numTimeZonesTested++;\n\n    final String dateTimeZoneId = dateTime.getZone().getID();\n\n    if (!timeZone.equals(dateTimeZoneId)) {\n        numTimeZonesFailed++;\n        System.out.println(timeZone + \" failed to construct into the proper date time zone - constructed time zone = \" + dateTimeZoneId);\n        return;\n    }\n    try {\n        DateTime convertedDateTime = parseStringToDateTime(convertDateTimeToFormattedString(dateTime));\n\n        if (dateTime.equals(convertedDateTime)) {\n            numTimeZonesPassed++;\n            //System.out.println(dateTime.getZone().getID() + \" passed.\");\n        } else {\n            numTimeZonesFailed++;\n            System.out.println(\"Formatter failed for time zone ID: \" + dateTimeZoneId + \"    converted it to: \" + convertedDateTime.getZone().getID());\n        }\n    } catch (IllegalArgumentException iae) {\n        numTimeZonesException++;\n        System.out.println(\"Formatter threw exception for time zone id: \" + dateTimeZoneId);\n    }\n}\n\npublic static void main(String[] args) {\n    Set<String> timeZones = DateTimeZone.getAvailableIDs();\n\n    for (String timeZone : timeZones) {\n        testDateTimeFormatter(DateTime.now().withZone(DateTimeZone.forID(timeZone)), timeZone);\n    }\n\n    System.out.println();\n    System.out.println(\"Number of Time Zones tested: \" + numTimeZonesTested);\n    System.out.println(\"Number passed:     \" + numTimeZonesPassed);\n    System.out.println(\"Number failed:     \" + numTimeZonesFailed);\n    System.out.println(\"Number exceptions: \" + numTimeZonesException);\n    System.out.println();\n}\n\n}\nThe results are out of 572 time zones 130 fail and 30 throw exceptions. \nThe failures are the most interesting.  When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka.  When I take that id and create a date time with it its time zone id is America/Adak.  It is like there are multiple list of time zones in Joda time and they are out of sync. \nSource code is attached.",
    "desc_source": "sourceforge"
  },
  "Time_22": {
    "description": "#113 Duration.toPeriod with fixed time zones.\nI have a question concerning the conversion of a Duration to Period.  I'm not sure if this is a bug, or if there is a different way to do this.\nThe basis of the problem, is that using Duration.toPeriod() uses the chronology of the default time zone to do the conversion.  This can cause different results from a timezone with DST and one without.  This can be reproduced easily with this test.\n//set default time zone with this argument -Duser.timezone=\"GMT\"\npublic void testForJodaForum()\n{\n    System.out.println(\"Timezone: \" + DateTimeZone.getDefault());\n\n    //Duration of more than 24 hours\n    Duration aDuration = new Duration(DateTimeConstants.MILLIS_PER_HOUR * 30 + DateTimeConstants.MILLIS_PER_MINUTE * 50\n        + DateTimeConstants.MILLIS_PER_SECOND * 14);\n\n    System.out.println(\"Duration before: \" + aDuration);\n    Period period = aDuration.toPeriod();\n    System.out.println(\"Period after: \" + period);        \n}\n\nA fixed time zone produces this output\nTimezone: Etc/GMT\nDuration before: PT111014S\nPeriod after: P1DT6H50M14S\nA DST time zone produces this output\nTimezone: America/Chicago\nDuration before: PT111014S\nPeriod after: PT30H50M14S\nIn the joda code, Duration.toPeriod() uses a period constructor that takes the chronology, but null is passed in, so the chronology of the default time zone is used, which leads to this behavior.\nThe javadoc of toPeriod() states that only precise fields of hours, minutes, seconds, and millis will be converted.  But for a fixed timezone, days and weeks are also precise, which is stated in the javadoc for toPeriod(Chronology chrono).  In our app, we need consistent behavior regardless of the default time zone, which is to have all the extra hours put into the hours bucket.  Since Duration is supposed to be a 'time zone independent' length of time, I don't think we should have to do any chronology manipulation to get this to work.\nAny help is appreciated.\nThanks,\nCameron",
    "desc_source": "sourceforge"
  },
  "Time_23": {
    "description": "#112 Incorrect mapping of the MET time zone\nThis timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time.\nI know that this bug has been raised before (Incorrect mapping of the MET time zone - ID: 2012274), and there is a comment stating that you won't break backward compatibility to fix this bug.\n\nI disagree that this is a backward compatibility argument\nNo matter how you look at it, it is a bug.\n\nYou could very well state that ALL bugs won't be fixed, because of backward compatibility.\nI request again that this bug be fixed.",
    "desc_source": "sourceforge"
  },
  "Time_24": {
    "description": "#107 Incorrect date parsed when week and month used together\nI have following code snippet :\n    DateTimeFormatter dtf = DateTimeFormat.forPattern(\"xxxxMM'w'ww\");\nDateTime dt = dtf.parseDateTime(\"201101w01\");       \nSystem.out.println(dt);\n\nIt should print 2011-01-03 but it is printing 2010-01-04. \nPlease let me know if I am doing something wrong here.",
    "desc_source": "sourceforge"
  },
  "Time_25": {
    "description": "#90 DateTimeZone.getOffsetFromLocal error during DST transition\nThis may be a failure of my understanding, but the comments in DateTimeZone.getOffsetFromLocal lead me to believe that if an ambiguous local time is given, the offset corresponding to the later of the two possible UTC instants will be returned - i.e. the greater offset.\nThis doesn't appear to tally with my experience. In fall 2009, America/Los_Angeles changed from -7 to -8 at 2am wall time on November 11. Thus 2am became 1am - so 1:30am is ambiguous. I would therefore expect that constructing a DateTime for November 11th, 1:30am would give an instant corresponding with the later value (i.e. 9:30am UTC). This appears not to be the case:\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeZone;\npublic class TzTest {\n    public static void main(String[] args) throws Exception {\n        DateTimeZone zone = DateTimeZone.forID(\"America/Los_Angeles\");\n        DateTime when1 = new DateTime(2009, 11, 1, 0, 30, 0, 0, zone);\n        DateTime when2 = new DateTime(2009, 11, 1, 1, 30, 0, 0, zone);\n        DateTime when3 = new DateTime(2009, 11, 1, 2, 30, 0, 0, zone);\n        System.out.println(when1);\n        System.out.println(when2);\n        System.out.println(when3);\n    }\n}\nResults:\n2009-11-01T00:30:00.000-07:00 // Correct\n2009-11-01T01:30:00.000-07:00 // Should be -08:00\n2009-11-01T02:30:00.000-08:00 // Correct",
    "desc_source": "sourceforge"
  },
  "Time_26": {
    "description": "#60 .withHourOfDay() sets hour inconsistantly on DST transition.\nWhen the hour of day is set to the ambiguous hour on the daylight to\nstandard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the\ndaylight hour or the standard hour for all time zones? I can't find anything\nthat documents this behavior.\nMy test code below returns different results for different time zones.\n/*\n* Verify Joda converts the hour of day the same for regions north and\nsouth of the equator on the DST\n* daylight to standard time transition.\n/\n@Test\npublic void jodaTest ()\n{\nChronology chronUTC =\nGregorianChronology.getInstance(DateTimeZone.UTC);\nDateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0,\n0, chronUTC);\nDateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0,\n0, chronUTC);\nChronology chronUSCentral =\nGregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\nAssert.assertTrue(\"Should be standard time\",\nchronUSCentral.getZone().isStandardOffset(\nusCentralStandardInUTC.getMillis()));\nAssert.assertFalse(\"Should be daylight time\",\nchronUSCentral.getZone().isStandardOffset(\nusCentralDaylightInUTC.getMillis()));\nDateTime usCentralStandardInUSCentral =\nusCentralStandardInUTC.toDateTime(chronUSCentral);\nDateTime usCentralDaylightInUSCentral =\nusCentralDaylightInUTC.toDateTime(chronUSCentral);\nassertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\nassertEquals(usCentralStandardInUSCentral.getHourOfDay(),\nusCentralDaylightInUSCentral.getHourOfDay());\nAssert.assertTrue(usCentralStandardInUSCentral.getMillis() !=\nusCentralDaylightInUSCentral.getMillis());\nDateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0,\n0, 0, chronUTC);\nDateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0,\n0, 0, chronUTC);\nChronology chronAusNSW =\nGregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\nAssert.assertTrue(\"Should be standard time\",\nchronAusNSW.getZone().isStandardOffset(\naustraliaNSWStandardInUTC.getMillis()));\nAssert.assertFalse(\"Should be daylight time\",\nchronAusNSW.getZone().isStandardOffset(\naustraliaNSWDaylightInUTC.getMillis()));\nDateTime australiaNSWStandardInAustraliaNSW =\naustraliaNSWStandardInUTC.toDateTime(chronAusNSW);\nDateTime australiaNSWDaylightInAusraliaNSW =\naustraliaNSWDaylightInUTC.toDateTime(chronAusNSW);\nassertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\nassertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(),\naustraliaNSWDaylightInAusraliaNSW.getHourOfDay());\nAssert.assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() !=\naustraliaNSWDaylightInAusraliaNSW.getMillis());\n// Verify that setting the hour of day on the DST boundary results\nin a daylight time for\n// both time zones.\nassertEquals(usCentralDaylightInUSCentral,\nusCentralStandardInUSCentral.withHourOfDay(1));\nassertEquals(australiaNSWDaylightInAusraliaNSW,\naustraliaNSWStandardInAustraliaNSW.withHourOfDay(2));\n}\nThe very last assertion fails on the Australia time zone cutover.\njava.lang.AssertionError: expected:<2008-04-06T02:00:00.000+11:00> but\nwas:<2008-04-06T02:00:00.000+10:00>",
    "desc_source": "sourceforge"
  },
  "Time_27": {
    "description": "#64 Different behaviour of PeriodFormatter\nPeriodFormatter pfmt2 = pfmtbuilder2.append(ISOPeriodFormat.standard() ).toFormatter(); is not the same as \nPeriodFormatterBuilder pfmtbuilder1 = new PeriodFormatterBuilder()\n        .appendLiteral(\"P\")\n        .appendYears()\n        .appendSuffix(\"Y\")\n        .appendMonths()\n        .appendSuffix(\"M\")\n        .appendWeeks()\n        .appendSuffix(\"W\")\n        .appendDays()\n        .appendSuffix(\"D\")\n        .appendSeparatorIfFieldsAfter(\"T\")\n        .appendHours()\n        .appendSuffix(\"H\")\n        .appendMinutes()\n        .appendSuffix(\"M\")\n        .appendSecondsWithOptionalMillis()\n        .appendSuffix(\"S\");\nwhich is copied from ISOPeriodFormat.standard() method",
    "desc_source": "sourceforge"
  }
}