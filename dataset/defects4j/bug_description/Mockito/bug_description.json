{
  "Mockito_1": {
    "description": "ArgumentCaptor no longer working for varargs\nI ran into the issue described here: http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_2": {
    "description": "Mockito.after() method accepts negative timeperiods and subsequent verifications always pass\ne.g.\n\n```\nRunnable runnable = Mockito.mock(Runnable.class);\nMockito.verify(runnable, Mockito.never()).run(); // passes as expected\nMockito.verify(runnable, Mockito.after(1000).never()).run(); // passes as expected\nMockito.verify(runnable, Mockito.after(-1000).atLeastOnce()).run(); // passes incorrectly\n```\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_3": {
    "description": "ArgumentCaptor no longer working for varargs\nI ran into the issue described here: http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_4": {
    "description": "java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String\nException throws on verifyZeroInteractions when using mock with default answer.\nchecked on versions 1.10.5-2.0.5\nall ok on 1.9.5\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_5": {
    "description": "Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError)\nIf JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a `VerifyError` or a `NoClassDefFoundError`.\n\nThis issue has been reported on the [mailing list](https://groups.google.com/forum/#!topic/mockito/A6D7myKiD5k) and on [StackOverflow](http://stackoverflow.com/questions/27721621/java-lang-verifyerror-with-mockito-1-10-17)\n\nA simple test like that with **TestNG** (and no JUnit in the class path of course) exposes the issue:\n\n```\nimport org.testng.annotations.Test;\nimport java.util.Observable;\nimport static org.mockito.Mockito.*;\n\npublic class VerifyErrorOnVerificationWithTimeoutTest {\n    @Test public void should_not_throw_VerifyError() {\n        verify(mock(Observable.class), timeout(500)).countObservers();\n    }\n}\n```\n\nWith TestNG 5.13.1, the stack trace is :\n\n```\njava.lang.VerifyError: (class: org/mockito/internal/verification/VerificationOverTimeImpl, method: verify signature: (Lorg/mockito/internal/verification/api/VerificationData;)V) Incompatible argument to function\n    at org.mockito.verification.Timeout.<init>(Timeout.java:32)\n    at org.mockito.verification.Timeout.<init>(Timeout.java:25)\n    at org.mockito.Mockito.timeout(Mockito.java:2103)\n    at com.example.UserServiceImplTest.test(UserServiceImplTest.java:26)\n```\n\nTestNG includes a dependency on JUnit 3.8.1, which has the `junit.framework.ComparisonFailure`, but the JVM cannot perform the linking at runtime (`VerifyError` extends `LinkageError`), probably because for the JVM there's some incompatible changes in this class between version 3.x and 4.x.\nNote that Mockito is compiled against JUnit 4.x. This also reveal that Mockito is not anymore compatible with JUnit 3.x.\n\nWith TestNG 6.8.13, the stack trace is :\n\n```\njava.lang.NoClassDefFoundError: junit/framework/ComparisonFailure\n    at java.lang.ClassLoader.defineClass1(Native Method)\n    at java.lang.ClassLoader.defineClassCond(ClassLoader.java:637)\n    at java.lang.ClassLoader.defineClass(ClassLoader.java:621)\n    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)\n    at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)\n    at java.net.URLClassLoader.access$000(URLClassLoader.java:58)\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:197)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n    at org.mockito.verification.Timeout.<init>(Timeout.java:32)\n    at org.mockito.verification.Timeout.<init>(Timeout.java:25)\n    at org.mockito.Mockito.timeout(Mockito.java:2103)\n    at com.example.UserServiceImplTest.test(UserServiceImplTest.java:26)\nCaused by: java.lang.ClassNotFoundException: junit.framework.ComparisonFailure\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:202)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n    ... 49 more\n```\n\nIndeed JUnit is not anymore a dependency of TestNG.\n\nIn this specific case the issue is that the `Timeout` class wraps a `VerficationOverTimeImpl` that uses in try/catch block the exception `org.mockito.exceptions.verification.junit.ArgumentsAreDifferent` which extends `junit.framework.ComparisonFailure`.\n\nAt this time it seems to be the only place where JUnit is needed, this affect the following public API : \n\n``` java\nMockito.timeout(...)\nMockito.after(...)\n```\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_6": {
    "description": "Argument matcher anyXxx() (i.e. anyString(), anyList()) should not match nulls\nThis is a bug I'm seeing in 1.10.8 version (older version has the same issue - tested with 1.9.0).\n\nGiven:\n\n``` java\nFunction<Object, Integer> function = Mockito.mock(Function.class);\nwhen(function.apply(Mockito.anyString())).thenReturn(1);\nInteger result = function.apply(2);\n```\n\nExpected behavior:\n\n``` java\nresult == null;\n```\n\nActual behavior:\n\n``` java\nresult == 1;\n```\n\nNote that the function is called with an integer (not a string), and still the mocked function return the value which it should return only when a string is passed. The same works when using anyBoolean() or any other methof from any\\* family.\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_7": {
    "description": "Deep stubbing with generic responses in the call chain is not working\nDeep stubbing will throw an Exception if multiple generics occur in the call chain. For instance, consider having a mock `myMock1` that provides a function that returns a generic `T`. If `T` also has a function that returns a generic, an Exception with the message \"Raw extraction not supported for : 'null'\" will be thrown.\n\nAs an example the following test will throw an Exception:\n\n``` Java\npublic class MockitoGenericsDeepStubTest {\n\n    @Test\n    public void discoverDeepMockingOfGenerics() {\n        MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);\n\n        when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");\n    }\n\n    public static interface MyClass1 <MC2 extends MyClass2> {\n        public MC2 getNested();\n    }\n\n    public static interface MyClass2<MC3 extends MyClass3> {\n        public MC3 getNested();\n    }\n\n    public static interface MyClass3 {\n        public String returnSomething();\n    }\n}\n```\n\nYou can make this test run if you step into the class `ReturnsDeepStubs` and change the method `withSettingsUsing` to return `MockSettings` with `ReturnsDeepStubs` instead of `ReturnsDeepStubsSerializationFallback` as default answer:\n\n``` Java\nprivate MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n    MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n            withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n            : withSettings();\n\n    return propagateSerializationSettings(mockSettings, parentMockSettings)\n            .defaultAnswer(this);\n}\n```\n\nHowever, this breaks other tests and features.\n\nI think, the issue is that further generics are not possible to be mocked by `ReturnsDeepStubsSerializationFallback` since the `GenericMetadataSupport` is \"closed\" at this point.\n\nThanks and kind regards\nTobias\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_8": {
    "description": "1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound\nAdd this to `GenericMetadataSupportTest`:\n\n``` java\n    interface GenericsSelfReference<T extends GenericsSelfReference<T>> {\n        T self();\n    }\n\n    @Test\n    public void typeVariable_of_self_type() {\n        GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod(\"self\", GenericsSelfReference.class));\n\n        assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);\n    }\n```\n\nIt fails on master and 1.10.8 with this:\n\n```\njava.lang.StackOverflowError\n    at sun.reflect.generics.reflectiveObjects.TypeVariableImpl.hashCode(TypeVariableImpl.java:201)\n    at java.util.HashMap.hash(HashMap.java:338)\n    at java.util.HashMap.get(HashMap.java:556)\n    at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:193)\n    at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:196)\n    at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:196)\n```\n\nIt worked on 1.9.5. May be caused by the changes in ab9e9f3 (cc @bric3).\n\n(Also note that while the above interface looks strange, it is commonly used for builder hierarchies, where base class methods want to return this with a more specific type.)\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_9": {
    "description": "Problem spying on abstract classes\nThere's a problem with spying on abstract classes when the real implementation calls out to the abstract method. More details: #121 \n\n",
    "desc_source": "github_issue"
  },
  "Mockito_10": {
    "description": "RETURNS_DEEP_STUBS automatically tries to create serializable mocks\nI am just migrating from mockito 1.9.5 to 1.10.5\n\nThe following code runs fine with version 1.9.5. but breaks now:\n\n``` java\n\n  @Test\n  public void test() {\n    ToBeMocked mock = mock(ToBeMocked.class, RETURNS_DEEP_STUBS);\n    assertThat(mock.getSomething()).isNotNull();\n  }\n\n  public static class ToBeMocked {\n\n    NotSerializableReturnValue field1;\n\n    public ToBeMocked(NotSerializableReturnValue field1) {\n      this.field1 = field1;\n    }\n\n    public NotSerializableReturnValue getSomething() {\n      return field1;\n    }\n  }\n\n  public static class NotSerializableReturnValue {\n\n    String field1 = \"\";\n\n    public NotSerializableReturnValue(String field1) {\n      this.field1 = field1;\n    }\n\n    public String getSomething2() {\n      return field1;\n    }\n  }\n```\n\norg.mockito.exceptions.base.MockitoException: \nYou are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue'\ndo not implement Serializable AND do not have a no-arg constructor.\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_11": {
    "description": "Fixed DelegatingMethod.equals() so that it's easier to extend Mockito by custom verification modes\nCurrently if you create a DelegatingMethod and compare it to itself using .equals() it will show as not equal because the .equals() method expects a java.lang.reflect.Method (without explicitly stating such).  This has a knock on effect on the evaluation of InvocationImpl.equals() which at runtime may be using a DelegatingMethod in its .equals().\n\nI have changed .equals() and .hashCode() in DelegatingMethod to a more appropriate implementation, which can handle both the case where the input object is a DelegatingMethod and where it is a java.lang.reflect.Method.\n\nI ran up against this issue when creating a custom VerificationMode which used InvocationImpl.equals() to check that the appropriate invocation was made.  My comparison failed even though I was comparing two references to the same InvocationImpl instance.\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_12": {
    "description": "@Captor annotation might lead to NPE during autounboxing when capturing primitives\nSay I have a\r\n@Captor ArgumentCaptor&lt;Double&gt; fooCaptor;\r\n\r\nI'd like to have it capture primitive double arguments, but the annotation\r\ngives me an Object captor.\r\n\r\nUnfortunately this also fails in a non-obvious way. I get a\r\nNullPointerException because fooCaptor.capture() returns an Object, which\r\nobviously cannot be unboxed to a double.\r\n\r\nIt might be nice if @Captor had an optional parameter for specifying the\r\nclass. This would make one say the type twice in these cases (curse you,\r\nerasure!), but otherwise one would be forced to remove the @Captor\r\nannotation, which I'd personally consider even more ugly.",
    "desc_source": "google issue"
  },
  "Mockito_13": {
    "description": "make verify() possible if there is inlined different method call on other mock\nTo reproduce, run this as a test case:\r\n\t\r\n\tprivate static interface Foo {void setFoo(String bar);}\r\n\tprivate static interface Bar {String getBar();}\r\n\t\r\n\t@Test\r\n\tpublic void testVerifyFails() throws Exception {\r\n\t\tFoo foo = Mockito.mock(Foo.class);\r\n\t\tBar bar = Mockito.mock(Bar.class);\r\n\t\tbar.getBar();\r\n\t\tverify(foo).setFoo(bar.getBar());\r\n\t}\r\n\r\nThe verify should fail, since setFoo(String) was never called, but it will\r\nsucceed.\r\n\r\nI'm using 1.8 on Linux, JDK 1.6.\r\n\r\nIf you comment out the second-to-last line:\r\n//              bar.getBar();\r\nit will fail, complaining like this:\r\n# Wanted but not invoked:\r\n# bar.getBar();\r\n\r\nSo what seems to be happening is that the mock invocation of getBar(),\r\npassed as the parameter to the setFoo(String) invocation, confuses verify()\r\ninto thinking that it should verify getBar(), rather than setFoo(String).",
    "desc_source": "google issue"
  },
  "Mockito_14": {
    "description": "make verify() possible if there is inlined different method call on other mock\nTo reproduce, run this as a test case:\r\n\t\r\n\tprivate static interface Foo {void setFoo(String bar);}\r\n\tprivate static interface Bar {String getBar();}\r\n\t\r\n\t@Test\r\n\tpublic void testVerifyFails() throws Exception {\r\n\t\tFoo foo = Mockito.mock(Foo.class);\r\n\t\tBar bar = Mockito.mock(Bar.class);\r\n\t\tbar.getBar();\r\n\t\tverify(foo).setFoo(bar.getBar());\r\n\t}\r\n\r\nThe verify should fail, since setFoo(String) was never called, but it will\r\nsucceed.\r\n\r\nI'm using 1.8 on Linux, JDK 1.6.\r\n\r\nIf you comment out the second-to-last line:\r\n//              bar.getBar();\r\nit will fail, complaining like this:\r\n# Wanted but not invoked:\r\n# bar.getBar();\r\n\r\nSo what seems to be happening is that the mock invocation of getBar(),\r\npassed as the parameter to the setFoo(String) invocation, confuses verify()\r\ninto thinking that it should verify getBar(), rather than setFoo(String).",
    "desc_source": "google issue"
  },
  "Mockito_15": {
    "description": "@InjectMocks should carry out their work by the method (and not by field) if available\n@InjectMocks should carry out their work by the method (and not by field) if available\r\n\r\nNow @InjectMocks work in properties and this affects CodeCoberage reports :)",
    "desc_source": "google issue"
  },
  "Mockito_16": {
    "description": "Stubbing mocks that are configured to return mocks yields exception\nExample:\r\n\r\nIMethods mock = mock(IMethods.class, RETURNS_MOCKS);\r\nwhen(mock.objectReturningMethodNoArgs()).thenReturn(null);",
    "desc_source": "google issue"
  },
  "Mockito_17": {
    "description": "User should be able to set serializable and yet configure his own extra interfaces\nExample:\r\n\r\nFoo mock = mock(Foo.class, \r\n  withSettings().serializable().extraInterfaces(Bar.class));",
    "desc_source": "google issue"
  },
  "Mockito_18": {
    "description": "Return empty value for Iterables\nhttp://code.google.com/p/mockito/issues/detail?id=175\n\nI expect an Iterable to be mocked by default with an empty Iterable. I understand from the initial issue this behavior would be introduced in Mockito 2, but beta-8 still returns null.\n\nCould we return null for Iterables ?\n\nShould we have the same behavior for Iterator ?\n\nThanks\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_19": {
    "description": "InjectMocks injects mock into wrong field\nUsing `1.10.19`.\n\nWhen using `@InjectMocks` on some Android `TextView`s, the mock is injected into the wrong field.\n\nWe have two fields, `txtGateView` & `txtNextStep` in a class, and our test mocks out `txtNextStep`, then tried to inject. This field is injected wrong, see screenshot.\n\n![image](https://cloud.githubusercontent.com/assets/1404810/7410003/4f200580-ef2b-11e4-9c39-7a699dc4fefa.png)\n\nFrom our quick testing, the name `txtNextView` doesn't matter, that can be changed. But both `txtGateView` and `txtGateLabel` messed things up. If we mock out both fields, it works correctly.\n\nTestproject: https://github.com/SimenB/emptyandroid\n\nI don't know if it's because it's Android, but it was easiest for me to create a minimal test from existing code.\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_20": {
    "description": "Allow convenient spying on abstract classes\nI posted this in GoogleCode and was asked to submit in github.\n\nMockito is easy to use when the test needs to provide canned values for a certain method.\n\nBut it gets harder when a canned value isn't sufficient.\n##### Example 1: Fake with trivial Logic\n\n```\ninterface UserAccount {\n  List<String> getEmails();\n  void addEmail(String email);\n  // 12 other methods ...\n}\n```\n\nWhen mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.\n##### Example 2: callback-style API\n\n```\ninterface AccountService {\n  void getAccount(String id, AsyncCallback<UserAccount> callback);\n}\n```\n\nStubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:\n\n```\nwhen(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer<Void>() {\n  AsyncCallback<UserAccount> callback = (AsyncCallback<UserAccount>) getArguments()[1];\n  ...\n});\n```\n##### Example 3: Uninteresting parameters\n\n```\ninterface AccountRpcService {\n  FutureAccount getAccount(RpcContext context, String id);\n}\n```\n\nNone of the tests care about the context object. It's an uninteresting parameter imposed by the framework.\n\nIf AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:\n\n`when(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);`\n\nAnd all other parameters are required to be wrapped in eq().\n#### Proposal\n\nI propose adding support for abstract classes to mockito to make it easier to deal with tests like above:\n##### For example 1\n\n```\nabstract class FakeUserAccount implements UserAccount {\n  private final List<String> emails = new ArrayList<>();\n\n  @Override public void addEmail(String email) {\n    emails.add(email);\n  }\n  @Override List<String> getEmails() {\n    return ImmutableList.copyOf(emails);\n  }\n}\n\n@Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n```\n##### For example 2\n\n```\nabstract class MockAccountService implements AccountService {\n  @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {\n    callback.onSuccess(getAccount(id));\n  }\n  abstract UserAccount getAccount(String id);\n}\n\n@Fake private MockAccountService service;\n\n...\n\nwhen(service.getAccount(\"id\")).thenReturn(account);\n```\n##### For example 3\n\n```\nabstract class MockAccountRpcService implements AccountRpcService {\n  @Override Future<Account> getAccount(RpcContext context, String id) {\n    checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n    return getAccount(id);\n  }\n\n  abstract Future<Account> getAccount(String id);\n}\n\n@Fake private MockAccountRpcService service;\n\nwhen(service.getAccount(\"id\")).thenReturn(...);\n```\n\nMy work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.\n\nBut because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).\n\nIf the idea sounds okay to give a try, I'll volunteer to submit a patch.\n\nThanks!\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_21": {
    "description": "Allow convenient spying on abstract classes\nI posted this in GoogleCode and was asked to submit in github.\n\nMockito is easy to use when the test needs to provide canned values for a certain method.\n\nBut it gets harder when a canned value isn't sufficient.\n##### Example 1: Fake with trivial Logic\n\n```\ninterface UserAccount {\n  List<String> getEmails();\n  void addEmail(String email);\n  // 12 other methods ...\n}\n```\n\nWhen mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.\n##### Example 2: callback-style API\n\n```\ninterface AccountService {\n  void getAccount(String id, AsyncCallback<UserAccount> callback);\n}\n```\n\nStubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:\n\n```\nwhen(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer<Void>() {\n  AsyncCallback<UserAccount> callback = (AsyncCallback<UserAccount>) getArguments()[1];\n  ...\n});\n```\n##### Example 3: Uninteresting parameters\n\n```\ninterface AccountRpcService {\n  FutureAccount getAccount(RpcContext context, String id);\n}\n```\n\nNone of the tests care about the context object. It's an uninteresting parameter imposed by the framework.\n\nIf AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:\n\n`when(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);`\n\nAnd all other parameters are required to be wrapped in eq().\n#### Proposal\n\nI propose adding support for abstract classes to mockito to make it easier to deal with tests like above:\n##### For example 1\n\n```\nabstract class FakeUserAccount implements UserAccount {\n  private final List<String> emails = new ArrayList<>();\n\n  @Override public void addEmail(String email) {\n    emails.add(email);\n  }\n  @Override List<String> getEmails() {\n    return ImmutableList.copyOf(emails);\n  }\n}\n\n@Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n```\n##### For example 2\n\n```\nabstract class MockAccountService implements AccountService {\n  @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {\n    callback.onSuccess(getAccount(id));\n  }\n  abstract UserAccount getAccount(String id);\n}\n\n@Fake private MockAccountService service;\n\n...\n\nwhen(service.getAccount(\"id\")).thenReturn(account);\n```\n##### For example 3\n\n```\nabstract class MockAccountRpcService implements AccountRpcService {\n  @Override Future<Account> getAccount(RpcContext context, String id) {\n    checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n    return getAccount(id);\n  }\n\n  abstract Future<Account> getAccount(String id);\n}\n\n@Fake private MockAccountRpcService service;\n\nwhen(service.getAccount(\"id\")).thenReturn(...);\n```\n\nMy work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.\n\nBut because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).\n\nIf the idea sounds okay to give a try, I'll volunteer to submit a patch.\n\nThanks!\n\n",
    "desc_source": "github_issue"
  },
  "Mockito_22": {
    "description": "areEqual does not try == operator for trivial equality case and sometimes has unneccessary exceptions\n<b>What steps will reproduce the problem?</b>\n1. Any class that throws an exception in its equals method.  For example:\r\n\r\nprivate final class BadEquals {\r\n   @Override\r\n        public boolean equals (Object oth) {\r\n\t      throw new RuntimeException();\r\n        }\r\n   }\r\n2. Create an instance of that class.  Object badequals=new BadEquals();\r\n3. Test for equality using org.mockito.internal.matchers.Equality.areEqual:  areEqual(badequals,badequals)\r\n\r\n<b>What is the expected output? What do you see instead?</b>\nI expect to see they are equal.\r\n\r\nI suspect that the areEqual method is calling the equals method which is throwing an Exception.  In this case, we can use the java equality operator to see that they are equal, bypassing the equals method and its exception.\r\n\r\n\r\n<b>What version of the product are you using? On what operating system?</b>\n\r\n\r\n<b>Please provide any additional information below.</b>",
    "desc_source": "google issue"
  },
  "Mockito_23": {
    "description": "Deep Stubs are not serializable\n<b>What steps will reproduce the problem?</b>\nimport org.junit.Test;\r\nimport org.mockito.Matchers;\r\nimport org.mockito.Mockito;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.util.Map;\r\n\r\npublic class DeepStubsAreNotSerializableTest {\r\n\r\n  @Test\r\n  public void name() throws Exception {\r\n    Map map = Mockito.mock(Map.class, Mockito.RETURNS_DEEP_STUBS);\r\n\r\n    Mockito.when(map.entrySet().contains(Matchers.anyString())).thenReturn(false);\r\n\r\n    ByteArrayOutputStream serialized = new ByteArrayOutputStream();\r\n    new ObjectOutputStream(serialized).writeObject(map);\r\n  }\r\n}\r\n\r\n<b>What is the expected output? What do you see instead?</b>\njava.io.NotSerializableException: org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs$1\r\n\tat java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1180)\r\n\tat java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:346)\r\n        ...\r\n\r\n<b>Please use labels and text to provide additional information.</b>\nMockito 1.9.5, and earlier versions",
    "desc_source": "google issue"
  },
  "Mockito_24": {
    "description": "compareTo returns 1 for the same object\n@Test\r\n    public void shouldCompareToTreatAsEqualMocksWithTheSameReferences() {\r\n        //given\r\n        Date today    = mock(Date.class);\r\n\r\n        //when\r\n        Set&lt;Date&gt; set = new TreeSet&lt;Date&gt;();\r\n        set.add(today);\r\n        set.add(today);\r\n\r\n        //then\r\n        assertEquals(1, set.size());\r\n    }\r\n\r\n<b>What is the expected output? What do you see instead?</b>\nTest passes\r\n\r\n<b>What version of the product are you using? On what operating system?</b>\nWindows/Linux x66 jdk1.7\r\n\r\n<b>Please provide any additional information below.</b>\ncomapreTo should take into account reference equality",
    "desc_source": "google issue"
  },
  "Mockito_25": {
    "description": "Deep mock fails for generic classes\nConsider the following sample:\r\n\r\n    static interface ListSet extends List&lt;Set&gt; {}\r\n    @Test\r\n    public void testDeepMockWithClass() {\r\n        final ListSet mock = Mockito.mock(ListSet.class, Mockito.RETURNS_DEEP_STUBS);\r\n        final Set mock2 = mock.get(0);\r\n    }\r\n\r\nI get an exception on the last line since mock.get(0) is not of type Set.\r\nI would expect Mockito to make the deep mock of the correct type instead of just Object.",
    "desc_source": "google issue"
  },
  "Mockito_26": {
    "description": "Mockito-mocked methods returning primitive types other than \"int\" throw ClassCastException: java.lang.Integer\nMockito is returning a boxed Integer when it should be returning a boxed Long. Similarly for other types. I'm preparing a fix and will have a pull request very soon. It would be great to get this fixed before 1.9.5 final is cut.\r\n\r\nSee dexmaker issue 10\r\nhttp://code.google.com/p/dexmaker/issues/detail?id=10",
    "desc_source": "google issue"
  },
  "Mockito_27": {
    "description": "MockUtil.resetMock() doesn't create InvocationNotifierHandler when recreating a filter\n<b>What steps will reproduce the problem?</b>\n1. create a mock with verbose logging\r\n2. reset a mock\r\n\r\n<b>What is the expected output? What do you see instead?</b>\nVerbose logging doesn't work after reseting a mock.\r\n\r\n<b>What version of the product are you using? On what operating system?</b>\n1.9.0-rc1\r\n\r\nPatch attached.",
    "desc_source": "google issue"
  },
  "Mockito_28": {
    "description": "@InjectMocks injects mock into Object-typed fields\nWhen using @InjectMocks on a class which has fields of the type &quot;Object&quot;, the mock gets injected into that field instead of being only injected into the field it is supposed to be injected to.\r\n\r\nSee attachments for a testcase on this problem.\r\n\r\nIt would be better if @InjectMocks would leave the Object fields alone, because this behaviour is not expected and it is causing my own unit tests to fail. One example of such a failure is the production code having a Object-constant (see the commented out one in TestService as illustration) which mockito tries to override with a mock, but fails because PowerMock is not available. \r\n\r\nAnd even if i set the Object-field to non-static, it mangles the logic of my production code, because on class initialization the object is used to register a listener in a different class with that object as a map accessor. Now when mockito overrides the Object-field, the requests are added with the mock object instead of the original Object-instance and thus no listeners are being found by the async service my service uses.\r\n\r\nI don't like the idea of removing the Object-field as an accessor to instead use &quot;this&quot; (not explicit enough for readability purposes) or some other type as the accessor-type (just more code), instead I think this should better be fixed.\r\n\r\nSurely there will be more occasions this will make me problems in writing unit tests.\r\n\r\nBest regards\r\nsubes",
    "desc_source": "google issue"
  },
  "Mockito_29": {
    "description": "@Mock fields in super test class are not injected on @InjectMocks fields\n<b>What steps will reproduce the problem?</b>\n1. Consider there are 2 Junit 4 tests, one is BaseTest and the other is ImplicitTest like bellow:\r\n   @Ignore\r\n   public abstract class BaseTest {\r\n     @Mock\r\n     protected DaoA dao;\r\n     \r\n   }\r\n\r\n   \r\n   public class ImplicitTest extends BaseTest {\r\n     @InjectMocks\r\n     private SystemUnderTest sut = new SystemUnderTest();\r\n\r\n     @Before\r\n     public void setup() {\r\n       MockitoAnnotations.initMocks(this);\r\n     }\r\n    \r\n     @Test\r\n     public void test1() {\r\n        sut.businessMethodA();\r\n     }     \r\n   }\r\n\r\n   public class SystemUnderTest {\r\n     private DaoA dao;\r\n     public void setDao(DaoA dao) {\r\n       this.dao = dao;\r\n     }\r\n     \r\n     public void businessMethodA() {\r\n        dao.doQuery();\r\n     }\r\n   }\r\n\r\n\r\n   public class DaoA {\r\n     public void doQuery(){\r\n     }\r\n   }\r\n2. when I run &quot;test1()&quot; method, a NullPointException will throw out as bellow:\r\n   java.lang.NullPointerException\r\n\tat SystemUnderTest.businessMethodA(SystemUnderTest.java:9)\r\n\tat ImplicitTest.test1(ImplicitTest.java:17)\r\n\r\n3. when I add one more line code in &quot;test1()&quot; then the case can pass, the &quot;test1()&quot; method when the case pass is :\r\n    @Test\r\n    public void test1() {\r\n        sut.setDao(dao);\r\n        sut.businessMethodA();\r\n    }\r\n\r\n\r\n<b>What is the expected output? What do you see instead?</b>\nexpected: I can inject the mock object defined by @Mock in super class\r\nactual :  The mock object defined by @Mock annotation in super class can NOT inject into the SUT defined in child class.\r\n\r\n<b>What version of the product are you using? On what operating system?</b>\nMockito Version: mockito-all-1.8.5.jar\r\nOperation System: windows vista\r\njava -version :\r\njava version &quot;1.6.0_20&quot;\r\nJava(TM) SE Runtime Environment (build 1.6.0_20-b02)\r\nJava HotSpot(TM) Client VM (build 16.3-b01, mixed mode, sharing)\r\n\r\n<b>Please provide any additional information below.</b>",
    "desc_source": "google issue"
  },
  "Mockito_30": {
    "description": "SmartNulls should identify the arguments that the stubbed method was invoked with\nI've started mocking with RETURNS_SMART_NULLS. It is very useful and I like the fact that it can be configured with the @Mock annotation. I agree with the comment that it should be the default in Mockito 2.0. Returning null values from mocked methods encourages writing code that is designed to handle nulls, which IMO is a code smell.\r\n\r\nOne thing that would be really nice is if the arguments of the stubbed method were retained and then printed when the smart null is used. The reported message is typically correct: &quot;Because this method was *not* stubbed correctly:&quot;, but this is generally because I've made some mistake in matching the parameters of the stubbed method. If I could see the arguments that were used in the invocation it would mean that I wouldn't need to debug into the method to check them.",
    "desc_source": "google issue"
  },
  "Mockito_31": {
    "description": "SmartNulls should identify the arguments that the stubbed method was invoked with\nI've started mocking with RETURNS_SMART_NULLS. It is very useful and I like the fact that it can be configured with the @Mock annotation. I agree with the comment that it should be the default in Mockito 2.0. Returning null values from mocked methods encourages writing code that is designed to handle nulls, which IMO is a code smell.\r\n\r\nOne thing that would be really nice is if the arguments of the stubbed method were retained and then printed when the smart null is used. The reported message is typically correct: &quot;Because this method was *not* stubbed correctly:&quot;, but this is generally because I've made some mistake in matching the parameters of the stubbed method. If I could see the arguments that were used in the invocation it would mean that I wouldn't need to debug into the method to check them.",
    "desc_source": "google issue"
  },
  "Mockito_32": {
    "description": "the field name not used to identify @Spy objects\nspy objects created with @Spy annotation are note named against the field name, as mocks created with @Mock.\r\nI'd like to have this feature to use @InjectMocks with two spy objects of the same type.",
    "desc_source": "google issue"
  },
  "Mockito_33": {
    "description": "polimorphic call not dispatched correctly\nEdge case around generics + inheritance. Below code did not work correctly due to polimorphic call not dispatched to correct method.\r\n\r\n\r\n    protected interface MyIterable&lt;T&gt; extends Iterable&lt;T&gt; {\r\n        public MyIterator&lt;T&gt; iterator();\r\n    }\r\n\r\n    protected interface MyIterator&lt;T&gt; extends Iterator&lt;T&gt; {\r\n        // adds nothing here\r\n    }\r\n\r\n    MyIterator&lt;String&gt; myIterator = Mockito.mock(MyIterator.class);\r\n    MyIterable&lt;String&gt; iterable = Mockito.mock(MyIterable.class);\r\n\r\n    @Test\r\n    public void shouldStubbingWork() {\r\n        Mockito.when(iterable.iterator()).thenReturn(myIterator);\r\n        Assert.assertNotNull(((Iterable) iterable).iterator());\r\n        Assert.assertNotNull(iterable.iterator());\r\n    }\r\n    \r\n    @Test\r\n    public void shouldVerificationWorks() {\r\n        iterable.iterator();\r\n        \r\n        verify(iterable).iterator();\r\n        verify((Iterable) iterable).iterator();\r\n    }",
    "desc_source": "google issue"
  },
  "Mockito_34": {
    "description": "Invocation.thenReturn() may fail with varargs (similar to issue 123)\n<b>What steps will reproduce the problem?</b>\n1. Has a class with a method like this: blah(Object... o)\r\n2. Stub it like this: when(mock.blah(anyVararg())).thenReturn(-1)\r\n3. Run test.\r\n\r\n<b>What is the expected output? What do you see instead?</b>\nIt should return -1 on both calls, instead it threw an \r\nArrayIndexOutOfBoundsException on the second assert\r\n\r\n<b>What version of the product are you using? On what operating system?</b>\n1.8.1\r\nMacOS 10.5.8\r\n\r\n<b>Please provide any additional information below.</b>\n\tclass Foo {\r\n\t\tint blah(Object... o) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void shouldNotThrowAnyException() throws Exception {\r\n\t\tFoo foo = mock(Foo.class);\r\n\r\n\t\twhen(foo.blah(anyVararg())).thenReturn(-1);\r\n\t\t\r\n\t\tassertEquals(-1, foo.blah(&quot;foo&quot;));\r\n\t\tassertEquals(-1, foo.blah());\r\n\t}",
    "desc_source": "google issue"
  },
  "Mockito_35": {
    "description": "Verification using isA(int.class) gives NullPointerException\n<b>What steps will reproduce the problem?</b>\n1. Create an object that has a method do(int aValue)\r\n2. Create a spy for this object. T spy = spy(obj)\r\n3. Verify behavior using verify(spy).do(isA(int.class))\r\n\r\n<b>What is the expected output? What do you see instead?</b>\n\r\nExpected output is that there will be a normal verification (either pass\r\nthe test or &quot;wanted but not invoked&quot; result). \r\n\r\n<b>What version of the product are you using? On what operating system?</b>\n\r\n1.7, SLED 10 \r\n\r\n<b>Please provide any additional information below.</b>\n\r\nThis issue is mainly a usability issue. It is strange however that\r\nisA(String.class) works but isA(int.class) does not. Also\r\nisA(Integer.class) does not work. \r\n\r\nThis problem is mainly a usability issue. It occurs only for methods that\r\nhave primitive arguments instead of objects. In any case, either mockito\r\nshould support the verifications (preferred) or it should give a clear\r\nerror message when running the test. Currently, we get a NullPointerException: \r\n\r\njava.lang.NullPointerException\r\n\tat itoamapi.MockitoTest.testX(MockitoTest.java:22)\r\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\r\n\tat\r\nsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\r\n\tat\r\nsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\r\n\tat java.lang.reflect.Method.invoke(Method.java:597)\r\n\tat junit.framework.TestCase.runTest(TestCase.java:168)\r\n\tat junit.framework.TestCase.runBare(TestCase.java:134)\r\n\tat junit.framework.TestResult$1.protect(TestResult.java:110)\r\n\tat junit.framework.TestResult.runProtected(TestResult.java:128)\r\n\tat junit.framework.TestResult.run(TestResult.java:113)\r\n\tat junit.framework.TestCase.run(TestCase.java:124)\r\n\tat junit.framework.TestSuite.runTest(TestSuite.java:232)\r\n\tat junit.framework.TestSuite.run(TestSuite.java:227)\r\n\tat\r\norg.junit.internal.runners.OldTestClassRunner.run(OldTestClassRunner.java:76)\r\n\tat\r\norg.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)\r\n\tat\r\norg.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\r\n\tat\r\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\r\n\tat\r\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\r\n\tat\r\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\r\n\tat\r\norg.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)",
    "desc_source": "google issue"
  },
  "Mockito_36": {
    "description": "Inform the user immediately when she tries to 'callRealMethod()' on a mock of a interface\nInform the user immediately when she tries to 'callRealMethod()' on a mock\r\nof a interface:\r\n\r\n//fail fast when:\r\nwhen(mockOfAnIterface.doStuff()).thenCallRealMethod();",
    "desc_source": "google issue"
  },
  "Mockito_37": {
    "description": "Inform the user immediately when she tries to 'callRealMethod()' on a mock of a interface\nInform the user immediately when she tries to 'callRealMethod()' on a mock\r\nof a interface:\r\n\r\n//fail fast when:\r\nwhen(mockOfAnIterface.doStuff()).thenCallRealMethod();",
    "desc_source": "google issue"
  },
  "Mockito_38": {
    "description": "Mockito's sources in the central Maven repository should be in a *-sources.jar file\nRight now, in http://repo1.maven.org/maven2/org/mockito/, the binaries and sources of \r\nMockito are packed in the same JAR file (e.g. mockito-all-1.7.jar). This is against \r\nthe Maven conventions. As a result, at least IntelliJ IDEA does not automatically \r\ndetect the sources (i.e. no quick access to documentation, no seeing of method \r\nparameter names).\r\n\r\nThe convention in Maven is to have the binaries in one JAR, the sources in another JAR \r\nwhose name is prefixed &quot;-sources&quot; and the javadocs in a third JAR prefixed &quot;-javadoc&quot;. \r\nSee http:// \r\nmaven.apache.org/guides/mini/guide-central-repository- \r\nupload.html#Manual_upload_of_artifacts\r\n\r\nThe expected way to organize the files is:\r\n\r\nmockito-all-X.Y.jar  -- the .class files and everything that is required at runtime\r\nmockito-all-X.Y-sources.jar  -- the .java files and other sources\r\nmockito-all-X.Y-javadoc.jar  -- the javadocs (I don't use them, but maybe someone else \r\nlikes them)\r\n\r\nOrganizing them like this makes the library compatible with all Maven users. An added \r\nbenefit is that the binaries JAR becomes about 50% smaller, because the source code \r\nwill be in a separate file.",
    "desc_source": "google issue"
  }
}